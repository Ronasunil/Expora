// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"7m0pj":[function(require,module,exports) {
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _toConsumableArray = require("@swc/helpers/_/_to_consumable_array");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "551a4600f4d1a273";
module.bundle.HMR_BUNDLE_ID = "588f3fd31428e851";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && ![
        "localhost",
        "127.0.0.1",
        "0.0.0.0"
    ].includes(hostname) ? "wss" : "ws";
    var ws;
    try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = function() {
        var _ref = (0, _asyncToGenerator._)(function(event /*: {data: string, ...} */ ) {
            var data /*: HMRMessage */ , assets, handled, processedAssets, i, id, i1, id1, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, ansiDiagnostic, stack, overlay;
            return (0, _tsGenerator._)(this, function(_state) {
                switch(_state.label){
                    case 0:
                        checkedAssets = {} /*: {|[string]: boolean|} */ ;
                        assetsToAccept = [];
                        assetsToDispose = [];
                        data = JSON.parse(event.data);
                        if (!(data.type === "update")) return [
                            3,
                            3
                        ];
                        // Remove error overlay if there is one
                        if (typeof document !== "undefined") removeErrorOverlay();
                        assets = data.assets.filter(function(asset) {
                            return asset.envHash === HMR_ENV_HASH;
                        });
                        // Handle HMR Update
                        handled = assets.every(function(asset) {
                            return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
                        });
                        if (!handled) return [
                            3,
                            2
                        ];
                        console.clear();
                        // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                        if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                        return [
                            4,
                            hmrApplyUpdates(assets)
                        ];
                    case 1:
                        _state.sent();
                        // Dispose all old assets.
                        processedAssets = {} /*: {|[string]: boolean|} */ ;
                        for(i = 0; i < assetsToDispose.length; i++){
                            id = assetsToDispose[i][1];
                            if (!processedAssets[id]) {
                                hmrDispose(assetsToDispose[i][0], id);
                                processedAssets[id] = true;
                            }
                        }
                        // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                        processedAssets = {};
                        for(i1 = 0; i1 < assetsToAccept.length; i1++){
                            id1 = assetsToAccept[i1][1];
                            if (!processedAssets[id1]) {
                                hmrAccept(assetsToAccept[i1][0], id1);
                                processedAssets[id1] = true;
                            }
                        }
                        return [
                            3,
                            3
                        ];
                    case 2:
                        fullReload();
                        _state.label = 3;
                    case 3:
                        if (data.type === "error") {
                            _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                // Log parcel errors to console
                                for(_iterator = data.diagnostics.ansi[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    ansiDiagnostic = _step.value;
                                    stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                                    console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                            if (typeof document !== "undefined") {
                                // Render the fancy html overlay
                                removeErrorOverlay();
                                overlay = createErrorOverlay(data.diagnostics.html);
                                // $FlowFixMe
                                document.body.appendChild(overlay);
                            }
                        }
                        return [
                            2
                        ];
                }
            });
        });
        return function(event) {
            return _ref.apply(this, arguments);
        };
    }();
    ws.onerror = function(e) {
        if (e.message) console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = diagnostics[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var diagnostic = _step.value;
            var stack = diagnostic.frames.length ? diagnostic.frames.reduce(function(p, frame) {
                return "".concat(p, '\n<a href="/__parcel_launch_editor?file=').concat(encodeURIComponent(frame.location), '" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">').concat(frame.location, "</a>\n").concat(frame.code);
            }, "") : diagnostic.stack;
            errorHTML += '\n      <div>\n        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">\n          \uD83D\uDEA8 '.concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return "<div>\uD83D\uDCA1 " + hint + "</div>";
            }).join(""), "\n        </div>\n        ").concat(diagnostic.documentation ? '<div>\uD83D\uDCDD <a style="color: violet" href="'.concat(diagnostic.documentation, '" target="_blank">Learn more</a></div>') : "", "\n      </div>\n    ");
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            var script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise(function(resolve, reject) {
                var _document$head;
                script.onload = function() {
                    return resolve(script);
                };
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise(function(resolve, reject) {
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
function hmrApplyUpdates(assets) {
    return _hmrApplyUpdates.apply(this, arguments);
}
function _hmrApplyUpdates() {
    _hmrApplyUpdates = (0, _asyncToGenerator._)(function(assets) {
        var scriptsToRemove, promises;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    global.parcelHotUpdate = Object.create(null);
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        ,
                        4,
                        5
                    ]);
                    if (!!supportsSourceURL) return [
                        3,
                        3
                    ];
                    promises = assets.map(function(asset) {
                        var _hmrDownload;
                        return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch(function(err) {
                            // Web extension fix
                            if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                                extCtx.runtime.reload();
                                return;
                            }
                            throw err;
                        });
                    });
                    return [
                        4,
                        Promise.all(promises)
                    ];
                case 2:
                    scriptsToRemove = _state.sent();
                    _state.label = 3;
                case 3:
                    assets.forEach(function(asset) {
                        hmrApply(module.bundle.root, asset);
                    });
                    return [
                        3,
                        5
                    ];
                case 4:
                    delete global.parcelHotUpdate;
                    if (scriptsToRemove) scriptsToRemove.forEach(function(script) {
                        if (script) {
                            var _document$head2;
                            (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
                        }
                    });
                    return [
                        7
                    ];
                case 5:
                    return [
                        2
                    ];
            }
        });
    });
    return _hmrApplyUpdates.apply(this, arguments);
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                var oldDeps = modules[asset.id][1];
                for(var dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    var id = oldDeps[dep];
                    var parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            var fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    var modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        var deps = modules[id][1];
        var orphans = [];
        for(var dep in deps){
            var parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach(function(id) {
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    var parents = getParents(module.bundle.root, id);
    var accepted = false;
    while(parents.length > 0){
        var v = parents.shift();
        var a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            var _parents;
            // Otherwise, queue the parents in the next level upward.
            var p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            (_parents = parents).push.apply(_parents, (0, _toConsumableArray._)(p));
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_to_consumable_array":"ig3r6","@swc/helpers/_/_ts_generator":"dhhs4"}],"6EzFB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_async_to_generator", function() {
    return _async_to_generator;
});
parcelHelpers.export(exports, "_", function() {
    return _async_to_generator;
});
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) resolve(value);
    else Promise.resolve(value).then(_next, _throw);
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"3XTd0":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function get() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"ig3r6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_to_consumable_array", function() {
    return _to_consumable_array;
});
parcelHelpers.export(exports, "_", function() {
    return _to_consumable_array;
});
var _arrayWithoutHolesJs = require("./_array_without_holes.js");
var _iterableToArrayJs = require("./_iterable_to_array.js");
var _nonIterableSpreadJs = require("./_non_iterable_spread.js");
var _unsupportedIterableToArrayJs = require("./_unsupported_iterable_to_array.js");
function _to_consumable_array(arr) {
    return (0, _arrayWithoutHolesJs._array_without_holes)(arr) || (0, _iterableToArrayJs._iterable_to_array)(arr) || (0, _unsupportedIterableToArrayJs._unsupported_iterable_to_array)(arr) || (0, _nonIterableSpreadJs._non_iterable_spread)();
}

},{"./_array_without_holes.js":"3ejLp","./_iterable_to_array.js":"frgWD","./_non_iterable_spread.js":"3FLQR","./_unsupported_iterable_to_array.js":"vagJ6","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"3ejLp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_array_without_holes", function() {
    return _array_without_holes;
});
parcelHelpers.export(exports, "_", function() {
    return _array_without_holes;
});
var _arrayLikeToArrayJs = require("./_array_like_to_array.js");
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return (0, _arrayLikeToArrayJs._array_like_to_array)(arr);
}

},{"./_array_like_to_array.js":"j7GHA","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"j7GHA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_array_like_to_array", function() {
    return _array_like_to_array;
});
parcelHelpers.export(exports, "_", function() {
    return _array_like_to_array;
});
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"frgWD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_iterable_to_array", function() {
    return _iterable_to_array;
});
parcelHelpers.export(exports, "_", function() {
    return _iterable_to_array;
});
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"3FLQR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_non_iterable_spread", function() {
    return _non_iterable_spread;
});
parcelHelpers.export(exports, "_", function() {
    return _non_iterable_spread;
});
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"vagJ6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_unsupported_iterable_to_array", function() {
    return _unsupported_iterable_to_array;
});
parcelHelpers.export(exports, "_", function() {
    return _unsupported_iterable_to_array;
});
var _arrayLikeToArrayJs = require("./_array_like_to_array.js");
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return (0, _arrayLikeToArrayJs._array_like_to_array)(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0, _arrayLikeToArrayJs._array_like_to_array)(o, minLen);
}

},{"./_array_like_to_array.js":"j7GHA","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"dhhs4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", function() {
    return 0, _tslib.__generator;
});
parcelHelpers.export(exports, "_ts_generator", function() {
    return 0, _tslib.__generator;
});
var _tslib = require("tslib");

},{"tslib":"hzrXS","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"hzrXS":[function(require,module,exports) {
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__extends", function() {
    return __extends;
});
parcelHelpers.export(exports, "__assign", function() {
    return __assign;
});
parcelHelpers.export(exports, "__rest", function() {
    return __rest;
});
parcelHelpers.export(exports, "__decorate", function() {
    return __decorate;
});
parcelHelpers.export(exports, "__param", function() {
    return __param;
});
parcelHelpers.export(exports, "__esDecorate", function() {
    return __esDecorate;
});
parcelHelpers.export(exports, "__runInitializers", function() {
    return __runInitializers;
});
parcelHelpers.export(exports, "__propKey", function() {
    return __propKey;
});
parcelHelpers.export(exports, "__setFunctionName", function() {
    return __setFunctionName;
});
parcelHelpers.export(exports, "__metadata", function() {
    return __metadata;
});
parcelHelpers.export(exports, "__awaiter", function() {
    return __awaiter;
});
parcelHelpers.export(exports, "__generator", function() {
    return __generator;
});
parcelHelpers.export(exports, "__createBinding", function() {
    return __createBinding;
});
parcelHelpers.export(exports, "__exportStar", function() {
    return __exportStar;
});
parcelHelpers.export(exports, "__values", function() {
    return __values;
});
parcelHelpers.export(exports, "__read", function() {
    return __read;
});
/** @deprecated */ parcelHelpers.export(exports, "__spread", function() {
    return __spread;
});
/** @deprecated */ parcelHelpers.export(exports, "__spreadArrays", function() {
    return __spreadArrays;
});
parcelHelpers.export(exports, "__spreadArray", function() {
    return __spreadArray;
});
parcelHelpers.export(exports, "__await", function() {
    return __await;
});
parcelHelpers.export(exports, "__asyncGenerator", function() {
    return __asyncGenerator;
});
parcelHelpers.export(exports, "__asyncDelegator", function() {
    return __asyncDelegator;
});
parcelHelpers.export(exports, "__asyncValues", function() {
    return __asyncValues;
});
parcelHelpers.export(exports, "__makeTemplateObject", function() {
    return __makeTemplateObject;
});
parcelHelpers.export(exports, "__importStar", function() {
    return __importStar;
});
parcelHelpers.export(exports, "__importDefault", function() {
    return __importDefault;
});
parcelHelpers.export(exports, "__classPrivateFieldGet", function() {
    return __classPrivateFieldGet;
});
parcelHelpers.export(exports, "__classPrivateFieldSet", function() {
    return __classPrivateFieldSet;
});
parcelHelpers.export(exports, "__classPrivateFieldIn", function() {
    return __classPrivateFieldIn;
});
parcelHelpers.export(exports, "__addDisposableResource", function() {
    return __addDisposableResource;
});
parcelHelpers.export(exports, "__disposeResources", function() {
    return __disposeResources;
});
var _typeOf = require("@swc/helpers/_/_type_of");
var extendStatics = function extendStatics1(d, b) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return extendStatics(d, b);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function __assign1() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
}
function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++)value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    return useValue ? value : void 0;
}
function __propKey(x) {
    return (typeof x === "undefined" ? "undefined" : (0, _typeOf._)(x)) === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
    if ((typeof name === "undefined" ? "undefined" : (0, _typeOf._)(name)) === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", {
        configurable: true,
        value: prefix ? "".concat(prefix, " ", name) : name
    });
}
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function sent() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var __createBinding = Object.create ? function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
};
function __exportStar(m, o) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function __spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
}
function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    function verb(n) {
        if (g[n]) i[n] = function(v) {
            return new Promise(function(a, b) {
                q.push([
                    n,
                    v,
                    a,
                    b
                ]) > 1 || resume(n, v);
            });
        };
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: false
            } : f ? f(v) : v;
        } : f;
    }
}
function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) Object.defineProperty(cooked, "raw", {
        value: raw
    });
    else cooked.raw = raw;
    return cooked;
}
var __setModuleDefault = Object.create ? function __setModuleDefault(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
};
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
}
function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({
            value: value,
            dispose: dispose,
            async: async
        });
    } else if (async) env.stack.push({
        async: true
    });
    return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function _SuppressedError(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
    function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
    }
    function next() {
        while(env.stack.length){
            var rec = env.stack.pop();
            try {
                var result = rec.dispose && rec.dispose.call(rec.value);
                if (rec.async) return Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                });
            } catch (e) {
                fail(e);
            }
        }
        if (env.hasError) throw env.error;
    }
    return next();
}
exports.default = {
    __extends: __extends,
    __assign: __assign,
    __rest: __rest,
    __decorate: __decorate,
    __param: __param,
    __metadata: __metadata,
    __awaiter: __awaiter,
    __generator: __generator,
    __createBinding: __createBinding,
    __exportStar: __exportStar,
    __values: __values,
    __read: __read,
    __spread: __spread,
    __spreadArrays: __spreadArrays,
    __spreadArray: __spreadArray,
    __await: __await,
    __asyncGenerator: __asyncGenerator,
    __asyncDelegator: __asyncDelegator,
    __asyncValues: __asyncValues,
    __makeTemplateObject: __makeTemplateObject,
    __importStar: __importStar,
    __importDefault: __importDefault,
    __classPrivateFieldGet: __classPrivateFieldGet,
    __classPrivateFieldSet: __classPrivateFieldSet,
    __classPrivateFieldIn: __classPrivateFieldIn,
    __addDisposableResource: __addDisposableResource,
    __disposeResources: __disposeResources
};

},{"@swc/helpers/_/_type_of":"b4wfg","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"b4wfg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_type_of", function() {
    return _type_of;
});
parcelHelpers.export(exports, "_", function() {
    return _type_of;
});
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"jDAbT":[function(require,module,exports) {
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var _home = require("./home");
var _signup = require("./signup");
var _otp = require("./otp");
var _login = require("./login");
var _tours = require("./tours");
var _profile = require("./profile");
var _detail = require("./detail");
var _stripe = require("./stripe");
var _checkout = require("./checkout");
var _userProfile = require("./userProfile");
var _map = require("./map");
var _memories = require("./memories");
var _forgetPassword = require("./forgetPassword");
var _resetPassword = require("./resetPassword");
var _coupon = require("./coupon");
var _routeChanger = require("./routeChanger");
var _renderProfile = require("./renderProfile");
var editFormvalid;
var signupBtn = document.querySelector(".signup-btn");
var otpBtn = document.querySelector(".btn-otp");
var loginForm = document.querySelector(".login-form");
var toursSearchBtn = document.querySelector(".search-bar");
var categoreyOptions = document.querySelector(".options");
var topToursBtn = document.querySelector(".top-tours ");
var allToursBtn = document.querySelector(".all-tours");
var resendOtpLink = document.querySelector(".resend-otp");
var addTourBtn = document.querySelector(".fa-plus");
var purchaseBtn = document.querySelector(".purchase-btn");
var couponBtn = document.querySelector(".coupon-apply");
var checkoutBtn = document.querySelector(".checkout-btn");
var cancelBtn = document.querySelector(".cancel-btn");
var userBookingsBtn = document.querySelector(".bookings-btn");
var adminBookingsBtn = document.querySelector(".admin-bookings-btn");
var bookmarkBtn = document.querySelector(".bookmark-icon");
var feedbackBtn = document.querySelector(".feedback-btn");
var securityBtn = document.querySelector(".security-btn");
var memoriesSubmitBtn = document.querySelector(".memories-submit-btn");
var memoriesBtn = document.querySelector(".memories-btn");
var resetPasswordSubmitBtn = document.querySelector(".reset-password-btn");
var forgetPasswordLabel = document.querySelector(".label-forget-password");
var recoveryBtn = document.querySelector(".recovery-btn");
var allBookmarkBtn = document.querySelector(".bookmark-user-btn");
var reviewStars = document.querySelector(".stars");
var reviewsSubmitBtn = document.querySelector(".review-feedback-btn");
var slideLeft = document.querySelector(".slide-left");
var slideRight = document.querySelector(".slide-right");
var analyticsBtn = document.querySelector(".analytics-btn");
var menuBtn = document.querySelector(".btn-mobile-nav");
var couponsBtn = document.querySelector(".coupon-btn");
var addCouponsBtn = document.querySelector(".add-coupon-btn");
var notificationBtn = document.querySelector(".notification-btn");
var profileBtn = document.querySelector(".user-profile-btn");
var moreToursLink = document.querySelector(".more-tours");
var catgorizeOptionContainer = document.querySelector(".catogrizing-opt");
var iconRight = document.querySelector(".icon-right");
var iconLeft = document.querySelector(".icon-left");
var walletBtn = document.querySelector(".wallet-btn");
// map container
var mapContainer = document.getElementById("map");
// container
var itemsContainer = document.querySelector(".dash-board-items");
// admin panel btns
var usersBtn = document.querySelector(".users-btn");
var toursBtn = document.querySelector(".tours-btn");
// menu btn in home page
menuBtn === null || menuBtn === void 0 ? void 0 : menuBtn.addEventListener("click", (0, _home.showMenu));
signupBtn === null || signupBtn === void 0 ? void 0 : signupBtn.addEventListener("click", (0, _signup.validateFormAndSendData));
otpBtn === null || otpBtn === void 0 ? void 0 : otpBtn.addEventListener("click", (0, _otp.verifyOtp));
loginForm === null || loginForm === void 0 ? void 0 : loginForm.addEventListener("submit", (0, _login.loginUser));
toursSearchBtn === null || toursSearchBtn === void 0 ? void 0 : toursSearchBtn.addEventListener("keyup", (0, _tours.searchTours));
categoreyOptions === null || categoreyOptions === void 0 ? void 0 : categoreyOptions.addEventListener("change", (0, _tours.categorizeTour));
topToursBtn === null || topToursBtn === void 0 ? void 0 : topToursBtn.addEventListener("click", (0, _tours.renderTopTours));
allToursBtn === null || allToursBtn === void 0 ? void 0 : allToursBtn.addEventListener("click", (0, _tours.renderAllTours));
moreToursLink === null || moreToursLink === void 0 ? void 0 : moreToursLink.addEventListener("click", function(e) {
    e.preventDefault();
    localStorage.clear();
    location.assign("/tours");
});
resendOtpLink === null || resendOtpLink === void 0 ? void 0 : resendOtpLink.addEventListener("click", (0, _otp.resendOtp));
usersBtn === null || usersBtn === void 0 ? void 0 : usersBtn.addEventListener("click", (0, _profile.showUsers));
toursBtn === null || toursBtn === void 0 ? void 0 : toursBtn.addEventListener("click", (0, _profile.showTours));
purchaseBtn === null || purchaseBtn === void 0 ? void 0 : purchaseBtn.addEventListener("click", (0, _detail.renderBookingDates));
couponBtn === null || couponBtn === void 0 ? void 0 : couponBtn.addEventListener("click", (0, _checkout.applyCoupon));
checkoutBtn === null || checkoutBtn === void 0 ? void 0 : checkoutBtn.addEventListener("click", (0, _checkout.checkout)((0, _stripe.bookTour)));
cancelBtn === null || cancelBtn === void 0 ? void 0 : cancelBtn.addEventListener("click", function() {
    var bookingId = this.dataset.bookingId;
    (0, _userProfile.renderCancellationWindow)((0, _stripe.cancelBooking), bookingId);
});
userBookingsBtn === null || userBookingsBtn === void 0 ? void 0 : userBookingsBtn.addEventListener("click", (0, _userProfile.renderBookings));
adminBookingsBtn === null || adminBookingsBtn === void 0 ? void 0 : adminBookingsBtn.addEventListener("click", (0, _profile.showAllBookings));
bookmarkBtn === null || bookmarkBtn === void 0 ? void 0 : bookmarkBtn.addEventListener("click", (0, _detail.bookmark));
allBookmarkBtn === null || allBookmarkBtn === void 0 ? void 0 : allBookmarkBtn.addEventListener("click", (0, _userProfile.renderBookmarks));
notificationBtn === null || notificationBtn === void 0 ? void 0 : notificationBtn.addEventListener("click", (0, _profile.renderNotificationMenu));
profileBtn === null || profileBtn === void 0 ? void 0 : profileBtn.addEventListener("click", (0, _renderProfile.renderProfile));
// DOM TRAVERSING
itemsContainer === null || itemsContainer === void 0 ? void 0 : itemsContainer.addEventListener("click", function() {
    var _ref = (0, _asyncToGenerator._)(function(e) {
        var slug, slug1, slug2, slug3, bookingId, bookingUUID, couponId, selectEl, bookingId1;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (e.target.classList.contains("admin-user-delete-btn")) {
                        slug = e.target.closest(".item").dataset.slug;
                        (0, _profile.adminAction)(slug, {
                            isDeleted: true
                        }, "User is deleted");
                    }
                    // Dom traversing for unblock-btn user (Admin only)
                    if (e.target.classList.contains("admin-user-unblock-btn")) {
                        slug1 = e.target.closest(".item").dataset.slug;
                        (0, _profile.adminAction)(slug1, {
                            isBlocked: false
                        }, "User is unblocked");
                    }
                    // Dom traversing for block-btn user (Admin only)
                    if (e.target.classList.contains("admin-user-block-btn")) {
                        slug2 = e.target.closest(".item").dataset.slug;
                        (0, _profile.adminAction)(slug2, {
                            isBlocked: true
                        }, "User is blocked");
                    }
                    if (!e.target.classList.contains("admin-tour-edit-btn")) return [
                        3,
                        2
                    ];
                    slug3 = e.target.closest(".item").dataset.slug;
                    return [
                        4,
                        (0, _profile.editPopup)(slug3)
                    ];
                case 1:
                    editFormvalid = _state.sent();
                    _state.label = 2;
                case 2:
                    // Dom traversing for tour verifying or proccesing btn (Admin only)
                    if (e.target.classList.contains("admin-tour-verify-btn")) {
                        // bookingCode for identifying tour from db
                        bookingId = e.target.closest(".item").dataset.slug;
                        // updating status in booking
                        (0, _profile.updateBooking)(bookingId, "confirmed", "Booking verified");
                    }
                    // Dom traversing for booked tour rejecting btn (Admin only)
                    if (e.target.classList.contains("admin-tour-reject-btn")) {
                        // bookingCode for identifying tour from db
                        bookingUUID = e.target.closest(".item").dataset.slug;
                        // updating status in booking
                        (0, _profile.updateBooking)(bookingUUID, "cancelled", "Booking rejected");
                    }
                    //Dom traversing for download btn
                    if (e.target.classList.contains("download-btn")) (0, _profile.renderDatePicker)(function(obj) {
                        if (!obj) return;
                        (0, _profile.downloadSalesReport)(obj);
                    });
                    // Dom traversing for edit btn of coupon
                    if (e.target.classList.contains("admin-coupon-edit-btn")) (0, _profile.renderCouponEditPopup)(e, (0, _coupon.editCoupon));
                    // Dom traversing for delete btn of coupon
                    if (e.target.classList.contains("admin-coupon-delete-btn")) {
                        couponId = e.target.dataset.couponId;
                        (0, _coupon.deleteCoupon)(couponId);
                    }
                    // Dom traversing for select button for group tour
                    if (e.target.classList.contains("booking-select")) {
                        selectEl = e.target;
                        bookingId1 = selectEl.value;
                        (0, _profile.renderGroupedBookings)(bookingId1);
                    }
                    // Dom traversing for send notification button
                    if (e.target.classList.contains("notification-btn")) (0, _profile.sendNotification)(e);
                    // Dom traversing for profile editing
                    if (e.target.classList.contains("profile-img")) (0, _renderProfile.previewImage)();
                    // Dom traversing for updating profile or save btn
                    if (e.target.classList.contains("profile-form-btn")) (0, _renderProfile.updateProfileDetails)(e);
                    return [
                        2
                    ];
            }
        });
    });
    return function(e) {
        return _ref.apply(this, arguments);
    };
}());
// edit tour submit button
document.addEventListener("click", function(e) {
    if (!(editFormvalid === null || editFormvalid === void 0 ? void 0 : editFormvalid.value)) return;
    if (e.target.classList.contains("swal2-confirm")) {
        var inputTourName = document.querySelector(".input-tour-name");
        var inputCatagorey = document.querySelector(".input-catagorey");
        var inputDifficulty = document.querySelector(".input-difficulty");
        var inputMaxPeople = document.querySelector(".input-max-people");
        var inputLocation = document.querySelector(".input-location");
        var inputDuration = document.querySelector(".input-duration");
        var inputPrice = document.querySelector(".input-price");
        var inputDescription = document.querySelector(".input-description");
        var inputFeatures = document.querySelector(".input-features");
        var inputStops = document.querySelector(".input-stop");
        var coverImg = document.getElementById("input-cover-image");
        var tourImg_1 = document.querySelector(".input-cover-img-1");
        var tourImg_2 = document.querySelector(".input-cover-img-2");
        var tourImg_3 = document.querySelector(".input-cover-img-3");
        var inputFields = {
            inputTourName: inputTourName,
            inputDifficulty: inputDifficulty,
            inputCatagorey: inputCatagorey,
            inputMaxPeople: inputMaxPeople,
            inputPrice: inputPrice,
            inputDescription: inputDescription,
            inputLocation: inputLocation,
            inputDuration: inputDuration,
            inputFeatures: inputFeatures,
            inputStops: inputStops,
            tourImg_1: tourImg_1,
            tourImg_2: tourImg_2,
            tourImg_3: tourImg_3,
            coverImg: coverImg
        };
        var slug = document.querySelector(".update-form").dataset.slug;
        if (!slug) return (0, _profile.createTour)(inputFields);
        (0, _profile.editTour)(slug, inputFields);
    }
});
addTourBtn === null || addTourBtn === void 0 ? void 0 : addTourBtn.addEventListener("click", /*#__PURE__*/ (0, _asyncToGenerator._)(function() {
    return (0, _tsGenerator._)(this, function(_state) {
        switch(_state.label){
            case 0:
                return [
                    4,
                    (0, _profile.editPopup)()
                ];
            case 1:
                editFormvalid = _state.sent();
                return [
                    2
                ];
        }
    });
}));
// swal2 - styled;
// edit tour submit button
document.addEventListener("click", function(e) {
    // Dom traversing for send feedback btn
    var feedbackSubmitBtn = e.target.classList.contains("feedback-submit-btn");
    if (feedbackSubmitBtn) (0, _userProfile.sendFeedback)(e);
    // Dom traversing for send reset password btn
    var resetPasswordBtn = e.target.classList.contains("reset-btn");
    if (resetPasswordBtn) (0, _userProfile.resetPassword)(e);
    // forget password in user profile
    var forgetLabel = e.target.classList.contains("forget-text");
    if (forgetLabel) (0, _routeChanger.routeChanger)("/forget-password");
    if (e.target.classList.contains("bookingBtn")) (0, _detail.displayChekout)(e);
    if (!(editFormvalid === null || editFormvalid === void 0 ? void 0 : editFormvalid.value)) return;
    if (e.target.classList.contains("swal2-confirm")) {
        var inputTourName = document.querySelector(".input-tour-name");
        var inputCatagorey = document.querySelector(".input-catagorey");
        var inputDifficulty = document.querySelector(".input-difficulty");
        var inputMaxPeople = document.querySelector(".input-max-people");
        var inputLocation = document.querySelector(".input-location");
        var inputDuration = document.querySelector(".input-duration");
        var inputPrice = document.querySelector(".input-price");
        var inputDescription = document.querySelector(".input-description");
        var inputFeatures = document.querySelector(".input-features");
        var inputStops = document.querySelector(".input-stop");
        var coverImg = document.getElementById("input-cover-image");
        var tourImg_1 = document.querySelector(".input-cover-img-1");
        var tourImg_2 = document.querySelector(".input-cover-img-2");
        var tourImg_3 = document.querySelector(".input-cover-img-3");
        var inputFields = {
            inputTourName: inputTourName,
            inputDifficulty: inputDifficulty,
            inputCatagorey: inputCatagorey,
            inputMaxPeople: inputMaxPeople,
            inputPrice: inputPrice,
            inputDescription: inputDescription,
            inputLocation: inputLocation,
            inputDuration: inputDuration,
            inputFeatures: inputFeatures,
            inputStops: inputStops,
            tourImg_1: tourImg_1,
            tourImg_2: tourImg_2,
            tourImg_3: tourImg_3,
            coverImg: coverImg
        };
        var slug = document.querySelector(".update-form").dataset.slug;
        if (!slug) return (0, _profile.createTour)(inputFields);
        (0, _profile.editTour)(slug, inputFields);
    }
});
// feedback button
feedbackBtn === null || feedbackBtn === void 0 ? void 0 : feedbackBtn.addEventListener("click", (0, _userProfile.renderFeedbackInputs));
// security button
securityBtn === null || securityBtn === void 0 ? void 0 : securityBtn.addEventListener("click", (0, _userProfile.renderSecurityInputs));
// memories btn
memoriesBtn === null || memoriesBtn === void 0 ? void 0 : memoriesBtn.addEventListener("click", (0, _userProfile.renderMemories));
// memories submit btn
memoriesSubmitBtn === null || memoriesSubmitBtn === void 0 ? void 0 : memoriesSubmitBtn.addEventListener("click", (0, _memories.addMemories));
console.log(memoriesBtn);
// reset password submit btn
resetPasswordSubmitBtn === null || resetPasswordSubmitBtn === void 0 ? void 0 : resetPasswordSubmitBtn.addEventListener("click", (0, _resetPassword.updatePassword));
// forgetPassword link like label action
forgetPasswordLabel === null || forgetPasswordLabel === void 0 ? void 0 : forgetPasswordLabel.addEventListener("click", function() {
    return (0, _routeChanger.routeChanger)("/forget-password");
});
// recovery btn for forget password gmail
recoveryBtn === null || recoveryBtn === void 0 ? void 0 : recoveryBtn.addEventListener("click", (0, _forgetPassword.sendRestPasswordLink));
window.addEventListener("load", function() {
    var _document_querySelector;
    var memoriesContainer = document.body.classList.contains("memories-body");
    var detailPageContainer = document.body.classList.contains("details-body");
    var homePageContainer = document.body.classList.contains("home");
    var slides = (_document_querySelector = document.querySelector(".slider-container")) === null || _document_querySelector === void 0 ? void 0 : _document_querySelector.childNodes;
    // rendering map when the memories page loaded
    if (memoriesContainer) (0, _memories.renderMap)();
    // rendering map with markers when the tour detail page loaded
    if (detailPageContainer) {
        var coordinates = JSON.parse(mapContainer.dataset.locations);
        (0, _map.renderAllMarkers)(coordinates);
        (0, _detail.renderBookmarkStatus)();
        slides === null || slides === void 0 ? void 0 : slides.forEach(function(el, i) {
            el.style.transform = "translate(".concat(100 * i, "%, -50%)");
        });
    }
    // asking for permission when home page is loaded
    if (homePageContainer) (0, _home.requestPermission)();
});
//making review Star dynamic
reviewStars === null || reviewStars === void 0 ? void 0 : reviewStars.addEventListener("click", (0, _detail.updateStarRating));
// review submit btn
reviewsSubmitBtn === null || reviewsSubmitBtn === void 0 ? void 0 : reviewsSubmitBtn.addEventListener("click", (0, _detail.submitReview));
// slider right btn
slideRight === null || slideRight === void 0 ? void 0 : slideRight.addEventListener("click", (0, _detail.slideToRight));
// slider left btn
slideLeft === null || slideLeft === void 0 ? void 0 : slideLeft.addEventListener("click", (0, _detail.slideToLeft));
// analytics btn
analyticsBtn === null || analyticsBtn === void 0 ? void 0 : analyticsBtn.addEventListener("click", (0, _profile.renderAnalytics));
// admin dashboard coupons btn
couponsBtn === null || couponsBtn === void 0 ? void 0 : couponsBtn.addEventListener("click", (0, _profile.renderCoupons));
// adding new coupon btn
addCouponsBtn === null || addCouponsBtn === void 0 ? void 0 : addCouponsBtn.addEventListener("click", (0, _coupon.addCoupon));
// for advanced catogrizing
catgorizeOptionContainer === null || catgorizeOptionContainer === void 0 ? void 0 : catgorizeOptionContainer.addEventListener("click", (0, _tours.renderFilterTour));
// left key for  pagination
iconLeft === null || iconLeft === void 0 ? void 0 : iconLeft.addEventListener("click", (0, _tours.paginateLeft));
// right key for  pagination
iconRight === null || iconRight === void 0 ? void 0 : iconRight.addEventListener("click", (0, _tours.paginateRight));
// wallet btn
walletBtn === null || walletBtn === void 0 ? void 0 : walletBtn.addEventListener("click", (0, _userProfile.renderWallet));

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_ts_generator":"dhhs4","./home":"8wf1I","./signup":"jPCvs","./otp":"bm9NT","./login":"an02B","./tours":"9dYhW","./profile":"kLVhs","./detail":"7PsJg","./stripe":"6zQkQ","./checkout":"iiVov","./userProfile":"6DZE5","./map":"eQweB","./memories":"fuBEK","./forgetPassword":"9QfUV","./resetPassword":"kd774","./coupon":"85UK9","./routeChanger":"ful9o","./renderProfile":"5N5Hk"}],"8wf1I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showMenu", function() {
    return showMenu;
});
parcelHelpers.export(exports, "requestPermission", function() {
    return requestPermission;
});
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var navBar = document.querySelector(".nav-bar");
var showMenu = function() {
    navBar.classList.toggle("nav-open");
};
var requestPermission = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    return [
                        4,
                        Notification.requestPermission()
                    ];
                case 1:
                    _state.sent();
                    return [
                        2
                    ];
            }
        });
    });
    return function requestPermission() {
        return _ref.apply(this, arguments);
    };
}();

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_ts_generator":"dhhs4","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"jPCvs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "validateFormAndSendData", function() {
    return validateFormAndSendData;
});
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _routeChanger = require("./routeChanger");
var form = document.querySelector(".signup-form");
// inputs
var inputName = document.querySelector(".name");
var inputEmail = document.querySelector(".email");
var inputPassword = document.querySelector(".password");
var inputConfirmPassword = document.querySelector(".cpassword");
// Error labels
var errPassword = document.querySelector(".err-paragraph");
var errName = document.querySelector(".error-name-paragraph ");
var errEmail = document.querySelector(".error-email-paragraph");
var showError = function showError(err, type1) {
    if (type1 === "email") errEmail.textContent = err;
    else if (type1 === "password") errPassword.textContent = err;
    else errEmail.textContent = "", errPassword.textContent = "";
};
var validateFormAndSendData = function() {
    var _ref = (0, _asyncToGenerator._)(function(e) {
        var message, specialCharcterRegex, response, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    specialCharcterRegex = new RegExp(/[^a-zA-Z0-9]/);
                    //   validating name field
                    if (inputName.value.trim().length === 0) {
                        e.preventDefault();
                        return [
                            2,
                            errName.textContent = "Enter a value"
                        ];
                    }
                    // checking any special charcter is there
                    if (specialCharcterRegex.test(inputName.value)) {
                        e.preventDefault();
                        return [
                            2,
                            errName.textContent = "Remove all special charcters"
                        ];
                    }
                    errName.textContent = "";
                    //   validating password and confirm password
                    if (inputConfirmPassword.value !== inputPassword.value) {
                        e.preventDefault();
                        return [
                            2,
                            errPassword.textContent = "Password and confirm password are not same"
                        ];
                    }
                    errPassword.textContent = "";
                    if (!form.checkValidity()) return [
                        2
                    ];
                    e.preventDefault();
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "POST",
                            url: "/api/v1/users/signup",
                            data: {
                                name: inputName.value,
                                email: inputEmail.value,
                                password: inputPassword.value,
                                confirmPassword: inputConfirmPassword.value
                            }
                        })
                    ];
                case 2:
                    response = _state.sent();
                    inputEmail.value = inputName.value = inputPassword.value = inputConfirmPassword.value = "";
                    errEmail.textContent = "";
                    errPassword.textContent = "";
                    (0, _routeChanger.routeChanger)("/otp-verification");
                    message = response.data.message;
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    console.log(err);
                    message = err.response.data.message;
                    type = err.response.data.type;
                    showError(message, type);
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function validateFormAndSendData(e) {
        return _ref.apply(this, arguments);
    };
}();

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_ts_generator":"dhhs4","axios":"eCZhQ","./routeChanger":"ful9o","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"eCZhQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", function() {
    return 0, _axiosJsDefault.default;
});
parcelHelpers.export(exports, "Axios", function() {
    return Axios;
});
parcelHelpers.export(exports, "AxiosError", function() {
    return AxiosError;
});
parcelHelpers.export(exports, "CanceledError", function() {
    return CanceledError;
});
parcelHelpers.export(exports, "isCancel", function() {
    return isCancel;
});
parcelHelpers.export(exports, "CancelToken", function() {
    return CancelToken;
});
parcelHelpers.export(exports, "VERSION", function() {
    return VERSION;
});
parcelHelpers.export(exports, "all", function() {
    return all;
});
parcelHelpers.export(exports, "Cancel", function() {
    return Cancel;
});
parcelHelpers.export(exports, "isAxiosError", function() {
    return isAxiosError;
});
parcelHelpers.export(exports, "spread", function() {
    return spread;
});
parcelHelpers.export(exports, "toFormData", function() {
    return toFormData;
});
parcelHelpers.export(exports, "AxiosHeaders", function() {
    return AxiosHeaders;
});
parcelHelpers.export(exports, "HttpStatusCode", function() {
    return HttpStatusCode;
});
parcelHelpers.export(exports, "formToJSON", function() {
    return formToJSON;
});
parcelHelpers.export(exports, "getAdapter", function() {
    return getAdapter;
});
parcelHelpers.export(exports, "mergeConfig", function() {
    return mergeConfig;
});
var _axiosJs = require("./lib/axios.js");
var _axiosJsDefault = parcelHelpers.interopDefault(_axiosJs);
// This module is intended to unwrap Axios default export as named.
// Keep top-level export same with static properties
// so that it can keep same with es module or cjs
var Axios = (0, _axiosJsDefault.default).Axios, AxiosError = (0, _axiosJsDefault.default).AxiosError, CanceledError = (0, _axiosJsDefault.default).CanceledError, isCancel = (0, _axiosJsDefault.default).isCancel, CancelToken = (0, _axiosJsDefault.default).CancelToken, VERSION = (0, _axiosJsDefault.default).VERSION, all = (0, _axiosJsDefault.default).all, Cancel = (0, _axiosJsDefault.default).Cancel, isAxiosError = (0, _axiosJsDefault.default).isAxiosError, spread = (0, _axiosJsDefault.default).spread, toFormData = (0, _axiosJsDefault.default).toFormData, AxiosHeaders = (0, _axiosJsDefault.default).AxiosHeaders, HttpStatusCode = (0, _axiosJsDefault.default).HttpStatusCode, formToJSON = (0, _axiosJsDefault.default).formToJSON, getAdapter = (0, _axiosJsDefault.default).getAdapter, mergeConfig = (0, _axiosJsDefault.default).mergeConfig;

},{"./lib/axios.js":"kgmMd","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"kgmMd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _bindJs = require("./helpers/bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var _axiosJs = require("./core/Axios.js");
var _axiosJsDefault = parcelHelpers.interopDefault(_axiosJs);
var _mergeConfigJs = require("./core/mergeConfig.js");
var _mergeConfigJsDefault = parcelHelpers.interopDefault(_mergeConfigJs);
var _indexJs = require("./defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _formDataToJSONJs = require("./helpers/formDataToJSON.js");
var _formDataToJSONJsDefault = parcelHelpers.interopDefault(_formDataToJSONJs);
var _canceledErrorJs = require("./cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _cancelTokenJs = require("./cancel/CancelToken.js");
var _cancelTokenJsDefault = parcelHelpers.interopDefault(_cancelTokenJs);
var _isCancelJs = require("./cancel/isCancel.js");
var _isCancelJsDefault = parcelHelpers.interopDefault(_isCancelJs);
var _dataJs = require("./env/data.js");
var _toFormDataJs = require("./helpers/toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _axiosErrorJs = require("./core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _spreadJs = require("./helpers/spread.js");
var _spreadJsDefault = parcelHelpers.interopDefault(_spreadJs);
var _isAxiosErrorJs = require("./helpers/isAxiosError.js");
var _isAxiosErrorJsDefault = parcelHelpers.interopDefault(_isAxiosErrorJs);
var _axiosHeadersJs = require("./core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _adaptersJs = require("./adapters/adapters.js");
var _adaptersJsDefault = parcelHelpers.interopDefault(_adaptersJs);
var _httpStatusCodeJs = require("./helpers/HttpStatusCode.js");
var _httpStatusCodeJsDefault = parcelHelpers.interopDefault(_httpStatusCodeJs);
"use strict";
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */ function createInstance(defaultConfig) {
    var context = new (0, _axiosJsDefault.default)(defaultConfig);
    var instance = (0, _bindJsDefault.default)((0, _axiosJsDefault.default).prototype.request, context);
    // Copy axios.prototype to instance
    (0, _utilsJsDefault.default).extend(instance, (0, _axiosJsDefault.default).prototype, context, {
        allOwnKeys: true
    });
    // Copy context to instance
    (0, _utilsJsDefault.default).extend(instance, context, null, {
        allOwnKeys: true
    });
    // Factory for creating new instances
    instance.create = function create(instanceConfig) {
        return createInstance((0, _mergeConfigJsDefault.default)(defaultConfig, instanceConfig));
    };
    return instance;
}
// Create the default instance to be exported
var axios = createInstance((0, _indexJsDefault.default));
// Expose Axios class to allow class inheritance
axios.Axios = (0, _axiosJsDefault.default);
// Expose Cancel & CancelToken
axios.CanceledError = (0, _canceledErrorJsDefault.default);
axios.CancelToken = (0, _cancelTokenJsDefault.default);
axios.isCancel = (0, _isCancelJsDefault.default);
axios.VERSION = (0, _dataJs.VERSION);
axios.toFormData = (0, _toFormDataJsDefault.default);
// Expose AxiosError class
axios.AxiosError = (0, _axiosErrorJsDefault.default);
// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;
// Expose all/spread
axios.all = function all(promises) {
    return Promise.all(promises);
};
axios.spread = (0, _spreadJsDefault.default);
// Expose isAxiosError
axios.isAxiosError = (0, _isAxiosErrorJsDefault.default);
// Expose mergeConfig
axios.mergeConfig = (0, _mergeConfigJsDefault.default);
axios.AxiosHeaders = (0, _axiosHeadersJsDefault.default);
axios.formToJSON = function(thing) {
    return (0, _formDataToJSONJsDefault.default)((0, _utilsJsDefault.default).isHTMLForm(thing) ? new FormData(thing) : thing);
};
axios.getAdapter = (0, _adaptersJsDefault.default).getAdapter;
axios.HttpStatusCode = (0, _httpStatusCodeJsDefault.default);
axios.default = axios;
// this module should only have a default export
exports.default = axios;

},{"./utils.js":"bSnR4","./helpers/bind.js":"iYpFS","./core/Axios.js":"4laJX","./core/mergeConfig.js":"1dcDU","./defaults/index.js":"5LA8n","./helpers/formDataToJSON.js":"A19Dx","./cancel/CanceledError.js":"coV7f","./cancel/CancelToken.js":"59by1","./cancel/isCancel.js":"lnNbu","./env/data.js":"5l1Fg","./helpers/toFormData.js":"QvwvR","./core/AxiosError.js":"cvT67","./helpers/spread.js":"jiIIH","./helpers/isAxiosError.js":"75Que","./core/AxiosHeaders.js":"i1deg","./adapters/adapters.js":"lR18I","./helpers/HttpStatusCode.js":"6R5zC","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"bSnR4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _typeOf = require("@swc/helpers/_/_type_of");
var _bindJs = require("./helpers/bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var global = arguments[3];
"use strict";
// utils is a library of generic helper functions non-specific to axios
var toString = Object.prototype.toString;
var getPrototypeOf = Object.getPrototypeOf;
var kindOf = function(cache) {
    return function(thing) {
        var str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    };
}(Object.create(null));
var kindOfTest = function(type) {
    type = type.toLowerCase();
    return function(thing) {
        return kindOf(thing) === type;
    };
};
var typeOfTest = function(type) {
    return function(thing) {
        return (typeof thing === "undefined" ? "undefined" : (0, _typeOf._)(thing)) === type;
    };
};
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */ var isArray = Array.isArray;
/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */ var isUndefined = typeOfTest("undefined");
/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */ function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */ var isArrayBuffer = kindOfTest("ArrayBuffer");
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */ function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) result = ArrayBuffer.isView(val);
    else result = val && val.buffer && isArrayBuffer(val.buffer);
    return result;
}
/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */ var isString = typeOfTest("string");
/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */ var isFunction = typeOfTest("function");
/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */ var isNumber = typeOfTest("number");
/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */ var isObject = function(thing) {
    return thing !== null && typeof thing === "object";
};
/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */ var isBoolean = function(thing) {
    return thing === true || thing === false;
};
/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */ var isPlainObject = function(val) {
    if (kindOf(val) !== "object") return false;
    var prototype = getPrototypeOf(val);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */ var isDate = kindOfTest("Date");
/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ var isFile = kindOfTest("File");
/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */ var isBlob = kindOfTest("Blob");
/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ var isFileList = kindOfTest("FileList");
/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */ var isStream = function(val) {
    return isObject(val) && isFunction(val.pipe);
};
/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */ var isFormData = function(thing) {
    var kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */ var isURLSearchParams = kindOfTest("URLSearchParams");
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */ var trim = function(str) {
    return str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
};
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */ function forEach(obj, fn) {
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref_allOwnKeys = _ref.allOwnKeys, allOwnKeys = _ref_allOwnKeys === void 0 ? false : _ref_allOwnKeys;
    // Don't bother if no value provided
    if (obj === null || typeof obj === "undefined") return;
    var i;
    var l;
    // Force an array if not already something iterable
    if (typeof obj !== "object") /*eslint no-param-reassign:0*/ obj = [
        obj
    ];
    if (isArray(obj)) // Iterate over array values
    for(i = 0, l = obj.length; i < l; i++)fn.call(null, obj[i], i, obj);
    else {
        // Iterate over object keys
        var keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        var len = keys.length;
        var key;
        for(i = 0; i < len; i++){
            key = keys[i];
            fn.call(null, obj[key], key, obj);
        }
    }
}
function findKey(obj, key) {
    key = key.toLowerCase();
    var keys = Object.keys(obj);
    var i = keys.length;
    var _key;
    while(i-- > 0){
        _key = keys[i];
        if (key === _key.toLowerCase()) return _key;
    }
    return null;
}
var _global = function() {
    /*eslint no-undef:0*/ if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
}();
var isContextDefined = function(context) {
    return !isUndefined(context) && context !== _global;
};
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */ function merge() {
    var caseless = (isContextDefined(this) && this || {}).caseless;
    var result = {};
    var assignValue = function(val, key) {
        var targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) result[targetKey] = merge(result[targetKey], val);
        else if (isPlainObject(val)) result[targetKey] = merge({}, val);
        else if (isArray(val)) result[targetKey] = val.slice();
        else result[targetKey] = val;
    };
    for(var i = 0, l = arguments.length; i < l; i++)arguments[i] && forEach(arguments[i], assignValue);
    return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */ var extend = function(a, b, thisArg) {
    var allOwnKeys = (arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}).allOwnKeys;
    forEach(b, function(val, key) {
        if (thisArg && isFunction(val)) a[key] = (0, _bindJsDefault.default)(val, thisArg);
        else a[key] = val;
    }, {
        allOwnKeys: allOwnKeys
    });
    return a;
};
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */ var stripBOM = function(content) {
    if (content.charCodeAt(0) === 0xFEFF) content = content.slice(1);
    return content;
};
/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */ var inherits = function(constructor, superConstructor, props, descriptors) {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
};
/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */ var toFlatObject = function(sourceObj, destObj, filter, propFilter) {
    var props;
    var i;
    var prop;
    var merged = {};
    destObj = destObj || {};
    // eslint-disable-next-line no-eq-null,eqeqeq
    if (sourceObj == null) return destObj;
    do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while(i-- > 0){
            prop = props[i];
            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
                destObj[prop] = sourceObj[prop];
                merged[prop] = true;
            }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
    }while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
};
/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */ var endsWith = function(str, searchString, position) {
    str = String(str);
    if (position === undefined || position > str.length) position = str.length;
    position -= searchString.length;
    var lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
};
/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */ var toArray = function(thing) {
    if (!thing) return null;
    if (isArray(thing)) return thing;
    var i = thing.length;
    if (!isNumber(i)) return null;
    var arr = new Array(i);
    while(i-- > 0)arr[i] = thing[i];
    return arr;
};
/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */ // eslint-disable-next-line func-names
var isTypedArray = function(TypedArray) {
    // eslint-disable-next-line func-names
    return function(thing) {
        return TypedArray && thing instanceof TypedArray;
    };
}(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */ var forEachEntry = function(obj, fn) {
    var generator = obj && obj[Symbol.iterator];
    var iterator = generator.call(obj);
    var result;
    while((result = iterator.next()) && !result.done){
        var pair = result.value;
        fn.call(obj, pair[0], pair[1]);
    }
};
/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */ var matchAll = function(regExp, str) {
    var matches;
    var arr = [];
    while((matches = regExp.exec(str)) !== null)arr.push(matches);
    return arr;
};
/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */ var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = function(str) {
    return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
    });
};
/* Creating a function that will check if an object has a property. */ var hasOwnProperty = function(param) {
    var hasOwnProperty = param.hasOwnProperty;
    return function(obj, prop) {
        return hasOwnProperty.call(obj, prop);
    };
}(Object.prototype);
/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */ var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = function(obj, reducer) {
    var descriptors = Object.getOwnPropertyDescriptors(obj);
    var reducedDescriptors = {};
    forEach(descriptors, function(descriptor, name) {
        var ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) reducedDescriptors[name] = ret || descriptor;
    });
    Object.defineProperties(obj, reducedDescriptors);
};
/**
 * Makes all methods read-only
 * @param {Object} obj
 */ var freezeMethods = function(obj) {
    reduceDescriptors(obj, function(descriptor, name) {
        // skip restricted props in strict mode
        if (isFunction(obj) && [
            "arguments",
            "caller",
            "callee"
        ].indexOf(name) !== -1) return false;
        var value = obj[name];
        if (!isFunction(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
            descriptor.writable = false;
            return;
        }
        if (!descriptor.set) descriptor.set = function() {
            throw Error("Can not rewrite read-only method '" + name + "'");
        };
    });
};
var toObjectSet = function(arrayOrString, delimiter) {
    var obj = {};
    var define = function(arr) {
        arr.forEach(function(value) {
            obj[value] = true;
        });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
};
var noop = function() {};
var toFiniteNumber = function(value, defaultValue) {
    value = +value;
    return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
    DIGIT: DIGIT,
    ALPHA: ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = function() {
    var size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16, alphabet = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ALPHABET.ALPHA_DIGIT;
    var str = "";
    var length = alphabet.length;
    while(size--)str += alphabet[Math.random() * length | 0];
    return str;
};
/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */ function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = function(obj) {
    var stack = new Array(10);
    var visit = function(source, i) {
        if (isObject(source)) {
            if (stack.indexOf(source) >= 0) return;
            if (!("toJSON" in source)) {
                stack[i] = source;
                var target = isArray(source) ? [] : {};
                forEach(source, function(value, key) {
                    var reducedValue = visit(value, i + 1);
                    !isUndefined(reducedValue) && (target[key] = reducedValue);
                });
                stack[i] = undefined;
                return target;
            }
        }
        return source;
    };
    return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = function(thing) {
    return thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
};
exports.default = {
    isArray: isArray,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString,
    isNumber: isNumber,
    isBoolean: isBoolean,
    isObject: isObject,
    isPlainObject: isPlainObject,
    isUndefined: isUndefined,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isRegExp: isRegExp,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isTypedArray: isTypedArray,
    isFileList: isFileList,
    forEach: forEach,
    merge: merge,
    extend: extend,
    trim: trim,
    stripBOM: stripBOM,
    inherits: inherits,
    toFlatObject: toFlatObject,
    kindOf: kindOf,
    kindOfTest: kindOfTest,
    endsWith: endsWith,
    toArray: toArray,
    forEachEntry: forEachEntry,
    matchAll: matchAll,
    isHTMLForm: isHTMLForm,
    hasOwnProperty: hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    reduceDescriptors: reduceDescriptors,
    freezeMethods: freezeMethods,
    toObjectSet: toObjectSet,
    toCamelCase: toCamelCase,
    noop: noop,
    toFiniteNumber: toFiniteNumber,
    findKey: findKey,
    global: _global,
    isContextDefined: isContextDefined,
    ALPHABET: ALPHABET,
    generateString: generateString,
    isSpecCompliantForm: isSpecCompliantForm,
    toJSONObject: toJSONObject,
    isAsyncFn: isAsyncFn,
    isThenable: isThenable
};

},{"@swc/helpers/_/_type_of":"b4wfg","./helpers/bind.js":"iYpFS","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"iYpFS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", function() {
    return bind;
});
"use strict";
function bind(fn, thisArg) {
    return function wrap() {
        return fn.apply(thisArg, arguments);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"4laJX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _classCallCheck = require("@swc/helpers/_/_class_call_check");
var _createClass = require("@swc/helpers/_/_create_class");
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _buildURLJs = require("../helpers/buildURL.js");
var _buildURLJsDefault = parcelHelpers.interopDefault(_buildURLJs);
var _interceptorManagerJs = require("./InterceptorManager.js");
var _interceptorManagerJsDefault = parcelHelpers.interopDefault(_interceptorManagerJs);
var _dispatchRequestJs = require("./dispatchRequest.js");
var _dispatchRequestJsDefault = parcelHelpers.interopDefault(_dispatchRequestJs);
var _mergeConfigJs = require("./mergeConfig.js");
var _mergeConfigJsDefault = parcelHelpers.interopDefault(_mergeConfigJs);
var _buildFullPathJs = require("./buildFullPath.js");
var _buildFullPathJsDefault = parcelHelpers.interopDefault(_buildFullPathJs);
var _validatorJs = require("../helpers/validator.js");
var _validatorJsDefault = parcelHelpers.interopDefault(_validatorJs);
var _axiosHeadersJs = require("./AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
var validators = (0, _validatorJsDefault.default).validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */ var Axios = /*#__PURE__*/ function() {
    function Axios(instanceConfig) {
        (0, _classCallCheck._)(this, Axios);
        this.defaults = instanceConfig;
        this.interceptors = {
            request: new (0, _interceptorManagerJsDefault.default)(),
            response: new (0, _interceptorManagerJsDefault.default)()
        };
    }
    (0, _createClass._)(Axios, [
        {
            /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */ key: "request",
            value: function request(configOrUrl, config) {
                /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API
                if (typeof configOrUrl === "string") {
                    config = config || {};
                    config.url = configOrUrl;
                } else config = configOrUrl || {};
                config = (0, _mergeConfigJsDefault.default)(this.defaults, config);
                var transitional = config.transitional, paramsSerializer = config.paramsSerializer, headers = config.headers;
                if (transitional !== undefined) (0, _validatorJsDefault.default).assertOptions(transitional, {
                    silentJSONParsing: validators.transitional(validators.boolean),
                    forcedJSONParsing: validators.transitional(validators.boolean),
                    clarifyTimeoutError: validators.transitional(validators.boolean)
                }, false);
                if (paramsSerializer != null) {
                    if ((0, _utilsJsDefault.default).isFunction(paramsSerializer)) config.paramsSerializer = {
                        serialize: paramsSerializer
                    };
                    else (0, _validatorJsDefault.default).assertOptions(paramsSerializer, {
                        encode: validators.function,
                        serialize: validators.function
                    }, true);
                }
                // Set config.method
                config.method = (config.method || this.defaults.method || "get").toLowerCase();
                // Flatten headers
                var contextHeaders = headers && (0, _utilsJsDefault.default).merge(headers.common, headers[config.method]);
                headers && (0, _utilsJsDefault.default).forEach([
                    "delete",
                    "get",
                    "head",
                    "post",
                    "put",
                    "patch",
                    "common"
                ], function(method) {
                    delete headers[method];
                });
                config.headers = (0, _axiosHeadersJsDefault.default).concat(contextHeaders, headers);
                // filter out skipped interceptors
                var requestInterceptorChain = [];
                var synchronousRequestInterceptors = true;
                this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
                    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) return;
                    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
                    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
                });
                var responseInterceptorChain = [];
                this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
                    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
                });
                var promise;
                var i = 0;
                var len;
                if (!synchronousRequestInterceptors) {
                    var chain = [
                        (0, _dispatchRequestJsDefault.default).bind(this),
                        undefined
                    ];
                    chain.unshift.apply(chain, requestInterceptorChain);
                    chain.push.apply(chain, responseInterceptorChain);
                    len = chain.length;
                    promise = Promise.resolve(config);
                    while(i < len)promise = promise.then(chain[i++], chain[i++]);
                    return promise;
                }
                len = requestInterceptorChain.length;
                var newConfig = config;
                i = 0;
                while(i < len){
                    var onFulfilled = requestInterceptorChain[i++];
                    var onRejected = requestInterceptorChain[i++];
                    try {
                        newConfig = onFulfilled(newConfig);
                    } catch (error) {
                        onRejected.call(this, error);
                        break;
                    }
                }
                try {
                    promise = (0, _dispatchRequestJsDefault.default).call(this, newConfig);
                } catch (error) {
                    return Promise.reject(error);
                }
                i = 0;
                len = responseInterceptorChain.length;
                while(i < len)promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
                return promise;
            }
        },
        {
            key: "getUri",
            value: function getUri(config) {
                config = (0, _mergeConfigJsDefault.default)(this.defaults, config);
                var fullPath = (0, _buildFullPathJsDefault.default)(config.baseURL, config.url);
                return (0, _buildURLJsDefault.default)(fullPath, config.params, config.paramsSerializer);
            }
        }
    ]);
    return Axios;
}();
// Provide aliases for supported request methods
(0, _utilsJsDefault.default).forEach([
    "delete",
    "get",
    "head",
    "options"
], function forEachMethodNoData(method) {
    /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) {
        return this.request((0, _mergeConfigJsDefault.default)(config || {}, {
            method: method,
            url: url,
            data: (config || {}).data
        }));
    };
});
(0, _utilsJsDefault.default).forEach([
    "post",
    "put",
    "patch"
], function forEachMethodWithData(method) {
    /*eslint func-names:0*/ function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
            return this.request((0, _mergeConfigJsDefault.default)(config || {}, {
                method: method,
                headers: isForm ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: url,
                data: data
            }));
        };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
exports.default = Axios;

},{"@swc/helpers/_/_class_call_check":"70JET","@swc/helpers/_/_create_class":"9CG3U","./../utils.js":"bSnR4","../helpers/buildURL.js":"gIhwF","./InterceptorManager.js":"jmkci","./dispatchRequest.js":"866Gx","./mergeConfig.js":"1dcDU","./buildFullPath.js":"4RrOH","../helpers/validator.js":"8M0BI","./AxiosHeaders.js":"i1deg","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"70JET":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_class_call_check", function() {
    return _class_call_check;
});
parcelHelpers.export(exports, "_", function() {
    return _class_call_check;
});
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"9CG3U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_create_class", function() {
    return _create_class;
});
parcelHelpers.export(exports, "_", function() {
    return _create_class;
});
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"gIhwF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", function() {
    return buildURL;
});
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosURLSearchParamsJs = require("../helpers/AxiosURLSearchParams.js");
var _axiosURLSearchParamsJsDefault = parcelHelpers.interopDefault(_axiosURLSearchParamsJs);
"use strict";
/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */ function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
    /*eslint no-param-reassign:0*/ if (!params) return url;
    var _encode = options && options.encode || encode;
    var serializeFn = options && options.serialize;
    var serializedParams;
    if (serializeFn) serializedParams = serializeFn(params, options);
    else serializedParams = (0, _utilsJsDefault.default).isURLSearchParams(params) ? params.toString() : new (0, _axiosURLSearchParamsJsDefault.default)(params, options).toString(_encode);
    if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) url = url.slice(0, hashmarkIndex);
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
}

},{"../utils.js":"bSnR4","../helpers/AxiosURLSearchParams.js":"4UrRB","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"4UrRB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _toFormDataJs = require("./toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
"use strict";
/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */ function encode(str) {
    var charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\x00"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
    });
}
/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */ function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && (0, _toFormDataJsDefault.default)(params, this, options);
}
var prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
    this._pairs.push([
        name,
        value
    ]);
};
prototype.toString = function toString(encoder) {
    var _encode = encoder ? function _encode(value) {
        return encoder.call(this, value, encode);
    } : encode;
    return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
};
exports.default = AxiosURLSearchParams;

},{"./toFormData.js":"QvwvR","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"QvwvR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored
var _formDataJs = require("../platform/node/classes/FormData.js");
var _formDataJsDefault = parcelHelpers.interopDefault(_formDataJs);
var Buffer = require("adfd9b103875c2dd").Buffer;
"use strict";
/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */ function isVisitable(thing) {
    return (0, _utilsJsDefault.default).isPlainObject(thing) || (0, _utilsJsDefault.default).isArray(thing);
}
/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */ function removeBrackets(key) {
    return (0, _utilsJsDefault.default).endsWith(key, "[]") ? key.slice(0, -2) : key;
}
/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */ function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
        // eslint-disable-next-line no-param-reassign
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
}
/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */ function isFlatArray(arr) {
    return (0, _utilsJsDefault.default).isArray(arr) && !arr.some(isVisitable);
}
var predicates = (0, _utilsJsDefault.default).toFlatObject((0, _utilsJsDefault.default), {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
});
/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/ /**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */ function toFormData(obj, formData, options) {
    if (!(0, _utilsJsDefault.default).isObject(obj)) throw new TypeError("target must be an object");
    // eslint-disable-next-line no-param-reassign
    formData = formData || new ((0, _formDataJsDefault.default) || FormData)();
    // eslint-disable-next-line no-param-reassign
    options = (0, _utilsJsDefault.default).toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
    }, false, function defined(option, source) {
        // eslint-disable-next-line no-eq-null,eqeqeq
        return !(0, _utilsJsDefault.default).isUndefined(source[option]);
    });
    var metaTokens = options.metaTokens;
    // eslint-disable-next-line no-use-before-define
    var visitor = options.visitor || defaultVisitor;
    var dots = options.dots;
    var indexes = options.indexes;
    var _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    var useBlob = _Blob && (0, _utilsJsDefault.default).isSpecCompliantForm(formData);
    if (!(0, _utilsJsDefault.default).isFunction(visitor)) throw new TypeError("visitor must be a function");
    function convertValue(value) {
        if (value === null) return "";
        if ((0, _utilsJsDefault.default).isDate(value)) return value.toISOString();
        if (!useBlob && (0, _utilsJsDefault.default).isBlob(value)) throw new (0, _axiosErrorJsDefault.default)("Blob is not supported. Use a Buffer instead.");
        if ((0, _utilsJsDefault.default).isArrayBuffer(value) || (0, _utilsJsDefault.default).isTypedArray(value)) return useBlob && typeof Blob === "function" ? new Blob([
            value
        ]) : Buffer.from(value);
        return value;
    }
    /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */ function defaultVisitor(value, key, path) {
        var arr = value;
        if (value && !path && typeof value === "object") {
            if ((0, _utilsJsDefault.default).endsWith(key, "{}")) {
                // eslint-disable-next-line no-param-reassign
                key = metaTokens ? key : key.slice(0, -2);
                // eslint-disable-next-line no-param-reassign
                value = JSON.stringify(value);
            } else if ((0, _utilsJsDefault.default).isArray(value) && isFlatArray(value) || ((0, _utilsJsDefault.default).isFileList(value) || (0, _utilsJsDefault.default).endsWith(key, "[]")) && (arr = (0, _utilsJsDefault.default).toArray(value))) {
                // eslint-disable-next-line no-param-reassign
                key = removeBrackets(key);
                arr.forEach(function each(el, index) {
                    !((0, _utilsJsDefault.default).isUndefined(el) || el === null) && formData.append(// eslint-disable-next-line no-nested-ternary
                    indexes === true ? renderKey([
                        key
                    ], index, dots) : indexes === null ? key : key + "[]", convertValue(el));
                });
                return false;
            }
        }
        if (isVisitable(value)) return true;
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
    }
    var stack = [];
    var exposedHelpers = Object.assign(predicates, {
        defaultVisitor: defaultVisitor,
        convertValue: convertValue,
        isVisitable: isVisitable
    });
    function build(value, path) {
        if ((0, _utilsJsDefault.default).isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) throw Error("Circular reference detected in " + path.join("."));
        stack.push(value);
        (0, _utilsJsDefault.default).forEach(value, function each(el, key) {
            var result = !((0, _utilsJsDefault.default).isUndefined(el) || el === null) && visitor.call(formData, el, (0, _utilsJsDefault.default).isString(key) ? key.trim() : key, path, exposedHelpers);
            if (result === true) build(el, path ? path.concat(key) : [
                key
            ]);
        });
        stack.pop();
    }
    if (!(0, _utilsJsDefault.default).isObject(obj)) throw new TypeError("data must be an object");
    build(obj);
    return formData;
}
exports.default = toFormData;

},{"adfd9b103875c2dd":"1Dkt1","../utils.js":"bSnR4","../core/AxiosError.js":"cvT67","../platform/node/classes/FormData.js":"13uSO","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"1Dkt1":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ var _assertThisInitialized = require("@swc/helpers/_/_assert_this_initialized");
var _classCallCheck = require("@swc/helpers/_/_class_call_check");
var _createClass = require("@swc/helpers/_/_create_class");
var _inherits = require("@swc/helpers/_/_inherits");
var _typeOf = require("@swc/helpers/_/_type_of");
var _createSuper = require("@swc/helpers/_/_create_super");
"use strict";
var base64 = require("9c62938f1dccc73c");
var ieee754 = require("aceacb6a4531a9d2");
var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function foo() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function get() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function get() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + (typeof value === "undefined" ? "undefined" : (0, _typeOf._)(value)));
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + (typeof value === "undefined" ? "undefined" : (0, _typeOf._)(value)));
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + (typeof string === "undefined" ? "undefined" : (0, _typeOf._)(string)));
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(var i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(var i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(var i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = "";
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + (typeof target === "undefined" ? "undefined" : (0, _typeOf._)(target)));
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    var i;
    for(i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    var loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte = void 0, thirdByte = void 0, fourthByte = void 0, tempCodePoint = void 0;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = "";
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = "";
    for(var i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(var i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    var first = this[offset];
    var last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    var lo = first + this[++offset] * 256 + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
    var hi = this[++offset] + this[++offset] * 256 + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    var first = this[offset];
    var last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * 256 + this[++offset];
    var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    var first = this[offset];
    var last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    var val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * Math.pow(2, 16) + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    var first = this[offset];
    var last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    var val = (first << 24) + // Overflow
    this[++offset] * Math.pow(2, 16) + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    var lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    var lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
var errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = /*#__PURE__*/ function(Base) {
        (0, _inherits._)(NodeError, Base);
        var _super = (0, _createSuper._)(NodeError);
        function NodeError() {
            (0, _classCallCheck._)(this, NodeError);
            var _this;
            _this = _super.call(this);
            Object.defineProperty((0, _assertThisInitialized._)(_this), "message", {
                value: getMessage.apply((0, _assertThisInitialized._)(_this), arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            _this.name = "".concat(_this.name, " [").concat(sym, "]");
            // Access the stack to generate the error message including the error code
            // from the name.
            _this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete _this.name;
            return _this;
        }
        (0, _createClass._)(NodeError, [
            {
                key: "code",
                get: function get() {
                    return sym;
                },
                set: function set(value) {
                    Object.defineProperty(this, "code", {
                        configurable: true,
                        enumerable: true,
                        value: value,
                        writable: true
                    });
                }
            },
            {
                key: "toString",
                value: function toString() {
                    return "".concat(this.name, " [").concat(sym, "]: ").concat(this.message);
                }
            }
        ]);
        return NodeError;
    }(Base);
}
E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) return "".concat(name, " is outside of buffer bounds");
    return "Attempt to access memory outside buffer bounds";
}, RangeError);
E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return 'The "'.concat(name, '" argument must be of type number. Received type ').concat(typeof actual === "undefined" ? "undefined" : (0, _typeOf._)(actual));
}, TypeError);
E("ERR_OUT_OF_RANGE", function(str, range, input) {
    var msg = 'The value of "'.concat(str, '" is out of range.');
    var received = input;
    if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) received = addNumericalSeparator(String(input));
    else if ((typeof input === "undefined" ? "undefined" : (0, _typeOf._)(input)) === "bigint") {
        received = String(input);
        if (input > Math.pow(BigInt(2), BigInt(32)) || input < -Math.pow(BigInt(2), BigInt(32))) received = addNumericalSeparator(received);
        received += "n";
    }
    msg += " It must be ".concat(range, ". Received ").concat(received);
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    var res = "";
    var i = val.length;
    var start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = "_".concat(val.slice(i - 3, i)).concat(res);
    return "".concat(val.slice(0, i)).concat(res);
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        var n = (typeof min === "undefined" ? "undefined" : (0, _typeOf._)(min)) === "bigint" ? "n" : "";
        var range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = ">= 0".concat(n, " and < 2").concat(n, " ** ").concat((byteLength + 1) * 8).concat(n);
            else range = ">= -(2".concat(n, " ** ").concat((byteLength + 1) * 8 - 1).concat(n, ") and < 2 ** ") + "".concat((byteLength + 1) * 8 - 1).concat(n);
        } else range = ">= ".concat(min).concat(n, " and <= ").concat(max).concat(n);
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== "number") throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", ">= ".concat(type ? 1 : 0, " and <= ").concat(length), value);
}
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    var i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}

},{"@swc/helpers/_/_assert_this_initialized":"3PLnj","@swc/helpers/_/_class_call_check":"70JET","@swc/helpers/_/_create_class":"9CG3U","@swc/helpers/_/_inherits":"dofLt","@swc/helpers/_/_type_of":"b4wfg","@swc/helpers/_/_create_super":"gf9e2","9c62938f1dccc73c":"8xh5B","aceacb6a4531a9d2":"dywN9"}],"3PLnj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_assert_this_initialized", function() {
    return _assert_this_initialized;
});
parcelHelpers.export(exports, "_", function() {
    return _assert_this_initialized;
});
function _assert_this_initialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"dofLt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_inherits", function() {
    return _inherits;
});
parcelHelpers.export(exports, "_", function() {
    return _inherits;
});
var _setPrototypeOfJs = require("./_set_prototype_of.js");
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) (0, _setPrototypeOfJs._set_prototype_of)(subClass, superClass);
}

},{"./_set_prototype_of.js":"epPZP","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"epPZP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_set_prototype_of", function() {
    return _set_prototype_of;
});
parcelHelpers.export(exports, "_", function() {
    return _set_prototype_of;
});
function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"gf9e2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_create_super", function() {
    return _create_super;
});
parcelHelpers.export(exports, "_", function() {
    return _create_super;
});
var _getPrototypeOfJs = require("./_get_prototype_of.js");
var _isNativeReflectConstructJs = require("./_is_native_reflect_construct.js");
var _possibleConstructorReturnJs = require("./_possible_constructor_return.js");
function _create_super(Derived) {
    var hasNativeReflectConstruct = (0, _isNativeReflectConstructJs._is_native_reflect_construct)();
    return function _createSuperInternal() {
        var Super = (0, _getPrototypeOfJs._get_prototype_of)(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = (0, _getPrototypeOfJs._get_prototype_of)(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return (0, _possibleConstructorReturnJs._possible_constructor_return)(this, result);
    };
}

},{"./_get_prototype_of.js":"04T80","./_is_native_reflect_construct.js":"8VpOd","./_possible_constructor_return.js":"iwgtj","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"04T80":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_get_prototype_of", function() {
    return _get_prototype_of;
});
parcelHelpers.export(exports, "_", function() {
    return _get_prototype_of;
});
function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of(o);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"8VpOd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_is_native_reflect_construct", function() {
    return _is_native_reflect_construct;
});
parcelHelpers.export(exports, "_", function() {
    return _is_native_reflect_construct;
});
function _is_native_reflect_construct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"iwgtj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_possible_constructor_return", function() {
    return _possible_constructor_return;
});
parcelHelpers.export(exports, "_", function() {
    return _possible_constructor_return;
});
var _assertThisInitializedJs = require("./_assert_this_initialized.js");
var _typeOfJs = require("./_type_of.js");
function _possible_constructor_return(self, call) {
    if (call && ((0, _typeOfJs._type_of)(call) === "object" || typeof call === "function")) return call;
    return (0, _assertThisInitializedJs._assert_this_initialized)(self);
}

},{"./_assert_this_initialized.js":"3PLnj","./_type_of.js":"b4wfg","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"8xh5B":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"dywN9":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"cvT67":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */ function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
    else this.stack = new Error().stack;
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    response && (this.response = response);
}
(0, _utilsJsDefault.default).inherits(AxiosError, Error, {
    toJSON: function toJSON() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: (0, _utilsJsDefault.default).toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        };
    }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
].forEach(function(code) {
    descriptors[code] = {
        value: code
    };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", {
    value: true
});
// eslint-disable-next-line func-names
AxiosError.from = function(error, code, config, request, response, customProps) {
    var axiosError = Object.create(prototype);
    (0, _utilsJsDefault.default).toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
    }, function(prop) {
        return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
};
exports.default = AxiosError;

},{"../utils.js":"bSnR4","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"13uSO":[function(require,module,exports) {
// eslint-disable-next-line strict
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"jmkci":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _classCallCheck = require("@swc/helpers/_/_class_call_check");
var _createClass = require("@swc/helpers/_/_create_class");
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
var InterceptorManager = /*#__PURE__*/ function() {
    function InterceptorManager() {
        (0, _classCallCheck._)(this, InterceptorManager);
        this.handlers = [];
    }
    (0, _createClass._)(InterceptorManager, [
        {
            /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */ key: "use",
            value: function use(fulfilled, rejected, options) {
                this.handlers.push({
                    fulfilled: fulfilled,
                    rejected: rejected,
                    synchronous: options ? options.synchronous : false,
                    runWhen: options ? options.runWhen : null
                });
                return this.handlers.length - 1;
            }
        },
        {
            /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */ key: "eject",
            value: function eject(id) {
                if (this.handlers[id]) this.handlers[id] = null;
            }
        },
        {
            /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */ key: "clear",
            value: function clear() {
                if (this.handlers) this.handlers = [];
            }
        },
        {
            /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */ key: "forEach",
            value: function forEach(fn) {
                (0, _utilsJsDefault.default).forEach(this.handlers, function forEachHandler(h) {
                    if (h !== null) fn(h);
                });
            }
        }
    ]);
    return InterceptorManager;
}();
exports.default = InterceptorManager;

},{"@swc/helpers/_/_class_call_check":"70JET","@swc/helpers/_/_create_class":"9CG3U","./../utils.js":"bSnR4","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"866Gx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", function() {
    return dispatchRequest;
});
var _transformDataJs = require("./transformData.js");
var _transformDataJsDefault = parcelHelpers.interopDefault(_transformDataJs);
var _isCancelJs = require("../cancel/isCancel.js");
var _isCancelJsDefault = parcelHelpers.interopDefault(_isCancelJs);
var _indexJs = require("../defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _canceledErrorJs = require("../cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _adaptersJs = require("../adapters/adapters.js");
var _adaptersJsDefault = parcelHelpers.interopDefault(_adaptersJs);
"use strict";
/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */ function throwIfCancellationRequested(config) {
    if (config.cancelToken) config.cancelToken.throwIfRequested();
    if (config.signal && config.signal.aborted) throw new (0, _canceledErrorJsDefault.default)(null, config);
}
function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = (0, _axiosHeadersJsDefault.default).from(config.headers);
    // Transform request data
    config.data = (0, _transformDataJsDefault.default).call(config, config.transformRequest);
    if ([
        "post",
        "put",
        "patch"
    ].indexOf(config.method) !== -1) config.headers.setContentType("application/x-www-form-urlencoded", false);
    var adapter = (0, _adaptersJsDefault.default).getAdapter(config.adapter || (0, _indexJsDefault.default).adapter);
    return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        // Transform response data
        response.data = (0, _transformDataJsDefault.default).call(config, config.transformResponse, response);
        response.headers = (0, _axiosHeadersJsDefault.default).from(response.headers);
        return response;
    }, function onAdapterRejection(reason) {
        if (!(0, _isCancelJsDefault.default)(reason)) {
            throwIfCancellationRequested(config);
            // Transform response data
            if (reason && reason.response) {
                reason.response.data = (0, _transformDataJsDefault.default).call(config, config.transformResponse, reason.response);
                reason.response.headers = (0, _axiosHeadersJsDefault.default).from(reason.response.headers);
            }
        }
        return Promise.reject(reason);
    });
}

},{"./transformData.js":"8ukg3","../cancel/isCancel.js":"lnNbu","../defaults/index.js":"5LA8n","../cancel/CanceledError.js":"coV7f","../core/AxiosHeaders.js":"i1deg","../adapters/adapters.js":"lR18I","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"8ukg3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", function() {
    return transformData;
});
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
function transformData(fns, response) {
    var config = this || (0, _indexJsDefault.default);
    var context = response || config;
    var headers = (0, _axiosHeadersJsDefault.default).from(context.headers);
    var data = context.data;
    (0, _utilsJsDefault.default).forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
    });
    headers.normalize();
    return data;
}

},{"./../utils.js":"bSnR4","../defaults/index.js":"5LA8n","../core/AxiosHeaders.js":"i1deg","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"5LA8n":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _transitionalJs = require("./transitional.js");
var _transitionalJsDefault = parcelHelpers.interopDefault(_transitionalJs);
var _toFormDataJs = require("../helpers/toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _toURLEncodedFormJs = require("../helpers/toURLEncodedForm.js");
var _toURLEncodedFormJsDefault = parcelHelpers.interopDefault(_toURLEncodedFormJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _formDataToJSONJs = require("../helpers/formDataToJSON.js");
var _formDataToJSONJsDefault = parcelHelpers.interopDefault(_formDataToJSONJs);
"use strict";
/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */ function stringifySafely(rawValue, parser, encoder) {
    if ((0, _utilsJsDefault.default).isString(rawValue)) try {
        (parser || JSON.parse)(rawValue);
        return (0, _utilsJsDefault.default).trim(rawValue);
    } catch (e) {
        if (e.name !== "SyntaxError") throw e;
    }
    return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
    transitional: (0, _transitionalJsDefault.default),
    adapter: [
        "xhr",
        "http"
    ],
    transformRequest: [
        function transformRequest(data, headers) {
            var contentType = headers.getContentType() || "";
            var hasJSONContentType = contentType.indexOf("application/json") > -1;
            var isObjectPayload = (0, _utilsJsDefault.default).isObject(data);
            if (isObjectPayload && (0, _utilsJsDefault.default).isHTMLForm(data)) data = new FormData(data);
            var isFormData = (0, _utilsJsDefault.default).isFormData(data);
            if (isFormData) {
                if (!hasJSONContentType) return data;
                return hasJSONContentType ? JSON.stringify((0, _formDataToJSONJsDefault.default)(data)) : data;
            }
            if ((0, _utilsJsDefault.default).isArrayBuffer(data) || (0, _utilsJsDefault.default).isBuffer(data) || (0, _utilsJsDefault.default).isStream(data) || (0, _utilsJsDefault.default).isFile(data) || (0, _utilsJsDefault.default).isBlob(data)) return data;
            if ((0, _utilsJsDefault.default).isArrayBufferView(data)) return data.buffer;
            if ((0, _utilsJsDefault.default).isURLSearchParams(data)) {
                headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
                return data.toString();
            }
            var isFileList;
            if (isObjectPayload) {
                if (contentType.indexOf("application/x-www-form-urlencoded") > -1) return (0, _toURLEncodedFormJsDefault.default)(data, this.formSerializer).toString();
                if ((isFileList = (0, _utilsJsDefault.default).isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
                    var _FormData = this.env && this.env.FormData;
                    return (0, _toFormDataJsDefault.default)(isFileList ? {
                        "files[]": data
                    } : data, _FormData && new _FormData(), this.formSerializer);
                }
            }
            if (isObjectPayload || hasJSONContentType) {
                headers.setContentType("application/json", false);
                return stringifySafely(data);
            }
            return data;
        }
    ],
    transformResponse: [
        function transformResponse(data) {
            var transitional = this.transitional || defaults.transitional;
            var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
            var JSONRequested = this.responseType === "json";
            if (data && (0, _utilsJsDefault.default).isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
                var silentJSONParsing = transitional && transitional.silentJSONParsing;
                var strictJSONParsing = !silentJSONParsing && JSONRequested;
                try {
                    return JSON.parse(data);
                } catch (e) {
                    if (strictJSONParsing) {
                        if (e.name === "SyntaxError") throw (0, _axiosErrorJsDefault.default).from(e, (0, _axiosErrorJsDefault.default).ERR_BAD_RESPONSE, this, null, this.response);
                        throw e;
                    }
                }
            }
            return data;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: (0, _indexJsDefault.default).classes.FormData,
        Blob: (0, _indexJsDefault.default).classes.Blob
    },
    validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
    },
    headers: {
        common: {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": undefined
        }
    }
};
(0, _utilsJsDefault.default).forEach([
    "delete",
    "get",
    "head",
    "post",
    "put",
    "patch"
], function(method) {
    defaults.headers[method] = {};
});
exports.default = defaults;

},{"../utils.js":"bSnR4","../core/AxiosError.js":"cvT67","./transitional.js":"4YEEQ","../helpers/toFormData.js":"QvwvR","../helpers/toURLEncodedForm.js":"d225Q","../platform/index.js":"3xlWB","../helpers/formDataToJSON.js":"A19Dx","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"4YEEQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"d225Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", function() {
    return toURLEncodedForm;
});
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _toFormDataJs = require("./toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
"use strict";
function toURLEncodedForm(data, options) {
    return (0, _toFormDataJsDefault.default)(data, new (0, _indexJsDefault.default).classes.URLSearchParams(), Object.assign({
        visitor: function visitor(value, key, path, helpers) {
            if ((0, _indexJsDefault.default).isNode && (0, _utilsJsDefault.default).isBuffer(value)) {
                this.append(key, value.toString("base64"));
                return false;
            }
            return helpers.defaultVisitor.apply(this, arguments);
        }
    }, options));
}

},{"../utils.js":"bSnR4","./toFormData.js":"QvwvR","../platform/index.js":"3xlWB","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"3xlWB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectSpread = require("@swc/helpers/_/_object_spread");
var _indexJs = require("./node/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _utilsJs = require("./common/utils.js");
exports.default = (0, _objectSpread._)({}, _utilsJs, (0, _indexJsDefault.default));

},{"@swc/helpers/_/_object_spread":"lyjzq","./node/index.js":"h3kst","./common/utils.js":"jAkUs","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"lyjzq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_object_spread", function() {
    return _object_spread;
});
parcelHelpers.export(exports, "_", function() {
    return _object_spread;
});
var _definePropertyJs = require("./_define_property.js");
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
        ownKeys.forEach(function(key) {
            (0, _definePropertyJs._define_property)(target, key, source[key]);
        });
    }
    return target;
}

},{"./_define_property.js":"6dEyb","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"6dEyb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_define_property", function() {
    return _define_property;
});
parcelHelpers.export(exports, "_", function() {
    return _define_property;
});
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"h3kst":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _urlsearchParamsJs = require("./classes/URLSearchParams.js");
var _urlsearchParamsJsDefault = parcelHelpers.interopDefault(_urlsearchParamsJs);
var _formDataJs = require("./classes/FormData.js");
var _formDataJsDefault = parcelHelpers.interopDefault(_formDataJs);
var _blobJs = require("./classes/Blob.js");
var _blobJsDefault = parcelHelpers.interopDefault(_blobJs);
exports.default = {
    isBrowser: true,
    classes: {
        URLSearchParams: (0, _urlsearchParamsJsDefault.default),
        FormData: (0, _formDataJsDefault.default),
        Blob: (0, _blobJsDefault.default)
    },
    protocols: [
        "http",
        "https",
        "file",
        "blob",
        "url",
        "data"
    ]
};

},{"./classes/URLSearchParams.js":"imD4E","./classes/FormData.js":"g4kfE","./classes/Blob.js":"bFDVj","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"imD4E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axiosURLSearchParamsJs = require("../../../helpers/AxiosURLSearchParams.js");
var _axiosURLSearchParamsJsDefault = parcelHelpers.interopDefault(_axiosURLSearchParamsJs);
"use strict";
exports.default = typeof URLSearchParams !== "undefined" ? URLSearchParams : (0, _axiosURLSearchParamsJsDefault.default);

},{"../../../helpers/AxiosURLSearchParams.js":"4UrRB","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"g4kfE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = typeof FormData !== "undefined" ? FormData : null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"bFDVj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = typeof Blob !== "undefined" ? Blob : null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"jAkUs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasBrowserEnv", function() {
    return hasBrowserEnv;
});
parcelHelpers.export(exports, "hasStandardBrowserWebWorkerEnv", function() {
    return hasStandardBrowserWebWorkerEnv;
});
parcelHelpers.export(exports, "hasStandardBrowserEnv", function() {
    return hasStandardBrowserEnv;
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */ var hasStandardBrowserEnv = function(product) {
    return hasBrowserEnv && [
        "ReactNative",
        "NativeScript",
        "NS"
    ].indexOf(product) < 0;
}(typeof navigator !== "undefined" && navigator.product);
/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */ var hasStandardBrowserWebWorkerEnv = function() {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"A19Dx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */ function parsePropPath(name) {
    // foo[x][y][z]
    // foo.x.y.z
    // foo-x-y-z
    // foo x y z
    return (0, _utilsJsDefault.default).matchAll(/\w+|\[(\w*)]/g, name).map(function(match) {
        return match[0] === "[]" ? "" : match[1] || match[0];
    });
}
/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */ function arrayToObject(arr) {
    var obj = {};
    var keys = Object.keys(arr);
    var i;
    var len = keys.length;
    var key;
    for(i = 0; i < len; i++){
        key = keys[i];
        obj[key] = arr[key];
    }
    return obj;
}
/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */ function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
        var name = path[index++];
        if (name === "__proto__") return true;
        var isNumericKey = Number.isFinite(+name);
        var isLast = index >= path.length;
        name = !name && (0, _utilsJsDefault.default).isArray(target) ? target.length : name;
        if (isLast) {
            if ((0, _utilsJsDefault.default).hasOwnProp(target, name)) target[name] = [
                target[name],
                value
            ];
            else target[name] = value;
            return !isNumericKey;
        }
        if (!target[name] || !(0, _utilsJsDefault.default).isObject(target[name])) target[name] = [];
        var result = buildPath(path, value, target[name], index);
        if (result && (0, _utilsJsDefault.default).isArray(target[name])) target[name] = arrayToObject(target[name]);
        return !isNumericKey;
    }
    if ((0, _utilsJsDefault.default).isFormData(formData) && (0, _utilsJsDefault.default).isFunction(formData.entries)) {
        var obj = {};
        (0, _utilsJsDefault.default).forEachEntry(formData, function(name, value) {
            buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
    }
    return null;
}
exports.default = formDataToJSON;

},{"../utils.js":"bSnR4","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"i1deg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _classCallCheck = require("@swc/helpers/_/_class_call_check");
var _createClass = require("@swc/helpers/_/_create_class");
var _slicedToArray = require("@swc/helpers/_/_sliced_to_array");
var _toConsumableArray = require("@swc/helpers/_/_to_consumable_array");
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _parseHeadersJs = require("../helpers/parseHeaders.js");
var _parseHeadersJsDefault = parcelHelpers.interopDefault(_parseHeadersJs);
"use strict";
var $internals = Symbol("internals");
function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
    if (value === false || value == null) return value;
    return (0, _utilsJsDefault.default).isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
    var tokens = Object.create(null);
    var tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    var match;
    while(match = tokensRE.exec(str))tokens[match[1]] = match[2];
    return tokens;
}
var isValidHeaderName = function(str) {
    return /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
};
function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if ((0, _utilsJsDefault.default).isFunction(filter)) return filter.call(this, value, header);
    if (isHeaderNameFilter) value = header;
    if (!(0, _utilsJsDefault.default).isString(value)) return;
    if ((0, _utilsJsDefault.default).isString(filter)) return value.indexOf(filter) !== -1;
    if ((0, _utilsJsDefault.default).isRegExp(filter)) return filter.test(value);
}
function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, function(w, char, str) {
        return char.toUpperCase() + str;
    });
}
function buildAccessors(obj, header) {
    var accessorName = (0, _utilsJsDefault.default).toCamelCase(" " + header);
    [
        "get",
        "set",
        "has"
    ].forEach(function(methodName) {
        Object.defineProperty(obj, methodName + accessorName, {
            value: function value(arg1, arg2, arg3) {
                return this[methodName].call(this, header, arg1, arg2, arg3);
            },
            configurable: true
        });
    });
}
var AxiosHeaders = /*#__PURE__*/ function() {
    function AxiosHeaders(headers) {
        (0, _classCallCheck._)(this, AxiosHeaders);
        headers && this.set(headers);
    }
    (0, _createClass._)(AxiosHeaders, [
        {
            key: "set",
            value: function set(header, valueOrRewrite, rewrite) {
                var self = this;
                function setHeader(_value, _header, _rewrite) {
                    var lHeader = normalizeHeader(_header);
                    if (!lHeader) throw new Error("header name must be a non-empty string");
                    var key = (0, _utilsJsDefault.default).findKey(self, lHeader);
                    if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) self[key || _header] = normalizeValue(_value);
                }
                var setHeaders = function(headers, _rewrite) {
                    return (0, _utilsJsDefault.default).forEach(headers, function(_value, _header) {
                        return setHeader(_value, _header, _rewrite);
                    });
                };
                if ((0, _utilsJsDefault.default).isPlainObject(header) || header instanceof this.constructor) setHeaders(header, valueOrRewrite);
                else if ((0, _utilsJsDefault.default).isString(header) && (header = header.trim()) && !isValidHeaderName(header)) setHeaders((0, _parseHeadersJsDefault.default)(header), valueOrRewrite);
                else header != null && setHeader(valueOrRewrite, header, rewrite);
                return this;
            }
        },
        {
            key: "get",
            value: function get(header, parser) {
                header = normalizeHeader(header);
                if (header) {
                    var key = (0, _utilsJsDefault.default).findKey(this, header);
                    if (key) {
                        var value = this[key];
                        if (!parser) return value;
                        if (parser === true) return parseTokens(value);
                        if ((0, _utilsJsDefault.default).isFunction(parser)) return parser.call(this, value, key);
                        if ((0, _utilsJsDefault.default).isRegExp(parser)) return parser.exec(value);
                        throw new TypeError("parser must be boolean|regexp|function");
                    }
                }
            }
        },
        {
            key: "has",
            value: function has(header, matcher) {
                header = normalizeHeader(header);
                if (header) {
                    var key = (0, _utilsJsDefault.default).findKey(this, header);
                    return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
                }
                return false;
            }
        },
        {
            key: "delete",
            value: function _delete(header, matcher) {
                var self = this;
                var deleted = false;
                function deleteHeader(_header) {
                    _header = normalizeHeader(_header);
                    if (_header) {
                        var key = (0, _utilsJsDefault.default).findKey(self, _header);
                        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
                            delete self[key];
                            deleted = true;
                        }
                    }
                }
                if ((0, _utilsJsDefault.default).isArray(header)) header.forEach(deleteHeader);
                else deleteHeader(header);
                return deleted;
            }
        },
        {
            key: "clear",
            value: function clear(matcher) {
                var keys = Object.keys(this);
                var i = keys.length;
                var deleted = false;
                while(i--){
                    var key = keys[i];
                    if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
                        delete this[key];
                        deleted = true;
                    }
                }
                return deleted;
            }
        },
        {
            key: "normalize",
            value: function normalize(format) {
                var self = this;
                var headers = {};
                (0, _utilsJsDefault.default).forEach(this, function(value, header) {
                    var key = (0, _utilsJsDefault.default).findKey(headers, header);
                    if (key) {
                        self[key] = normalizeValue(value);
                        delete self[header];
                        return;
                    }
                    var normalized = format ? formatHeader(header) : String(header).trim();
                    if (normalized !== header) delete self[header];
                    self[normalized] = normalizeValue(value);
                    headers[normalized] = true;
                });
                return this;
            }
        },
        {
            key: "concat",
            value: function concat() {
                for(var _len = arguments.length, targets = new Array(_len), _key = 0; _key < _len; _key++){
                    targets[_key] = arguments[_key];
                }
                var _this_constructor;
                return (_this_constructor = this.constructor).concat.apply(_this_constructor, [
                    this
                ].concat((0, _toConsumableArray._)(targets)));
            }
        },
        {
            key: "toJSON",
            value: function toJSON(asStrings) {
                var obj = Object.create(null);
                (0, _utilsJsDefault.default).forEach(this, function(value, header) {
                    value != null && value !== false && (obj[header] = asStrings && (0, _utilsJsDefault.default).isArray(value) ? value.join(", ") : value);
                });
                return obj;
            }
        },
        {
            key: Symbol.iterator,
            value: function value() {
                return Object.entries(this.toJSON())[Symbol.iterator]();
            }
        },
        {
            key: "toString",
            value: function toString() {
                return Object.entries(this.toJSON()).map(function(param) {
                    var _param = (0, _slicedToArray._)(param, 2), header = _param[0], value = _param[1];
                    return header + ": " + value;
                }).join("\n");
            }
        },
        {
            key: Symbol.toStringTag,
            get: function get() {
                return "AxiosHeaders";
            }
        }
    ], [
        {
            key: "from",
            value: function from(thing) {
                return thing instanceof this ? thing : new this(thing);
            }
        },
        {
            key: "concat",
            value: function concat(first) {
                for(var _len = arguments.length, targets = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    targets[_key - 1] = arguments[_key];
                }
                var computed = new this(first);
                targets.forEach(function(target) {
                    return computed.set(target);
                });
                return computed;
            }
        },
        {
            key: "accessor",
            value: function accessor(header) {
                var internals = this[$internals] = this[$internals] = {
                    accessors: {}
                };
                var accessors = internals.accessors;
                var prototype = this.prototype;
                function defineAccessor(_header) {
                    var lHeader = normalizeHeader(_header);
                    if (!accessors[lHeader]) {
                        buildAccessors(prototype, _header);
                        accessors[lHeader] = true;
                    }
                }
                (0, _utilsJsDefault.default).isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
                return this;
            }
        }
    ]);
    return AxiosHeaders;
}();
AxiosHeaders.accessor([
    "Content-Type",
    "Content-Length",
    "Accept",
    "Accept-Encoding",
    "User-Agent",
    "Authorization"
]);
// reserved names hotfix
(0, _utilsJsDefault.default).reduceDescriptors(AxiosHeaders.prototype, function(param, key) {
    var value = param.value;
    var mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
    return {
        get: function() {
            return value;
        },
        set: function(headerValue) {
            this[mapped] = headerValue;
        }
    };
});
(0, _utilsJsDefault.default).freezeMethods(AxiosHeaders);
exports.default = AxiosHeaders;

},{"@swc/helpers/_/_class_call_check":"70JET","@swc/helpers/_/_create_class":"9CG3U","@swc/helpers/_/_sliced_to_array":"lHDUI","@swc/helpers/_/_to_consumable_array":"ig3r6","../utils.js":"bSnR4","../helpers/parseHeaders.js":"5BSCJ","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"lHDUI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_sliced_to_array", function() {
    return _sliced_to_array;
});
parcelHelpers.export(exports, "_", function() {
    return _sliced_to_array;
});
var _arrayWithHolesJs = require("./_array_with_holes.js");
var _iterableToArrayLimitJs = require("./_iterable_to_array_limit.js");
var _nonIterableRestJs = require("./_non_iterable_rest.js");
var _unsupportedIterableToArrayJs = require("./_unsupported_iterable_to_array.js");
function _sliced_to_array(arr, i) {
    return (0, _arrayWithHolesJs._array_with_holes)(arr) || (0, _iterableToArrayLimitJs._iterable_to_array_limit)(arr, i) || (0, _unsupportedIterableToArrayJs._unsupported_iterable_to_array)(arr, i) || (0, _nonIterableRestJs._non_iterable_rest)();
}

},{"./_array_with_holes.js":"155GO","./_iterable_to_array_limit.js":"IKsbs","./_non_iterable_rest.js":"iyBaH","./_unsupported_iterable_to_array.js":"vagJ6","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"155GO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_array_with_holes", function() {
    return _array_with_holes;
});
parcelHelpers.export(exports, "_", function() {
    return _array_with_holes;
});
function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"IKsbs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_iterable_to_array_limit", function() {
    return _iterable_to_array_limit;
});
parcelHelpers.export(exports, "_", function() {
    return _iterable_to_array_limit;
});
function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"iyBaH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_non_iterable_rest", function() {
    return _non_iterable_rest;
});
parcelHelpers.export(exports, "_", function() {
    return _non_iterable_rest;
});
function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"5BSCJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = (0, _utilsJsDefault.default).toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
]);
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */ exports.default = function(rawHeaders) {
    var parsed = {};
    var key;
    var val;
    var i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) return;
        if (key === "set-cookie") {
            if (parsed[key]) parsed[key].push(val);
            else parsed[key] = [
                val
            ];
        } else parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    });
    return parsed;
};

},{"./../utils.js":"bSnR4","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"lnNbu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", function() {
    return isCancel;
});
"use strict";
function isCancel(value) {
    return !!(value && value.__CANCEL__);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"coV7f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */ function CanceledError(message, config, request) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    (0, _axiosErrorJsDefault.default).call(this, message == null ? "canceled" : message, (0, _axiosErrorJsDefault.default).ERR_CANCELED, config, request);
    this.name = "CanceledError";
}
(0, _utilsJsDefault.default).inherits(CanceledError, (0, _axiosErrorJsDefault.default), {
    __CANCEL__: true
});
exports.default = CanceledError;

},{"../core/AxiosError.js":"cvT67","../utils.js":"bSnR4","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"lR18I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _slicedToArray = require("@swc/helpers/_/_sliced_to_array");
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _httpJs = require("./http.js");
var _httpJsDefault = parcelHelpers.interopDefault(_httpJs);
var _xhrJs = require("./xhr.js");
var _xhrJsDefault = parcelHelpers.interopDefault(_xhrJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var knownAdapters = {
    http: (0, _httpJsDefault.default),
    xhr: (0, _xhrJsDefault.default)
};
(0, _utilsJsDefault.default).forEach(knownAdapters, function(fn, value) {
    if (fn) {
        try {
            Object.defineProperty(fn, "name", {
                value: value
            });
        } catch (e) {
        // eslint-disable-next-line no-empty
        }
        Object.defineProperty(fn, "adapterName", {
            value: value
        });
    }
});
var renderReason = function(reason) {
    return "- ".concat(reason);
};
var isResolvedHandle = function(adapter) {
    return (0, _utilsJsDefault.default).isFunction(adapter) || adapter === null || adapter === false;
};
exports.default = {
    getAdapter: function(adapters) {
        adapters = (0, _utilsJsDefault.default).isArray(adapters) ? adapters : [
            adapters
        ];
        var length = adapters.length;
        var nameOrAdapter;
        var adapter;
        var rejectedReasons = {};
        for(var i = 0; i < length; i++){
            nameOrAdapter = adapters[i];
            var id = void 0;
            adapter = nameOrAdapter;
            if (!isResolvedHandle(nameOrAdapter)) {
                adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
                if (adapter === undefined) throw new (0, _axiosErrorJsDefault.default)("Unknown adapter '".concat(id, "'"));
            }
            if (adapter) break;
            rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
            var reasons = Object.entries(rejectedReasons).map(function(param) {
                var _param = (0, _slicedToArray._)(param, 2), id = _param[0], state = _param[1];
                return "adapter ".concat(id, " ") + (state === false ? "is not supported by the environment" : "is not available in the build");
            });
            var s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
            throw new (0, _axiosErrorJsDefault.default)("There is no suitable adapter to dispatch the request " + s, "ERR_NOT_SUPPORT");
        }
        return adapter;
    },
    adapters: knownAdapters
};

},{"@swc/helpers/_/_sliced_to_array":"lHDUI","../utils.js":"bSnR4","./http.js":"13uSO","./xhr.js":"2HaEB","../core/AxiosError.js":"cvT67","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"2HaEB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _toArray = require("@swc/helpers/_/_to_array");
var _toConsumableArray = require("@swc/helpers/_/_to_consumable_array");
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _settleJs = require("./../core/settle.js");
var _settleJsDefault = parcelHelpers.interopDefault(_settleJs);
var _cookiesJs = require("./../helpers/cookies.js");
var _cookiesJsDefault = parcelHelpers.interopDefault(_cookiesJs);
var _buildURLJs = require("./../helpers/buildURL.js");
var _buildURLJsDefault = parcelHelpers.interopDefault(_buildURLJs);
var _buildFullPathJs = require("../core/buildFullPath.js");
var _buildFullPathJsDefault = parcelHelpers.interopDefault(_buildFullPathJs);
var _isURLSameOriginJs = require("./../helpers/isURLSameOrigin.js");
var _isURLSameOriginJsDefault = parcelHelpers.interopDefault(_isURLSameOriginJs);
var _transitionalJs = require("../defaults/transitional.js");
var _transitionalJsDefault = parcelHelpers.interopDefault(_transitionalJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _canceledErrorJs = require("../cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _parseProtocolJs = require("../helpers/parseProtocol.js");
var _parseProtocolJsDefault = parcelHelpers.interopDefault(_parseProtocolJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _speedometerJs = require("../helpers/speedometer.js");
var _speedometerJsDefault = parcelHelpers.interopDefault(_speedometerJs);
"use strict";
function progressEventReducer(listener, isDownloadStream) {
    var bytesNotified = 0;
    var _speedometer = (0, _speedometerJsDefault.default)(50, 250);
    return function(e) {
        var loaded = e.loaded;
        var total = e.lengthComputable ? e.total : undefined;
        var progressBytes = loaded - bytesNotified;
        var rate = _speedometer(progressBytes);
        var inRange = loaded <= total;
        bytesNotified = loaded;
        var data = {
            loaded: loaded,
            total: total,
            progress: total ? loaded / total : undefined,
            bytes: progressBytes,
            rate: rate ? rate : undefined,
            estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
            event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
    };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
exports.default = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = (0, _axiosHeadersJsDefault.default).from(config.headers).normalize();
        var responseType = config.responseType, withXSRFToken = config.withXSRFToken;
        var onCanceled;
        function done() {
            if (config.cancelToken) config.cancelToken.unsubscribe(onCanceled);
            if (config.signal) config.signal.removeEventListener("abort", onCanceled);
        }
        var contentType;
        if ((0, _utilsJsDefault.default).isFormData(requestData)) {
            if ((0, _indexJsDefault.default).hasStandardBrowserEnv || (0, _indexJsDefault.default).hasStandardBrowserWebWorkerEnv) requestHeaders.setContentType(false); // Let the browser set it
            else if ((contentType = requestHeaders.getContentType()) !== false) {
                // fix semicolon duplication issue for ReactNative FormData implementation
                var _ref = (0, _toArray._)(contentType ? contentType.split(";").map(function(token) {
                    return token.trim();
                }).filter(Boolean) : []), type = _ref[0], tokens = _ref.slice(1);
                requestHeaders.setContentType([
                    type || "multipart/form-data"
                ].concat((0, _toConsumableArray._)(tokens)).join("; "));
            }
        }
        var request = new XMLHttpRequest();
        // HTTP basic authentication
        if (config.auth) {
            var username = config.auth.username || "";
            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        var fullPath = (0, _buildFullPathJsDefault.default)(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), (0, _buildURLJsDefault.default)(fullPath, config.params, config.paramsSerializer), true);
        // Set the request timeout in MS
        request.timeout = config.timeout;
        function onloadend() {
            if (!request) return;
            // Prepare the response
            var responseHeaders = (0, _axiosHeadersJsDefault.default).from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config: config,
                request: request
            };
            (0, _settleJsDefault.default)(function _resolve(value) {
                resolve(value);
                done();
            }, function _reject(err) {
                reject(err);
                done();
            }, response);
            // Clean up request
            request = null;
        }
        if ("onloadend" in request) // Use onloadend if available
        request.onloadend = onloadend;
        else // Listen for ready state to emulate onloadend
        request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) return;
            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) return;
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
        };
        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
            if (!request) return;
            reject(new (0, _axiosErrorJsDefault.default)("Request aborted", (0, _axiosErrorJsDefault.default).ECONNABORTED, config, request));
            // Clean up request
            request = null;
        };
        // Handle low level network errors
        request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(new (0, _axiosErrorJsDefault.default)("Network Error", (0, _axiosErrorJsDefault.default).ERR_NETWORK, config, request));
            // Clean up request
            request = null;
        };
        // Handle timeout
        request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            var transitional = config.transitional || (0, _transitionalJsDefault.default);
            if (config.timeoutErrorMessage) timeoutErrorMessage = config.timeoutErrorMessage;
            reject(new (0, _axiosErrorJsDefault.default)(timeoutErrorMessage, transitional.clarifyTimeoutError ? (0, _axiosErrorJsDefault.default).ETIMEDOUT : (0, _axiosErrorJsDefault.default).ECONNABORTED, config, request));
            // Clean up request
            request = null;
        };
        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if ((0, _indexJsDefault.default).hasStandardBrowserEnv) {
            withXSRFToken && (0, _utilsJsDefault.default).isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
            if (withXSRFToken || withXSRFToken !== false && (0, _isURLSameOriginJsDefault.default)(fullPath)) {
                // Add xsrf header
                var xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && (0, _cookiesJsDefault.default).read(config.xsrfCookieName);
                if (xsrfValue) requestHeaders.set(config.xsrfHeaderName, xsrfValue);
            }
        }
        // Remove Content-Type if data is undefined
        requestData === undefined && requestHeaders.setContentType(null);
        // Add headers to the request
        if ("setRequestHeader" in request) (0, _utilsJsDefault.default).forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
        });
        // Add withCredentials to request if needed
        if (!(0, _utilsJsDefault.default).isUndefined(config.withCredentials)) request.withCredentials = !!config.withCredentials;
        // Add responseType to request if needed
        if (responseType && responseType !== "json") request.responseType = config.responseType;
        // Handle progress if needed
        if (typeof config.onDownloadProgress === "function") request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        // Not all browsers support upload events
        if (typeof config.onUploadProgress === "function" && request.upload) request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        if (config.cancelToken || config.signal) {
            // Handle cancellation
            // eslint-disable-next-line func-names
            onCanceled = function(cancel) {
                if (!request) return;
                reject(!cancel || cancel.type ? new (0, _canceledErrorJsDefault.default)(null, config, request) : cancel);
                request.abort();
                request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
        var protocol = (0, _parseProtocolJsDefault.default)(fullPath);
        if (protocol && (0, _indexJsDefault.default).protocols.indexOf(protocol) === -1) {
            reject(new (0, _axiosErrorJsDefault.default)("Unsupported protocol " + protocol + ":", (0, _axiosErrorJsDefault.default).ERR_BAD_REQUEST, config));
            return;
        }
        // Send the request
        request.send(requestData || null);
    });
};

},{"@swc/helpers/_/_to_array":"crCHG","@swc/helpers/_/_to_consumable_array":"ig3r6","./../utils.js":"bSnR4","./../core/settle.js":"9wf9J","./../helpers/cookies.js":"iF7CM","./../helpers/buildURL.js":"gIhwF","../core/buildFullPath.js":"4RrOH","./../helpers/isURLSameOrigin.js":"8TIwj","../defaults/transitional.js":"4YEEQ","../core/AxiosError.js":"cvT67","../cancel/CanceledError.js":"coV7f","../helpers/parseProtocol.js":"6qTxx","../platform/index.js":"3xlWB","../core/AxiosHeaders.js":"i1deg","../helpers/speedometer.js":"azhuX","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"crCHG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_to_array", function() {
    return _to_array;
});
parcelHelpers.export(exports, "_", function() {
    return _to_array;
});
var _arrayWithHolesJs = require("./_array_with_holes.js");
var _iterableToArrayJs = require("./_iterable_to_array.js");
var _nonIterableRestJs = require("./_non_iterable_rest.js");
var _unsupportedIterableToArrayJs = require("./_unsupported_iterable_to_array.js");
function _to_array(arr) {
    return (0, _arrayWithHolesJs._array_with_holes)(arr) || (0, _iterableToArrayJs._iterable_to_array)(arr) || (0, _unsupportedIterableToArrayJs._unsupported_iterable_to_array)(arr) || (0, _nonIterableRestJs._non_iterable_rest)();
}

},{"./_array_with_holes.js":"155GO","./_iterable_to_array.js":"frgWD","./_non_iterable_rest.js":"iyBaH","./_unsupported_iterable_to_array.js":"vagJ6","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"9wf9J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", function() {
    return settle;
});
var _axiosErrorJs = require("./AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
"use strict";
function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) resolve(response);
    else reject(new (0, _axiosErrorJsDefault.default)("Request failed with status code " + response.status, [
        (0, _axiosErrorJsDefault.default).ERR_BAD_REQUEST,
        (0, _axiosErrorJsDefault.default).ERR_BAD_RESPONSE
    ][Math.floor(response.status / 100) - 4], response.config, response.request, response));
}

},{"./AxiosError.js":"cvT67","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"iF7CM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
exports.default = (0, _indexJsDefault.default).hasStandardBrowserEnv ? // Standard browser envs support document.cookie
{
    write: function(name, value, expires, path, domain, secure) {
        var cookie = [
            name + "=" + encodeURIComponent(value)
        ];
        (0, _utilsJsDefault.default).isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        (0, _utilsJsDefault.default).isString(path) && cookie.push("path=" + path);
        (0, _utilsJsDefault.default).isString(domain) && cookie.push("domain=" + domain);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
    },
    read: function(name) {
        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function(name) {
        this.write(name, "", Date.now() - 86400000);
    }
} : // Non-standard browser env (web workers, react-native) lack needed support.
{
    write: function() {},
    read: function() {
        return null;
    },
    remove: function() {}
};

},{"./../utils.js":"bSnR4","../platform/index.js":"3xlWB","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"4RrOH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", function() {
    return buildFullPath;
});
var _isAbsoluteURLJs = require("../helpers/isAbsoluteURL.js");
var _isAbsoluteURLJsDefault = parcelHelpers.interopDefault(_isAbsoluteURLJs);
var _combineURLsJs = require("../helpers/combineURLs.js");
var _combineURLsJsDefault = parcelHelpers.interopDefault(_combineURLsJs);
"use strict";
function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !(0, _isAbsoluteURLJsDefault.default)(requestedURL)) return (0, _combineURLsJsDefault.default)(baseURL, requestedURL);
    return requestedURL;
}

},{"../helpers/isAbsoluteURL.js":"3GxWx","../helpers/combineURLs.js":"l5MWA","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"3GxWx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", function() {
    return isAbsoluteURL;
});
"use strict";
function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"l5MWA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", function() {
    return combineURLs;
});
"use strict";
function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"8TIwj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
"use strict";
exports.default = (0, _indexJsDefault.default).hasStandardBrowserEnv ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    /**
    * Parse a URL to discover its components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */ function resolveURL(url) {
        var href = url;
        if (msie) {
            // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */ return function isURLSameOrigin(requestURL) {
        var parsed = (0, _utilsJsDefault.default).isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
        return true;
    };
}();

},{"./../utils.js":"bSnR4","../platform/index.js":"3xlWB","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"6qTxx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", function() {
    return parseProtocol;
});
"use strict";
function parseProtocol(url) {
    var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"azhuX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */ function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    var bytes = new Array(samplesCount);
    var timestamps = new Array(samplesCount);
    var head = 0;
    var tail = 0;
    var firstSampleTS;
    min = min !== undefined ? min : 1000;
    return function push(chunkLength) {
        var now = Date.now();
        var startedAt = timestamps[tail];
        if (!firstSampleTS) firstSampleTS = now;
        bytes[head] = chunkLength;
        timestamps[head] = now;
        var i = tail;
        var bytesCount = 0;
        while(i !== head){
            bytesCount += bytes[i++];
            i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) tail = (tail + 1) % samplesCount;
        if (now - firstSampleTS < min) return;
        var passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
    };
}
exports.default = speedometer;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"1dcDU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", function() {
    return mergeConfig;
});
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosHeadersJs = require("./AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
var headersToObject = function(thing) {
    return thing instanceof (0, _axiosHeadersJsDefault.default) ? thing.toJSON() : thing;
};
function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    var config = {};
    function getMergedValue(target, source, caseless) {
        if ((0, _utilsJsDefault.default).isPlainObject(target) && (0, _utilsJsDefault.default).isPlainObject(source)) return (0, _utilsJsDefault.default).merge.call({
            caseless: caseless
        }, target, source);
        else if ((0, _utilsJsDefault.default).isPlainObject(source)) return (0, _utilsJsDefault.default).merge({}, source);
        else if ((0, _utilsJsDefault.default).isArray(source)) return source.slice();
        return source;
    }
    // eslint-disable-next-line consistent-return
    function mergeDeepProperties(a, b, caseless) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(a, b, caseless);
        else if (!(0, _utilsJsDefault.default).isUndefined(a)) return getMergedValue(undefined, a, caseless);
    }
    // eslint-disable-next-line consistent-return
    function valueFromConfig2(a, b) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(undefined, b);
    }
    // eslint-disable-next-line consistent-return
    function defaultToConfig2(a, b) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(undefined, b);
        else if (!(0, _utilsJsDefault.default).isUndefined(a)) return getMergedValue(undefined, a);
    }
    // eslint-disable-next-line consistent-return
    function mergeDirectKeys(a, b, prop) {
        if (prop in config2) return getMergedValue(a, b);
        else if (prop in config1) return getMergedValue(undefined, a);
    }
    var mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: function(a, b) {
            return mergeDeepProperties(headersToObject(a), headersToObject(b), true);
        }
    };
    (0, _utilsJsDefault.default).forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(config1[prop], config2[prop], prop);
        (0, _utilsJsDefault.default).isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
}

},{"../utils.js":"bSnR4","./AxiosHeaders.js":"i1deg","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"8M0BI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _typeOf = require("@swc/helpers/_/_type_of");
var _dataJs = require("../env/data.js");
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
"use strict";
var validators = {};
// eslint-disable-next-line func-names
[
    "object",
    "boolean",
    "number",
    "function",
    "string",
    "symbol"
].forEach(function(type, i) {
    validators[type] = function validator(thing) {
        return (typeof thing === "undefined" ? "undefined" : (0, _typeOf._)(thing)) === type || "a" + (i < 1 ? "n " : " ") + type;
    };
});
var deprecatedWarnings = {};
/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */ validators.transitional = function transitional(validator, version, message) {
    function formatMessage(opt, desc) {
        return "[Axios v" + (0, _dataJs.VERSION) + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    // eslint-disable-next-line func-names
    return function(value, opt, opts) {
        if (validator === false) throw new (0, _axiosErrorJsDefault.default)(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), (0, _axiosErrorJsDefault.default).ERR_DEPRECATED);
        if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            // eslint-disable-next-line no-console
            console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
    };
};
/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */ function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") throw new (0, _axiosErrorJsDefault.default)("options must be an object", (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION_VALUE);
    var keys = Object.keys(options);
    var i = keys.length;
    while(i-- > 0){
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
            var value = options[opt];
            var result = value === undefined || validator(value, opt, options);
            if (result !== true) throw new (0, _axiosErrorJsDefault.default)("option " + opt + " must be " + result, (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION_VALUE);
            continue;
        }
        if (allowUnknown !== true) throw new (0, _axiosErrorJsDefault.default)("Unknown option " + opt, (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION);
    }
}
exports.default = {
    assertOptions: assertOptions,
    validators: validators
};

},{"@swc/helpers/_/_type_of":"b4wfg","../env/data.js":"5l1Fg","../core/AxiosError.js":"cvT67","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"5l1Fg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", function() {
    return VERSION;
});
var VERSION = "1.6.5";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"59by1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _classCallCheck = require("@swc/helpers/_/_class_call_check");
var _createClass = require("@swc/helpers/_/_create_class");
var _canceledErrorJs = require("./CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
"use strict";
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */ var CancelToken = /*#__PURE__*/ function() {
    function CancelToken(executor) {
        (0, _classCallCheck._)(this, CancelToken);
        if (typeof executor !== "function") throw new TypeError("executor must be a function.");
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
        });
        var token = this;
        // eslint-disable-next-line func-names
        this.promise.then(function(cancel) {
            if (!token._listeners) return;
            var i = token._listeners.length;
            while(i-- > 0)token._listeners[i](cancel);
            token._listeners = null;
        });
        // eslint-disable-next-line func-names
        this.promise.then = function(onfulfilled) {
            var _resolve;
            // eslint-disable-next-line func-names
            var promise = new Promise(function(resolve) {
                token.subscribe(resolve);
                _resolve = resolve;
            }).then(onfulfilled);
            promise.cancel = function reject() {
                token.unsubscribe(_resolve);
            };
            return promise;
        };
        executor(function cancel(message, config, request) {
            if (token.reason) // Cancellation has already been requested
            return;
            token.reason = new (0, _canceledErrorJsDefault.default)(message, config, request);
            resolvePromise(token.reason);
        });
    }
    (0, _createClass._)(CancelToken, [
        {
            /**
   * Throws a `CanceledError` if cancellation has been requested.
   */ key: "throwIfRequested",
            value: function throwIfRequested() {
                if (this.reason) throw this.reason;
            }
        },
        {
            /**
   * Subscribe to the cancel signal
   */ key: "subscribe",
            value: function subscribe(listener) {
                if (this.reason) {
                    listener(this.reason);
                    return;
                }
                if (this._listeners) this._listeners.push(listener);
                else this._listeners = [
                    listener
                ];
            }
        },
        {
            /**
   * Unsubscribe from the cancel signal
   */ key: "unsubscribe",
            value: function unsubscribe(listener) {
                if (!this._listeners) return;
                var index = this._listeners.indexOf(listener);
                if (index !== -1) this._listeners.splice(index, 1);
            }
        }
    ], [
        {
            key: "source",
            value: /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */ function source() {
                var cancel;
                var token = new CancelToken(function executor(c) {
                    cancel = c;
                });
                return {
                    token: token,
                    cancel: cancel
                };
            }
        }
    ]);
    return CancelToken;
}();
exports.default = CancelToken;

},{"@swc/helpers/_/_class_call_check":"70JET","@swc/helpers/_/_create_class":"9CG3U","./CanceledError.js":"coV7f","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"jiIIH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", function() {
    return spread;
});
"use strict";
function spread(callback) {
    return function wrap(arr) {
        return callback.apply(null, arr);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"75Que":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", function() {
    return isAxiosError;
});
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
function isAxiosError(payload) {
    return (0, _utilsJsDefault.default).isObject(payload) && payload.isAxiosError === true;
}

},{"./../utils.js":"bSnR4","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"6R5zC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _slicedToArray = require("@swc/helpers/_/_sliced_to_array");
var HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(function(param) {
    var _param = (0, _slicedToArray._)(param, 2), key = _param[0], value = _param[1];
    HttpStatusCode[value] = key;
});
exports.default = HttpStatusCode;

},{"@swc/helpers/_/_sliced_to_array":"lHDUI","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"ful9o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "routeChanger", function() {
    return routeChanger;
});
var routeChanger = function routeChanger(url) {
    setTimeout(function() {
        location.assign(url);
    }, 1300);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"bm9NT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "verifyOtp", function() {
    return verifyOtp;
});
parcelHelpers.export(exports, "resendOtp", function() {
    return resendOtp;
});
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _routeChanger = require("./routeChanger");
var inputOtp = document.querySelector(".input-otp");
var otpErr = document.querySelector(".otp-para");
var verifyOtp = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var _$message, response, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    _state.trys.push([
                        0,
                        2,
                        ,
                        3
                    ]);
                    // checking otp is 4 charcter long
                    if (inputOtp.value.trim().length !== 4) {
                        otpErr.classList.add("err-otp-paragraph");
                        otpErr.classList.remove("success-otp-paragraph");
                        return [
                            2,
                            otpErr.textContent = "Enter a valid otp"
                        ];
                    }
                    otpErr.textContent = "";
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "POST",
                            url: "/api/v1/users/otp-verification",
                            data: {
                                otp: inputOtp.value
                            }
                        })
                    ];
                case 1:
                    response = _state.sent();
                    _$message = response.data.message;
                    otpErr.textContent = "";
                    (0, _routeChanger.routeChanger)("/");
                    return [
                        3,
                        3
                    ];
                case 2:
                    err = _state.sent();
                    message = err.response.data.message;
                    otpErr.id = "";
                    otpErr.textContent = message;
                    return [
                        3,
                        3
                    ];
                case 3:
                    return [
                        2
                    ];
            }
        });
    });
    return function verifyOtp() {
        return _ref.apply(this, arguments);
    };
}();
var resendOtp = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var response, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    _state.trys.push([
                        0,
                        2,
                        ,
                        3
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "POST",
                            url: "/api/v1/users/otp-verification?resend=true",
                            data: {
                                otp: inputOtp.value
                            }
                        })
                    ];
                case 1:
                    response = _state.sent();
                    message = response.data.message;
                    otpErr.classList.add("success-otp-paragraph");
                    otpErr.classList.remove("err-otp-paragraph");
                    otpErr;
                    otpErr.textContent = message;
                    return [
                        3,
                        3
                    ];
                case 2:
                    err = _state.sent();
                    console.log(err);
                    message = err.response.data.message;
                    otpErr.classList.remove("success-otp-paragraph");
                    otpErr.classList.add("err-otp-paragraph");
                    otpErr.textContent = message;
                    otpErr.id = "";
                    return [
                        3,
                        3
                    ];
                case 3:
                    return [
                        2
                    ];
            }
        });
    });
    return function resendOtp() {
        return _ref.apply(this, arguments);
    };
}();

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_ts_generator":"dhhs4","axios":"eCZhQ","./routeChanger":"ful9o","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"an02B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "loginUser", function() {
    return loginUser;
});
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _routeChanger = require("./routeChanger");
var inputMail = document.querySelector(".email");
var inputPassword = document.querySelector(".password");
var errorBox = document.querySelector(".message-container");
var loginUser = function() {
    var _ref = (0, _asyncToGenerator._)(function(e) {
        var response, error;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (!this.checkValidity()) return [
                        2
                    ];
                    e.preventDefault();
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "POST",
                            url: "/api/v1/users/login",
                            data: {
                                email: inputMail.value,
                                password: inputPassword.value
                            }
                        })
                    ];
                case 2:
                    response = _state.sent();
                    errorBox.classList.remove("error-container");
                    errorBox.textContent = "Dont't Hesitate";
                    (0, _routeChanger.routeChanger)("/");
                    return [
                        3,
                        4
                    ];
                case 3:
                    error = _state.sent();
                    console.log(error);
                    errorBox.textContent = error.response.data.message;
                    errorBox.classList.add("error-container");
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function loginUser(e) {
        return _ref.apply(this, arguments);
    };
}();

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_ts_generator":"dhhs4","axios":"eCZhQ","./routeChanger":"ful9o","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"9dYhW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "searchTours", function() {
    return searchTours;
});
parcelHelpers.export(exports, "categorizeTour", function() {
    return categorizeTour;
});
parcelHelpers.export(exports, "renderTopTours", function() {
    return renderTopTours;
});
parcelHelpers.export(exports, "renderAllTours", function() {
    return renderAllTours;
});
parcelHelpers.export(exports, "renderFilterTour", function() {
    return renderFilterTour;
});
parcelHelpers.export(exports, "paginateRight", function() {
    return paginateRight;
});
parcelHelpers.export(exports, "paginateLeft", function() {
    return paginateLeft;
});
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var tourContainer = document.querySelector(".tour-cards");
var heading = document.querySelector(".tertiary-heading");
var pageCount = document.querySelector(".page-number");
var iconRight = document.querySelector(".icon-right");
var iconLeft = document.querySelector(".icon-left");
var page = 1;
var skip = 7;
var allTours, currentTour;
var resetPagination = function resetPagination(tours) {
    page = 1;
    pageCount.textContent = page;
    iconLeft.classList.add("hide");
    iconRight.classList.add("hide");
    if (tours.length > 7) iconRight.classList.remove("hide");
    if (page > 1) iconLeft.classList.remove("hide");
    console.log(page, page > 1);
};
var getTours = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var response, tours;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (allTours) return [
                        2,
                        allTours
                    ];
                    return [
                        4,
                        fetch("/api/v1/tours")
                    ];
                case 1:
                    return [
                        4,
                        _state.sent().json()
                    ];
                case 2:
                    response = _state.sent();
                    tours = response.data.tours;
                    allTours = tours;
                    return [
                        2,
                        allTours
                    ];
            }
        });
    });
    return function getTours() {
        return _ref.apply(this, arguments);
    };
}();
var setLocalStorage = function setLocalStorage(item, index) {
    localStorage.setItem("selectValue", JSON.stringify(item));
};
var getLocalStorage = function getLocalStorage(key) {
    var value = JSON.parse(localStorage.getItem(key));
    return value;
};
var createMarkup = function createMarkup(data) {
    var markup = '<div class="tour-card">\n                    <img class="card-img" src='.concat(data.coverImg, ' alt="Tour image">\n                    <p class="brand-heading"><span class="upper-part">').concat(data.tourName, '</span></p>\n                    <div class="icons">\n                        <div class="row">\n                        <p><i class="tour-icon fa-solid fa-location-dot"></i> ').concat(data.location, '</p>\n                        <p><i class="tour-icon fa-solid fa-calendar-days"></i> ').concat(data.duration, '</p>\n                    </div>\n                        <div class="row">\n                        <p><i class="tour-icon fa-regular fa-flag"></i> ').concat(data.stops, '</p>\n                        <p><i class="tour-icon fa-regular fa-user"></i> ').concat(data.maxPeople, ' </p>\n                        </div>\n                    </div>\n                    <a class="btn" id="light-green" href="/tour/').concat(data.slug, '">More</a></div>');
    return markup;
};
var renderTour = function renderTour(tours) {
    tourContainer.innerHTML = "";
    var cloneTours = tours.slice(skip * page - skip, skip * page);
    console.log(cloneTours.length);
    if (cloneTours.length !== skip) iconRight.classList.add("hide");
    cloneTours.forEach(function(tour) {
        var html = createMarkup(tour);
        tourContainer.insertAdjacentHTML("beforeend", html);
    });
};
var searchTours = function() {
    var _ref = (0, _asyncToGenerator._)(function(e) {
        var searchValue, tours, regex, searchedTour;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    tourContainer.innerHTML = "";
                    searchValue = this.value.trim();
                    return [
                        4,
                        getTours()
                    ];
                case 1:
                    tours = _state.sent();
                    regex = new RegExp("^".concat(searchValue), "i");
                    searchedTour = tours.filter(function(tour) {
                        return regex.test(tour.tourName.toLowerCase());
                    });
                    if (searchedTour.length === 0) return [
                        2,
                        heading.textContent = "No tour found"
                    ];
                    heading.textContent = "Explore all the tours";
                    currentTour = searchedTour;
                    resetPagination(searchedTour);
                    renderTour(searchedTour);
                    return [
                        2
                    ];
            }
        });
    });
    return function searchTours(e) {
        return _ref.apply(this, arguments);
    };
}();
var categorizeTour = function() {
    var _ref = (0, _asyncToGenerator._)(function(e) {
        var selectedOption, response, tours;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    tourContainer.innerHTML = "";
                    selectedOption = this.options[this.selectedIndex];
                    setLocalStorage(selectedOption.value);
                    return [
                        4,
                        fetch("api/v1/tours?".concat(selectedOption.value))
                    ];
                case 1:
                    return [
                        4,
                        _state.sent().json()
                    ];
                case 2:
                    response = _state.sent();
                    tours = response.data.tours;
                    if (tours.length === 0) return [
                        2,
                        heading.textContent = "No tour found"
                    ];
                    currentTour = tours;
                    resetPagination(tours);
                    renderTour(tours);
                    return [
                        2
                    ];
            }
        });
    });
    return function categorizeTour(e) {
        return _ref.apply(this, arguments);
    };
}();
var renderTopTours = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var response, tours;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    tourContainer.innerHTML = "";
                    return [
                        4,
                        fetch("/api/v1/tours?rating[gt]=4.5&&sort=price&limit=5")
                    ];
                case 1:
                    return [
                        4,
                        _state.sent().json()
                    ];
                case 2:
                    response = _state.sent();
                    tours = response.data.tours;
                    if (tours.length === 0) return [
                        2,
                        heading.textContent = "No tour found"
                    ];
                    currentTour = tours;
                    resetPagination(tours);
                    renderTour(tours);
                    return [
                        2
                    ];
            }
        });
    });
    return function renderTopTours() {
        return _ref.apply(this, arguments);
    };
}();
var renderAllTours = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var selectVal, url, response, tours;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    selectVal = getLocalStorage("selectValue");
                    url = selectVal ? "/api/v1/tours?".concat(selectVal) : "/api/v1/tours";
                    if (!tourContainer) return [
                        2
                    ];
                    tourContainer.innerHTML = "";
                    return [
                        4,
                        fetch(url)
                    ];
                case 1:
                    return [
                        4,
                        _state.sent().json()
                    ];
                case 2:
                    response = _state.sent();
                    tours = response.data.tours;
                    if (tours.length === 0) return [
                        2,
                        heading.textContent = "No tour found"
                    ];
                    currentTour = tours;
                    resetPagination(tours);
                    renderTour(tours);
                    return [
                        2
                    ];
            }
        });
    });
    return function renderAllTours() {
        return _ref.apply(this, arguments);
    };
}();
var renderFilterTour = function() {
    var _ref = (0, _asyncToGenerator._)(function(e) {
        var isEl, checkBoxes, el, res, tours;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    // Elements
                    isEl = e.target.classList.contains("checkbox-default");
                    checkBoxes = document.querySelectorAll(".checkbox-default");
                    if (!isEl) return [
                        2
                    ];
                    //current checkbox
                    el = e.target;
                    // clearing all other checkbox
                    checkBoxes.forEach(function(item) {
                        if (el !== item) item.checked = false;
                    });
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "GET",
                            url: "api/v1/tours?".concat(el.value)
                        })
                    ];
                case 1:
                    res = _state.sent();
                    tours = res.data.data.tours;
                    currentTour = tours;
                    resetPagination(tours);
                    // rendering filtered tours
                    renderTour(tours);
                    return [
                        2
                    ];
            }
        });
    });
    return function renderFilterTour(e) {
        return _ref.apply(this, arguments);
    };
}();
renderAllTours();
var paginateRight = function paginateRight() {
    page++;
    console.log(page);
    pageCount.textContent = page;
    if (page > 1) iconLeft.classList.remove("hide");
    renderTour(currentTour);
};
var paginateLeft = function paginateLeft() {
    page--;
    pageCount.textContent = page;
    iconRight.classList.remove("hide");
    if (page <= 1) iconLeft.classList.add("hide");
    renderTour(currentTour);
};

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_ts_generator":"dhhs4","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0","axios":"eCZhQ"}],"kLVhs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "renderNotificationMenu", function() {
    return renderNotificationMenu;
});
parcelHelpers.export(exports, "renderGroupedBookings", function() {
    return renderGroupedBookings;
});
parcelHelpers.export(exports, "renderAnalytics", function() {
    return renderAnalytics;
});
parcelHelpers.export(exports, "showUsers", function() {
    return showUsers;
});
parcelHelpers.export(exports, "adminAction", function() {
    return adminAction;
});
parcelHelpers.export(exports, "showTours", function() {
    return showTours;
});
parcelHelpers.export(exports, "editPopup", function() {
    return editPopup;
});
parcelHelpers.export(exports, "renderCouponEditPopup", function() {
    return renderCouponEditPopup;
});
parcelHelpers.export(exports, "renderDatePicker", function() {
    return renderDatePicker;
});
parcelHelpers.export(exports, "downloadSalesReport", function() {
    return downloadSalesReport;
});
parcelHelpers.export(exports, "editTour", function() {
    return editTour;
});
parcelHelpers.export(exports, "createTour", function() {
    return createTour;
});
parcelHelpers.export(exports, "showAllBookings", function() {
    return showAllBookings;
});
parcelHelpers.export(exports, "updateBooking", function() {
    return updateBooking;
});
parcelHelpers.export(exports, "renderCoupons", function() {
    return renderCoupons;
});
parcelHelpers.export(exports, "sendNotification", function() {
    return sendNotification;
});
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _toConsumableArray = require("@swc/helpers/_/_to_consumable_array");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _sweetalert2 = require("sweetalert2");
var _sweetalert2Default = parcelHelpers.interopDefault(_sweetalert2);
var _chartJs = require("chart.js");
var _fileSaver = require("file-saver");
var _Chart;
(_Chart = (0, _chartJs.Chart)).register.apply(_Chart, (0, _toConsumableArray._)((0, _chartJs.registerables)));
// DOM ELEMENTS
var itemsContainer = document.querySelector(".dash-board-commodity");
var dashboardHeading = document.querySelector(".dashboard-heading");
var dashBoardRightItem = document.querySelector(".dash-board-actions");
var date = document.querySelector(".date");
var addTourIcon = document.querySelector(".fa-plus");
var bookingBtn = document.querySelector(".admin-bookings-btn");
var ws = new WebSocket("wss://expora-75fa4c861fb7.herokuapp.com/");
ws.addEventListener("open", function() {
    console.log("WebSocket connection opened");
});
ws.addEventListener("message", function(e) {
    var data = JSON.parse(e.data);
    var msg = data;
    // sending notification with notification pi
    showNotification(msg);
});
ws.addEventListener("close", function() {
    console.log("server closed");
});
// displaying current date
var now = new Date();
if (date) date.textContent = "".concat(now.getDate(), "/").concat(now.getMonth() + 1, "/").concat(now.getFullYear());
// creating user  markup
var generateUserMarkup = function generateUserMarkup(data) {
    return ' <div class="item" data-slug="'.concat(data.slug, '">\n                    <div class="contents">\n                        <img class="item-img" src=').concat(data.profileImg, '>\n                        <p class="item-name">').concat(data.name, '</p>\n                        <div class="btns">\n                            <button class="edit-btn orange admin-user-block-btn">block</button>\n                            <button class="edit-btn green admin-user-unblock-btn">unblock</button>\n                            <button class="edit-btn red admin-user-delete-btn">delete</button>\n                        </div> \n                    </div>\n                </div>');
};
var generateCouponMarkup = function generateCouponMarkup(data) {
    return '<div class="coupon-container border-green">\n              <p class="coupon-code">COUPON CODE: '.concat(data.couponCode, '</p>\n              <p class="coupon-valid">VALID: ').concat(data.isValid === true ? "Yes" : "No", '</p>\n              <div class="btns">\n                <button class="edit-btn orange admin-coupon-delete-btn" data-coupon-id=').concat(data._id, '>delete</button>\n                <button class="edit-btn green admin-coupon-edit-btn" data-coupon-id=').concat(data._id, ">edit</button>\n              </div>\n          </div>");
};
// creating Tour markup
var generateBookingMarkup = function generateBookingMarkup(data) {
    var _data_tour, _data_tour1;
    var hideVerifyBtn = data.status === "confirmed" ? "hide" : "";
    var hideRejectBtn = data.status === "cancelled" ? "hide" : "";
    return ' <div class="item" data-slug="'.concat(data === null || data === void 0 ? void 0 : data._id, '">\n                <div class="contents">\n                    <img class="item-img" src=').concat((_data_tour = data.tour) === null || _data_tour === void 0 ? void 0 : _data_tour.coverImg, '>\n                    <p class="item-name">').concat((_data_tour1 = data.tour) === null || _data_tour1 === void 0 ? void 0 : _data_tour1.tourName, '</p>\n                    <div class="btns">\n                        <button class="edit-btn red admin-tour-reject-btn ').concat(hideRejectBtn, '">reject</button>\n                        <button class="edit-btn green admin-tour-verify-btn ').concat(hideVerifyBtn, '">verify</button>\n                        <a href="/booking-info/').concat(data._id, '" id="light-blue" class="edit-btn admin-info-btn" data-booking-code=').concat(data.bookingId, ">info</a>\n                    </div> \n                </div>\n            </div>");
};
// creating a sending notification markup
var generateNotificationMarkup = function generateNotificationMarkup() {
    var notificationMarkup = '<div class="notification">\n                            <form class="notification-form">\n                              <input class="input-notification-subject" type="text" placeholder="Heading" required minlength=4 pattern="[a-zA-Z]*"/>\n                              <textarea class="message-area notification-text" placeholder="content" required minlength=10 pattern="[a-zA-Z]*"></textarea>\n                              <button class="btn center notification-btn">Send notification</button>\n                            </form>\n                          </div>';
    return notificationMarkup;
};
var generateTourMarkup = function generateTourMarkup(data) {
    return ' <div class="item" data-slug="'.concat(data.slug, '">\n              <div class="contents">\n                  <img class="item-img" src=').concat(data.coverImg, '>\n                  <p class="item-name">').concat(data.tourName, '</p>\n                  <div class="btns">\n                      <button class="edit-btn green admin-tour-edit-btn }">edit</button>\n                      <button class="edit-btn red admin-tour-delete-btn">delete</button>\n                  </div> \n              </div>\n           </div>');
};
var createAnalyticsMarkup = function createAnalyticsMarkup() {
    return '<canvas id="myChart" class="grap-chart"></canvas>';
};
var renderNotificationMenu = function renderNotificationMenu() {
    // clearing item in container
    itemsContainer.innerHTML = "";
    dashBoardRightItem.innerHTML = "";
    itemsContainer.classList = "";
    itemsContainer.classList.add("dash-board-commodity-feedback");
    var markup = generateNotificationMarkup();
    itemsContainer.insertAdjacentHTML("beforeend", markup);
};
var renderDropDown = function renderDropDown() {
    dashBoardRightItem.innerHTML = "";
    var optionMarkup = '<select class="analytics-dropdown">\n                          <option value="2023">Monthly</option>\n                          <option value="all"> Yearly</option>\n                        </select> \n                        \n                        <button class="download-btn">Download </button>\n                        ';
    dashBoardRightItem.insertAdjacentHTML("beforeend", optionMarkup);
};
// top bar for  grouped tour headings
var renderGroupedTourBar = function renderGroupedTourBar() {
    var markup = '<div class="booking-heading">\n                    <p class="boooking-tour-name">Tour </p>\n                    <p class="booking-user-name">Customer </p>\n                    <p class="booking-date">Month</p>\n                    <p class="booking-price">Price</p>\n                  </div>';
    itemsContainer.insertAdjacentHTML("beforeend", markup);
};
var createBookingsMarkup = function createBookingsMarkup(booking) {
    var months = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
    ];
    var bookingMonth = months[new Date(booking.createdAt).getMonth()];
    return '<div class="tour">\n            <img class="booking-tour-img" src='.concat(booking.tour.coverImg, ' alt="Tour image" />\n            <p class="booking-cutomer-name">').concat(booking.user.name, '</p>\n            <p class="booking-tour-date">').concat(bookingMonth, '</p>\n            <p class="booking-tour-price">').concat(booking.tour.price, "</p>\n          </div>");
};
var renderBookingSelect = function renderBookingSelect(bookings) {
    var options = "";
    bookings.forEach(function(booking) {
        if (options.includes(booking.tour.tourName)) ;
        else options += "<option value=".concat(booking.tour._id, ">").concat(booking.tour.tourName, "</option>");
    });
    var tourOptionMarkup = '<select class="booking-select">'.concat(options, "</select>");
    dashBoardRightItem.insertAdjacentHTML("beforeend", tourOptionMarkup);
};
var renderGraph = function() {
    var _ref = (0, _asyncToGenerator._)(function(value) {
        var chart, markup, data, analytics, stats, labelArr, ctx, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    itemsContainer.innerHTML = "";
                    markup = createAnalyticsMarkup();
                    itemsContainer.insertAdjacentHTML("beforeend", markup);
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "GET",
                            url: "/api/v1/bookings/stats/".concat(value)
                        })
                    ];
                case 2:
                    data = _state.sent();
                    console.log(data);
                    analytics = data.data.data.stat;
                    stats = analytics.map(function(stat) {
                        return stat.count;
                    });
                    labelArr = analytics.map(function(stat) {
                        return stat.dateInfo;
                    });
                    // render graphs
                    ctx = document.getElementById("myChart");
                    chart = new (0, _chartJs.Chart)(ctx, {
                        type: "bar",
                        data: {
                            labels: labelArr,
                            datasets: [
                                {
                                    label: "Analytics of  ".concat(value),
                                    data: stats,
                                    borderWidth: 1
                                }
                            ]
                        },
                        options: {
                            onClick: function onClick(ev, el) {
                                var labelIndex = el[0].index;
                                var labelValue = chart.data.labels[labelIndex];
                                if (typeof labelValue !== "number") return;
                                renderGraph(labelValue);
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    console.log(err);
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function renderGraph(value) {
        return _ref.apply(this, arguments);
    };
}();
var dropdownAction = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    return [
                        4,
                        renderGraph(this.value)
                    ];
                case 1:
                    _state.sent();
                    return [
                        2
                    ];
            }
        });
    });
    return function dropdownAction() {
        return _ref.apply(this, arguments);
    };
}();
var renderGroupedBookings = function() {
    var _ref = (0, _asyncToGenerator._)(function(tourId) {
        var res, bookings, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    // clear everything
                    itemsContainer.innerHTML = "";
                    itemsContainer.classList = "";
                    dashBoardRightItem.innerHTML = "";
                    dashboardHeading.textContent = "Bookings";
                    itemsContainer.classList.add("grouped-booking");
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "GET",
                            url: "/api/v1/bookings/tour/".concat(tourId)
                        })
                    ];
                case 2:
                    res = _state.sent();
                    // taking boking from response
                    bookings = res.data.data.booking;
                    // rendering a top bar to show title of each items
                    renderGroupedTourBar();
                    // rendering every tours
                    bookings.forEach(function(booking) {
                        var html = createBookingsMarkup(booking);
                        itemsContainer.insertAdjacentHTML("beforeend", html);
                    });
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    console.log(err);
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function renderGroupedBookings(tourId) {
        return _ref.apply(this, arguments);
    };
}();
// rendering items
var renderItems = function renderItems(data) {
    itemsContainer.insertAdjacentHTML("beforeend", data);
};
var renderAnalytics = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var markup, year;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    itemsContainer.classList = "";
                    itemsContainer.classList.add("dash-board-commodity-graph");
                    markup = createAnalyticsMarkup();
                    itemsContainer.insertAdjacentHTML("beforeend", markup);
                    // rendering dropdown for monthly and year wise result
                    renderDropDown();
                    year = new Date(Date.now()).getFullYear();
                    return [
                        4,
                        renderGraph(year)
                    ];
                case 1:
                    _state.sent();
                    // adding eventListner to dropdown
                    document.querySelector(".analytics-dropdown").addEventListener("change", dropdownAction);
                    dashboardHeading.textContent = "Analytics";
                    return [
                        2
                    ];
            }
        });
    });
    return function renderAnalytics() {
        return _ref.apply(this, arguments);
    };
}();
// updating tour
var updateTour = function() {
    var _ref = (0, _asyncToGenerator._)(function(slug, inputs) {
        var form, tourFeatures, response, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    form = new FormData();
                    tourFeatures = inputs.inputFeatures.value.split(",");
                    form.append("tourName", inputs.inputTourName.value);
                    form.append("catagory", inputs.inputCatagorey.value);
                    form.append("difficulty", inputs.inputDifficulty.value);
                    form.append("maxPeople", inputs.inputMaxPeople.value);
                    form.append("location", inputs.inputLocation.value);
                    form.append("duration", inputs.inputDuration.value);
                    form.append("price", inputs.inputPrice.value);
                    form.append("description", inputs.inputDescription.value);
                    tourFeatures.forEach(function(feature, i) {
                        form.append("features[".concat(i, "]"), feature);
                    });
                    form.append("stops", Number.parseInt(inputs.inputStops.value));
                    if (inputs.coverImg.files.length > 0) form.append("coverImg", inputs.coverImg.files[0]);
                    // Assuming inputs.tourImg_1, inputs.tourImg_2, inputs.tourImg_3 are input fields for tour images
                    if (inputs.tourImg_1.files.length > 0) form.append("tourImgs", inputs.tourImg_1.files[0]);
                    if (inputs.tourImg_2.files.length > 0) form.append("tourImgs", inputs.tourImg_2.files[0]);
                    if (inputs.tourImg_3.files.length > 0) form.append("tourImgs", inputs.tourImg_3.files[0]);
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "PATCH",
                            url: "/api/v1/tours/slug/".concat(slug),
                            data: form
                        })
                    ];
                case 2:
                    response = _state.sent();
                    showTours();
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    console.log(err);
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function updateTour(slug, inputs) {
        return _ref.apply(this, arguments);
    };
}();
var showUsers = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var response, users, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    itemsContainer.innerHTML = "";
                    itemsContainer.classList = "";
                    dashBoardRightItem.innerHTML = "";
                    dashboardHeading.textContent = "Users";
                    itemsContainer.classList.add("dash-board-commodity");
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "GET",
                            url: "/api/v1/users"
                        })
                    ];
                case 2:
                    response = _state.sent();
                    users = response.data.data.users;
                    users.forEach(function(user) {
                        var userMarkup = generateUserMarkup(user);
                        renderItems(userMarkup);
                        dashboardHeading.textContent = "users";
                    });
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    console.log(err);
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function showUsers() {
        return _ref.apply(this, arguments);
    };
}();
var adminAction = function() {
    var _ref = (0, _asyncToGenerator._)(function(id, updateObj, text) {
        var response, message, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    _state.trys.push([
                        0,
                        2,
                        ,
                        3
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "PATCH",
                            url: "api/v1/admins/user/".concat(id),
                            data: updateObj
                        })
                    ];
                case 1:
                    response = _state.sent();
                    message = response.data.message;
                    (0, _sweetalert2Default.default).fire({
                        icon: "success",
                        title: message,
                        text: text,
                        confirmButtonColor: "#71C34E"
                    });
                    return [
                        3,
                        3
                    ];
                case 2:
                    err = _state.sent();
                    console.log(err);
                    return [
                        3,
                        3
                    ];
                case 3:
                    return [
                        2
                    ];
            }
        });
    });
    return function adminAction(id, updateObj, text) {
        return _ref.apply(this, arguments);
    };
}();
var showTours = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var response, tours;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    // addTourIcon.classList.remove("hide");
                    itemsContainer.innerHTML = "";
                    itemsContainer.classList = "";
                    itemsContainer.classList.add("dash-board-commodity");
                    dashboardHeading.textContent = "Tours";
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "GET",
                            url: "/api/v1/tours"
                        })
                    ];
                case 1:
                    response = _state.sent();
                    tours = response.data.data.tours;
                    tours.forEach(function(tour) {
                        var markup = generateTourMarkup(tour);
                        renderItems(markup);
                        dashboardHeading.textContent = "tours";
                    });
                    return [
                        2
                    ];
            }
        });
    });
    return function showTours() {
        return _ref.apply(this, arguments);
    };
}();
var editPopup = function() {
    var _ref = (0, _asyncToGenerator._)(function(slug) {
        var tour, response;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    // default tour value mainly used to create tour
                    tour = {
                        slug: "",
                        coverImg: "/img/tours/select-tour.png",
                        tourName: "",
                        catagory: "",
                        difficulty: "",
                        maxPeople: "",
                        location: "",
                        duration: "",
                        price: "",
                        stops: "",
                        tourImgs: [
                            "/img/tours/select-tour.png",
                            "/img/tours/select-tour.png",
                            "/img/tours/select-tour.png"
                        ],
                        features: [],
                        description: ""
                    };
                    if (!slug) return [
                        3,
                        2
                    ];
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "get",
                            url: "api/v1/tours/slug/".concat(slug)
                        })
                    ];
                case 1:
                    response = _state.sent();
                    tour = response.data.data.tour;
                    _state.label = 2;
                case 2:
                    // edit or create popup
                    return [
                        2,
                        (0, _sweetalert2Default.default).fire({
                            html: '<form class="update-form" data-slug="'.concat(tour.slug || "", '">') + '<input type="file" accept="image/*" id="input-cover-image"  name="coverImg">' + '<label for="input-cover-image"><img src="'.concat(tour.coverImg || "", '" alt="Image" class="img-update-box" /></label>') + '<input type="text" id="input1" class="swal2-input edit-input visible " value="rona"  >' + "<div class='swal-input-row'>" + '<input type="text" id="input1" class="swal2-input edit-input input-tour-name swal-input-edit" required minlength="6" placeholder="Tour name" value="'.concat(tour.tourName || "", '">') + '<input type="text" id="input2" class="swal2-input edit-input input-catagorey swal-input-edit" required minlength="4" placeholder="Catagory" value="'.concat(tour.catagory || "", '">') + "</div>" + "<div class='swal-input-row'>" + '<input type="text" id="input1" class="swal2-input edit-input input-difficulty swal-input-edit" required minlength="4" placeholder="Difficulty" value="'.concat(tour.difficulty || "", '">') + '<input type="text" id="input2" class="swal2-input edit-input input-max-people swal-input-edit" required minlength="1" placeholder="Max people" value="'.concat(tour.maxPeople || "", '">') + "</div>" + "<div class='swal-input-row'>" + '<input type="text" id="input2" class="swal2-input edit-input input-location swal-input-edit" required minlength="3" placeholder="Location" value="'.concat(tour.location || "", '">') + '<input type="text" id="input1" class="swal2-input edit-input input-duration swal-input-edit" required minlength="1" placeholder="Duration" value="'.concat(tour.duration || "", '">') + "</div>" + "<div class='swal-input-row'>" + '<input type="text" id="input2" class="swal2-input edit-input input-price swal-input-edit" required minlength="1" placeholder="Price" value="'.concat(tour.price || "", '">') + '<input type="text" id="input2" class="swal2-input edit-input input-stop swal-input-edit" required minlength="1" placeholder="Stops" value="'.concat(tour.stops || "", '">') + "</div>" + '<div class="swal-input-row">' + '<label for="input-images-1"><img class="select-img" src="'.concat(tour.tourImgs[0], '"></label>') + '<input class="input-cover-img-1" id="input-images-1" type="file" accept="image/*" name="tourImgs">' + '<label for="input-images-2"><img class="select-img" src="'.concat(tour.tourImgs[1], '"></label>') + '<input class="input-cover-img-2" id="input-images-2" type="file" accept="image/*" name="tourImgs">' + '<label for="input-images-3"><img class="select-img" src="'.concat(tour.tourImgs[2], '"></label>') + '<input class="input-cover-img-3" id="input-images-3" type="file" accept="image/*" name="tourImgs">' + "</div>" + '<textarea id="txtArea" rows="20" cols="20" class="swal2-textarea input-features swal-input-edit" required minlength="10" placeholder="Features">'.concat(tour.features.join(",") || "", "</textarea>") + '<textarea id="txtArea" rows="10" cols="20" class="swal2-textarea input-description swal-input-edit" required minlength="40" placeholder="Tour description">'.concat(tour.description || "", "</textarea>") + "</form>",
                            confirmButtonText: "Submit",
                            showCancelButton: true,
                            preConfirm: /*#__PURE__*/ (0, _asyncToGenerator._)(function() {
                                var form, inputFields, regex, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, input;
                                return (0, _tsGenerator._)(this, function(_state) {
                                    // form
                                    form = document.querySelector(".update-form");
                                    inputFields = Array.from(document.querySelectorAll(".swal-input-edit"));
                                    // regex to check if any special charcater is included in input
                                    regex = new RegExp(/[!@#$%^&*()_+\-=\[\]{};':"\\|<>\/?~]/);
                                    _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                    try {
                                        // checking every input
                                        for(_iterator = inputFields[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                            input = _step.value;
                                            if (regex.test(input.value) || input.value.trim().length === 0) {
                                                (0, _sweetalert2Default.default).showValidationMessage("check any field is empty or any field has special characters");
                                                return [
                                                    2,
                                                    false
                                                ];
                                            }
                                        }
                                    } catch (err) {
                                        _didIteratorError = true;
                                        _iteratorError = err;
                                    } finally{
                                        try {
                                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                                _iterator.return();
                                            }
                                        } finally{
                                            if (_didIteratorError) {
                                                throw _iteratorError;
                                            }
                                        }
                                    }
                                    // check form is valid
                                    if (!form.checkValidity()) {
                                        (0, _sweetalert2Default.default).showValidationMessage("check if any field is empty or you give any improper details");
                                        return [
                                            2,
                                            false
                                        ];
                                    }
                                    return [
                                        2,
                                        true
                                    ];
                                });
                            })
                        })
                    ];
            }
        });
    });
    return function editPopup(slug) {
        return _ref.apply(this, arguments);
    };
}();
var renderCouponEditPopup = function() {
    var _ref = (0, _asyncToGenerator._)(function(e, fn) {
        var _e_target, coupon, _e_target_dataset, couponId, res, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    // Take coupon id for findig coupon
                    couponId = ((_e_target_dataset = (_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.dataset) !== null && _e_target_dataset !== void 0 ? _e_target_dataset : null).couponId;
                    if (!couponId) return [
                        2
                    ];
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "GET",
                            url: "/api/v1/coupons/".concat(couponId)
                        })
                    ];
                case 2:
                    res = _state.sent();
                    coupon = res.data.data.coupon;
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    console.log(err);
                    return [
                        3,
                        4
                    ];
                case 4:
                    (0, _sweetalert2Default.default).fire({
                        title: "Edit",
                        html: '<form class="edit-coupon-form"><div style="display: flex; flex-direction: column; gap: 10px;"><label for="couponCode">Coupon Code</label>' + '<input id="couponCode" class="swal2-input input-coupon-code" value='.concat(coupon.couponCode, '  style="margin-top: 0;" placeholder="Enter Coupon Code" required minlength="4" maxlength="6">') + '<label for="valid">Valid</label>' + '<input id="valid" class="swal2-input input-coupon-valid" value='.concat(coupon.isValid === true ? "Yes" : "No", '  style="margin-top: 0;" placeholder="Enter Valid" required title="value must be yes or no">') + '<label for="discount">Discount</label>' + '<input id="discount" class="swal2-input input-coupon-discount" value='.concat(coupon.discountPercentage, ' style="margin-top: 0;" placeholder="Enter Discount" required>') + "</div>" + "</form>",
                        preConfirm: function() {
                            var form = document.querySelector(".edit-coupon-form");
                            var coupon = document.querySelector(".input-coupon-code").value;
                            var discount = document.querySelector(".input-coupon-discount").value;
                            var tokenValidity = document.querySelector(".input-coupon-valid").value;
                            if (tokenValidity.trim().toLowerCase() !== "yes" && tokenValidity.trim().toLowerCase() !== "no") return (0, _sweetalert2Default.default).showValidationMessage("invalid input for valid field");
                            if (!form.checkValidity()) return (0, _sweetalert2Default.default).showValidationMessage("Please fill every input field in valid format");
                            tokenValidity = tokenValidity.trim().toLowerCase() === "yes" ? true : false;
                            fn({
                                coupon: coupon,
                                discount: discount,
                                tokenValidity: tokenValidity,
                                couponId: couponId
                            });
                        }
                    });
                    return [
                        2
                    ];
            }
        });
    });
    return function renderCouponEditPopup(e, fn) {
        return _ref.apply(this, arguments);
    };
}();
var renderDatePicker = function renderDatePicker(fn) {
    (0, _sweetalert2Default.default).fire({
        title: "Select Date Range",
        html: '<div><label for="start-date">Start Date:</label><input type="date" id="start-date" class="swal2-input start-date" /></div><div><label for="end-date">End Date:</label><input type="date" id="end-date" class="swal2-input end-date" /></div></div>',
        focusConfirm: false,
        preConfirm: function() {
            var startDate = document.getElementById("start-date").value;
            var endDate = document.getElementById("end-date").value;
            // const selectedFormat = document.getElementById("format-select").value;
            if (!startDate || !endDate) {
                (0, _sweetalert2Default.default).showValidationMessage("Please select both start and end dates");
                return false;
            }
            fn({
                startDate: startDate,
                endDate: endDate
            });
        }
    });
};
var downloadSalesReport = function() {
    var _ref = (0, _asyncToGenerator._)(function(obj) {
        var startDate, endDate, data, fileName, blob, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    startDate = obj.startDate, endDate = obj.endDate;
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "POST",
                            url: "api/v1/bookings/sales-revenue",
                            data: {
                                startDate: startDate,
                                endDate: endDate
                            },
                            responseType: "arraybuffer"
                        })
                    ];
                case 2:
                    data = _state.sent();
                    // file name for downloading pdf
                    fileName = "sales-report.pdf";
                    // creating a blob  for file to download
                    blob = new Blob([
                        data.data
                    ], {
                        type: data.headers["Content-Type"]
                    });
                    // downloading it
                    (0, _fileSaver.saveAs)(blob, fileName);
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    (0, _sweetalert2Default.default).fire("Error downloading pdf try again later");
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function downloadSalesReport(obj) {
        return _ref.apply(this, arguments);
    };
}();
var editTour = function() {
    var _ref = (0, _asyncToGenerator._)(function(slug, inputFields) {
        return (0, _tsGenerator._)(this, function(_state) {
            updateTour(slug, inputFields);
            showTours();
            return [
                2
            ];
        });
    });
    return function editTour(slug, inputFields) {
        return _ref.apply(this, arguments);
    };
}();
var createTour = function() {
    var _ref = (0, _asyncToGenerator._)(function(inputs) {
        var form, response, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    form = new FormData();
                    form.append("tourName", inputs.inputTourName.value);
                    form.append("catagory", inputs.inputCatagorey.value);
                    form.append("difficulty", inputs.inputDifficulty.value);
                    form.append("maxPeople", inputs.inputMaxPeople.value);
                    form.append("location", inputs.inputLocation.value);
                    form.append("duration", inputs.inputDuration.value);
                    form.append("price", inputs.inputPrice.value);
                    form.append("description", inputs.inputDescription.value);
                    form.append("features", inputs.inputFeatures.value.split(","));
                    form.append("stops", Number.parseInt(inputs.inputStops.value));
                    if (inputs.coverImg.files.length > 0) form.append("coverImg", inputs.coverImg.files[0]);
                    // Assuming inputs.tourImg_1, inputs.tourImg_2, inputs.tourImg_3 are input fields for tour images
                    if (inputs.tourImg_1.files.length > 0) form.append("tourImgs", inputs.tourImg_1.files[0]);
                    if (inputs.tourImg_2.files.length > 0) form.append("tourImgs", inputs.tourImg_2.files[0]);
                    if (inputs.tourImg_3.files.length > 0) form.append("tourImgs", inputs.tourImg_3.files[0]);
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "POST",
                            url: "/api/v1/tours",
                            data: form
                        })
                    ];
                case 2:
                    response = _state.sent();
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    console.log(err);
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function createTour(inputs) {
        return _ref.apply(this, arguments);
    };
}();
var showAllBookings = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var response, bookings;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    // clear all items
                    itemsContainer.innerHTML = "";
                    dashBoardRightItem.innerHTML = "";
                    itemsContainer.classList = "";
                    itemsContainer.classList.add("dash-board-commodity");
                    dashboardHeading.textContent = "bookings";
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "GET",
                            url: "api/v1/bookings"
                        })
                    ];
                case 1:
                    response = _state.sent();
                    bookings = response.data.data.bookings;
                    // rendering a select with all booked tour
                    renderBookingSelect(bookings);
                    // rendering the booking
                    bookings.forEach(function(booking) {
                        var markup = generateBookingMarkup(booking);
                        renderItems(markup);
                    });
                    return [
                        2
                    ];
            }
        });
    });
    return function showAllBookings() {
        return _ref.apply(this, arguments);
    };
}();
var updateBooking = function() {
    var _ref = (0, _asyncToGenerator._)(function(bookingId, status, text) {
        var booking, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    _state.trys.push([
                        0,
                        2,
                        ,
                        3
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "PATCH",
                            url: "api/v1/bookings/".concat(bookingId),
                            data: {
                                status: status
                            }
                        })
                    ];
                case 1:
                    booking = _state.sent();
                    (0, _sweetalert2Default.default).fire({
                        icon: "success",
                        title: "Success",
                        text: text,
                        confirmButtonColor: "#71C34E"
                    });
                    showAllBookings();
                    return [
                        3,
                        3
                    ];
                case 2:
                    err = _state.sent();
                    console.log(err);
                    return [
                        3,
                        3
                    ];
                case 3:
                    return [
                        2
                    ];
            }
        });
    });
    return function updateBooking(bookingId, status, text) {
        return _ref.apply(this, arguments);
    };
}();
var renderCoupons = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var addIconMarkup, res, coupons, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    itemsContainer.innerHTML = "";
                    dashBoardRightItem.innerHTML = "";
                    itemsContainer.classList = "";
                    itemsContainer.classList.add("dash-board-commodity-coupon");
                    dashboardHeading.textContent = "Coupons";
                    addIconMarkup = '<a href="/create-coupon"><i class="fa fa-plus add-icon"></i></a>';
                    dashBoardRightItem.insertAdjacentHTML("beforeend", addIconMarkup);
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "GET",
                            url: "api/v1/coupons"
                        })
                    ];
                case 2:
                    res = _state.sent();
                    coupons = res.data.data.coupons;
                    coupons.forEach(function(coupon) {
                        var html = generateCouponMarkup(coupon);
                        itemsContainer.insertAdjacentHTML("beforeend", html);
                    });
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    (0, _sweetalert2Default.default).fire("Something went wrong");
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function renderCoupons() {
        return _ref.apply(this, arguments);
    };
}();
// showing notification with notification api
var showNotification = function showNotification(contentObj) {
    // getting data
    var notificationContent = contentObj.notificationContent, notificationSubject = contentObj.notificationSubject;
    // displaying notification
    new Notification(notificationSubject, {
        body: notificationContent,
        icon: "/img/Expora.png"
    });
};
var sendNotification = function sendNotification(e) {
    var form = document.querySelector(".notification-form");
    // prettier-ignore
    var notificationContent = document.querySelector(".notification-text").value;
    // prettier-ignore
    var notificationSubject = document.querySelector(".input-notification-subject").value;
    if (!form.checkValidity()) return;
    e.preventDefault();
    // sending notification content through ws
    if (ws.readyState === WebSocket.OPEN) {
        var data = {
            notificationContent: notificationContent,
            notificationSubject: notificationSubject
        };
        ws.send(JSON.stringify(data));
    }
};

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_ts_generator":"dhhs4","axios":"eCZhQ","sweetalert2":"2OR50","file-saver":"bpu2t","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0","@swc/helpers/_/_to_consumable_array":"ig3r6","chart.js":"hHQ1w"}],"2OR50":[function(require,module,exports) {
var _typeOf = require("@swc/helpers/_/_type_of");
/*!
* sweetalert2 v11.10.2
* Released under the MIT License.
*/ (function(global, factory) {
    module.exports = factory();
})(undefined, function() {
    "use strict";
    function _iterableToArrayLimit(r, l) {
        var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (null != t) {
            var e, n, i, u, a = [], f = !0, o = !1;
            try {
                if (i = (t = t.call(r)).next, 0 === l) {
                    if (Object(t) !== t) return;
                    f = !1;
                } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
            } catch (r) {
                o = !0, n = r;
            } finally{
                try {
                    if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
                } finally{
                    if (o) throw n;
                }
            }
            return a;
        }
    }
    function _toPrimitive(t, r) {
        if ("object" != typeof t || !t) return t;
        var e = t[Symbol.toPrimitive];
        if (void 0 !== e) {
            var i = e.call(t, r || "default");
            if ("object" != typeof i) return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r ? String : Number)(t);
    }
    function _toPropertyKey(t) {
        var i = _toPrimitive(t, "string");
        return "symbol" == (typeof i === "undefined" ? "undefined" : (0, _typeOf._)(i)) ? i : String(i);
    }
    function _typeof(o) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function _typeof(o) {
            return typeof o;
        } : function(o) {
            return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
        }, _typeof(o);
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
        for(var i = 0; i < props.length; i++){
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
            writable: false
        });
        return Constructor;
    }
    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                writable: true,
                configurable: true
            }
        });
        Object.defineProperty(subClass, "prototype", {
            writable: false
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o;
        };
        return _setPrototypeOf(o, p);
    }
    function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;
        try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
            return true;
        } catch (e) {
            return false;
        }
    }
    function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) _construct = Reflect.construct.bind();
        else _construct = function _construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _setPrototypeOf(instance, Class.prototype);
            return instance;
        };
        return _construct.apply(null, arguments);
    }
    function _assertThisInitialized(self) {
        if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return self;
    }
    function _possibleConstructorReturn(self, call) {
        if (call && (typeof call === "object" || typeof call === "function")) return call;
        else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
        return _assertThisInitialized(self);
    }
    function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            } else result = Super.apply(this, arguments);
            return _possibleConstructorReturn(this, result);
        };
    }
    function _superPropBase(object, property) {
        while(!Object.prototype.hasOwnProperty.call(object, property)){
            object = _getPrototypeOf(object);
            if (object === null) break;
        }
        return object;
    }
    function _get() {
        if (typeof Reflect !== "undefined" && Reflect.get) _get = Reflect.get.bind();
        else _get = function _get(target, property, receiver) {
            var base = _superPropBase(target, property);
            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.get) return desc.get.call(arguments.length < 3 ? target : receiver);
            return desc.value;
        };
        return _get.apply(this, arguments);
    }
    function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
    }
    function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
        return arr2;
    }
    function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _classPrivateFieldGet(receiver, privateMap) {
        var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
        return _classApplyDescriptorGet(receiver, descriptor);
    }
    function _classPrivateFieldSet(receiver, privateMap, value) {
        var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
        _classApplyDescriptorSet(receiver, descriptor, value);
        return value;
    }
    function _classExtractFieldDescriptor(receiver, privateMap, action) {
        if (!privateMap.has(receiver)) throw new TypeError("attempted to " + action + " private field on non-instance");
        return privateMap.get(receiver);
    }
    function _classApplyDescriptorGet(receiver, descriptor) {
        if (descriptor.get) return descriptor.get.call(receiver);
        return descriptor.value;
    }
    function _classApplyDescriptorSet(receiver, descriptor, value) {
        if (descriptor.set) descriptor.set.call(receiver, value);
        else {
            if (!descriptor.writable) throw new TypeError("attempted to set read only private field");
            descriptor.value = value;
        }
    }
    function _checkPrivateRedeclaration(obj, privateCollection) {
        if (privateCollection.has(obj)) throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
    function _classPrivateFieldInitSpec(obj, privateMap, value) {
        _checkPrivateRedeclaration(obj, privateMap);
        privateMap.set(obj, value);
    }
    var RESTORE_FOCUS_TIMEOUT = 100;
    /** @type {GlobalState} */ var globalState = {};
    var focusPreviousActiveElement = function focusPreviousActiveElement() {
        if (globalState.previousActiveElement instanceof HTMLElement) {
            globalState.previousActiveElement.focus();
            globalState.previousActiveElement = null;
        } else if (document.body) document.body.focus();
    };
    /**
   * Restore previous active (focused) element
   *
   * @param {boolean} returnFocus
   * @returns {Promise<void>}
   */ var restoreActiveElement = function restoreActiveElement(returnFocus) {
        return new Promise(function(resolve) {
            if (!returnFocus) return resolve();
            var x = window.scrollX;
            var y = window.scrollY;
            globalState.restoreFocusTimeout = setTimeout(function() {
                focusPreviousActiveElement();
                resolve();
            }, RESTORE_FOCUS_TIMEOUT); // issues/900
            window.scrollTo(x, y);
        });
    };
    var swalPrefix = "swal2-";
    /**
   * @typedef
   * { | 'container'
   *   | 'shown'
   *   | 'height-auto'
   *   | 'iosfix'
   *   | 'popup'
   *   | 'modal'
   *   | 'no-backdrop'
   *   | 'no-transition'
   *   | 'toast'
   *   | 'toast-shown'
   *   | 'show'
   *   | 'hide'
   *   | 'close'
   *   | 'title'
   *   | 'html-container'
   *   | 'actions'
   *   | 'confirm'
   *   | 'deny'
   *   | 'cancel'
   *   | 'default-outline'
   *   | 'footer'
   *   | 'icon'
   *   | 'icon-content'
   *   | 'image'
   *   | 'input'
   *   | 'file'
   *   | 'range'
   *   | 'select'
   *   | 'radio'
   *   | 'checkbox'
   *   | 'label'
   *   | 'textarea'
   *   | 'inputerror'
   *   | 'input-label'
   *   | 'validation-message'
   *   | 'progress-steps'
   *   | 'active-progress-step'
   *   | 'progress-step'
   *   | 'progress-step-line'
   *   | 'loader'
   *   | 'loading'
   *   | 'styled'
   *   | 'top'
   *   | 'top-start'
   *   | 'top-end'
   *   | 'top-left'
   *   | 'top-right'
   *   | 'center'
   *   | 'center-start'
   *   | 'center-end'
   *   | 'center-left'
   *   | 'center-right'
   *   | 'bottom'
   *   | 'bottom-start'
   *   | 'bottom-end'
   *   | 'bottom-left'
   *   | 'bottom-right'
   *   | 'grow-row'
   *   | 'grow-column'
   *   | 'grow-fullscreen'
   *   | 'rtl'
   *   | 'timer-progress-bar'
   *   | 'timer-progress-bar-container'
   *   | 'scrollbar-measure'
   *   | 'icon-success'
   *   | 'icon-warning'
   *   | 'icon-info'
   *   | 'icon-question'
   *   | 'icon-error'
   * } SwalClass
   * @typedef {Record<SwalClass, string>} SwalClasses
   */ /**
   * @typedef {'success' | 'warning' | 'info' | 'question' | 'error'} SwalIcon
   * @typedef {Record<SwalIcon, string>} SwalIcons
   */ /** @type {SwalClass[]} */ var classNames = [
        "container",
        "shown",
        "height-auto",
        "iosfix",
        "popup",
        "modal",
        "no-backdrop",
        "no-transition",
        "toast",
        "toast-shown",
        "show",
        "hide",
        "close",
        "title",
        "html-container",
        "actions",
        "confirm",
        "deny",
        "cancel",
        "default-outline",
        "footer",
        "icon",
        "icon-content",
        "image",
        "input",
        "file",
        "range",
        "select",
        "radio",
        "checkbox",
        "label",
        "textarea",
        "inputerror",
        "input-label",
        "validation-message",
        "progress-steps",
        "active-progress-step",
        "progress-step",
        "progress-step-line",
        "loader",
        "loading",
        "styled",
        "top",
        "top-start",
        "top-end",
        "top-left",
        "top-right",
        "center",
        "center-start",
        "center-end",
        "center-left",
        "center-right",
        "bottom",
        "bottom-start",
        "bottom-end",
        "bottom-left",
        "bottom-right",
        "grow-row",
        "grow-column",
        "grow-fullscreen",
        "rtl",
        "timer-progress-bar",
        "timer-progress-bar-container",
        "scrollbar-measure",
        "icon-success",
        "icon-warning",
        "icon-info",
        "icon-question",
        "icon-error"
    ];
    var swalClasses = classNames.reduce(function(acc, className) {
        acc[className] = swalPrefix + className;
        return acc;
    }, /** @type {SwalClasses} */ {});
    /** @type {SwalIcon[]} */ var icons = [
        "success",
        "warning",
        "info",
        "question",
        "error"
    ];
    var iconTypes = icons.reduce(function(acc, icon) {
        acc[icon] = swalPrefix + icon;
        return acc;
    }, /** @type {SwalIcons} */ {});
    var consolePrefix = "SweetAlert2:";
    /**
   * Capitalize the first letter of a string
   *
   * @param {string} str
   * @returns {string}
   */ var capitalizeFirstLetter = function capitalizeFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    };
    /**
   * Standardize console warnings
   *
   * @param {string | string[]} message
   */ var warn = function warn(message) {
        console.warn("".concat(consolePrefix, " ").concat(_typeof(message) === "object" ? message.join(" ") : message));
    };
    /**
   * Standardize console errors
   *
   * @param {string} message
   */ var error = function error(message) {
        console.error("".concat(consolePrefix, " ").concat(message));
    };
    /**
   * Private global state for `warnOnce`
   *
   * @type {string[]}
   * @private
   */ var previousWarnOnceMessages = [];
    /**
   * Show a console warning, but only if it hasn't already been shown
   *
   * @param {string} message
   */ var warnOnce = function warnOnce(message) {
        if (!previousWarnOnceMessages.includes(message)) {
            previousWarnOnceMessages.push(message);
            warn(message);
        }
    };
    /**
   * Show a one-time console warning about deprecated params/methods
   *
   * @param {string} deprecatedParam
   * @param {string} useInstead
   */ var warnAboutDeprecation = function warnAboutDeprecation(deprecatedParam, useInstead) {
        warnOnce('"'.concat(deprecatedParam, '" is deprecated and will be removed in the next major release. Please use "').concat(useInstead, '" instead.'));
    };
    /**
   * If `arg` is a function, call it (with no arguments or context) and return the result.
   * Otherwise, just pass the value through
   *
   * @param {Function | any} arg
   * @returns {any}
   */ var callIfFunction = function callIfFunction(arg) {
        return typeof arg === "function" ? arg() : arg;
    };
    /**
   * @param {any} arg
   * @returns {boolean}
   */ var hasToPromiseFn = function hasToPromiseFn(arg) {
        return arg && typeof arg.toPromise === "function";
    };
    /**
   * @param {any} arg
   * @returns {Promise<any>}
   */ var asPromise = function asPromise(arg) {
        return hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);
    };
    /**
   * @param {any} arg
   * @returns {boolean}
   */ var isPromise = function isPromise(arg) {
        return arg && Promise.resolve(arg) === arg;
    };
    /**
   * Gets the popup container which contains the backdrop and the popup itself.
   *
   * @returns {HTMLElement | null}
   */ var getContainer = function getContainer() {
        return document.body.querySelector(".".concat(swalClasses.container));
    };
    /**
   * @param {string} selectorString
   * @returns {HTMLElement | null}
   */ var elementBySelector = function elementBySelector(selectorString) {
        var container = getContainer();
        return container ? container.querySelector(selectorString) : null;
    };
    /**
   * @param {string} className
   * @returns {HTMLElement | null}
   */ var elementByClass = function elementByClass(className) {
        return elementBySelector(".".concat(className));
    };
    /**
   * @returns {HTMLElement | null}
   */ var getPopup = function getPopup() {
        return elementByClass(swalClasses.popup);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getIcon = function getIcon() {
        return elementByClass(swalClasses.icon);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getIconContent = function getIconContent() {
        return elementByClass(swalClasses["icon-content"]);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getTitle = function getTitle() {
        return elementByClass(swalClasses.title);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getHtmlContainer = function getHtmlContainer() {
        return elementByClass(swalClasses["html-container"]);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getImage = function getImage() {
        return elementByClass(swalClasses.image);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getProgressSteps = function getProgressSteps() {
        return elementByClass(swalClasses["progress-steps"]);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getValidationMessage = function getValidationMessage() {
        return elementByClass(swalClasses["validation-message"]);
    };
    /**
   * @returns {HTMLButtonElement | null}
   */ var getConfirmButton = function getConfirmButton() {
        return /** @type {HTMLButtonElement} */ elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.confirm));
    };
    /**
   * @returns {HTMLButtonElement | null}
   */ var getCancelButton = function getCancelButton() {
        return /** @type {HTMLButtonElement} */ elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.cancel));
    };
    /**
   * @returns {HTMLButtonElement | null}
   */ var getDenyButton = function getDenyButton() {
        return /** @type {HTMLButtonElement} */ elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.deny));
    };
    /**
   * @returns {HTMLElement | null}
   */ var getInputLabel = function getInputLabel() {
        return elementByClass(swalClasses["input-label"]);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getLoader = function getLoader() {
        return elementBySelector(".".concat(swalClasses.loader));
    };
    /**
   * @returns {HTMLElement | null}
   */ var getActions = function getActions() {
        return elementByClass(swalClasses.actions);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getFooter = function getFooter() {
        return elementByClass(swalClasses.footer);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getTimerProgressBar = function getTimerProgressBar() {
        return elementByClass(swalClasses["timer-progress-bar"]);
    };
    /**
   * @returns {HTMLElement | null}
   */ var getCloseButton = function getCloseButton() {
        return elementByClass(swalClasses.close);
    };
    // https://github.com/jkup/focusable/blob/master/index.js
    var focusable = '\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex="0"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n';
    /**
   * @returns {HTMLElement[]}
   */ var getFocusableElements = function getFocusableElements() {
        var popup = getPopup();
        if (!popup) return [];
        /** @type {NodeListOf<HTMLElement>} */ var focusableElementsWithTabindex = popup.querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])');
        var focusableElementsWithTabindexSorted = Array.from(focusableElementsWithTabindex)// sort according to tabindex
        .sort(function(a, b) {
            var tabindexA = parseInt(a.getAttribute("tabindex") || "0");
            var tabindexB = parseInt(b.getAttribute("tabindex") || "0");
            if (tabindexA > tabindexB) return 1;
            else if (tabindexA < tabindexB) return -1;
            return 0;
        });
        /** @type {NodeListOf<HTMLElement>} */ var otherFocusableElements = popup.querySelectorAll(focusable);
        var otherFocusableElementsFiltered = Array.from(otherFocusableElements).filter(function(el) {
            return el.getAttribute("tabindex") !== "-1";
        });
        return _toConsumableArray(new Set(focusableElementsWithTabindexSorted.concat(otherFocusableElementsFiltered))).filter(function(el) {
            return isVisible$1(el);
        });
    };
    /**
   * @returns {boolean}
   */ var isModal = function isModal() {
        return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses["toast-shown"]) && !hasClass(document.body, swalClasses["no-backdrop"]);
    };
    /**
   * @returns {boolean}
   */ var isToast = function isToast() {
        var popup = getPopup();
        if (!popup) return false;
        return hasClass(popup, swalClasses.toast);
    };
    /**
   * @returns {boolean}
   */ var isLoading = function isLoading() {
        var popup = getPopup();
        if (!popup) return false;
        return popup.hasAttribute("data-loading");
    };
    /**
   * Securely set innerHTML of an element
   * https://github.com/sweetalert2/sweetalert2/issues/1926
   *
   * @param {HTMLElement} elem
   * @param {string} html
   */ var setInnerHtml = function setInnerHtml(elem, html) {
        elem.textContent = "";
        if (html) {
            var parser = new DOMParser();
            var parsed = parser.parseFromString(html, "text/html");
            var head = parsed.querySelector("head");
            head && Array.from(head.childNodes).forEach(function(child) {
                elem.appendChild(child);
            });
            var body = parsed.querySelector("body");
            body && Array.from(body.childNodes).forEach(function(child) {
                if (child instanceof HTMLVideoElement || child instanceof HTMLAudioElement) elem.appendChild(child.cloneNode(true)); // https://github.com/sweetalert2/sweetalert2/issues/2507
                else elem.appendChild(child);
            });
        }
    };
    /**
   * @param {HTMLElement} elem
   * @param {string} className
   * @returns {boolean}
   */ var hasClass = function hasClass(elem, className) {
        if (!className) return false;
        var classList = className.split(/\s+/);
        for(var i = 0; i < classList.length; i++){
            if (!elem.classList.contains(classList[i])) return false;
        }
        return true;
    };
    /**
   * @param {HTMLElement} elem
   * @param {SweetAlertOptions} params
   */ var removeCustomClasses = function removeCustomClasses(elem, params) {
        Array.from(elem.classList).forEach(function(className) {
            if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass || {}).includes(className)) elem.classList.remove(className);
        });
    };
    /**
   * @param {HTMLElement} elem
   * @param {SweetAlertOptions} params
   * @param {string} className
   */ var applyCustomClass = function applyCustomClass(elem, params, className) {
        removeCustomClasses(elem, params);
        if (params.customClass && params.customClass[className]) {
            if (typeof params.customClass[className] !== "string" && !params.customClass[className].forEach) {
                warn("Invalid type of customClass.".concat(className, '! Expected string or iterable object, got "').concat(_typeof(params.customClass[className]), '"'));
                return;
            }
            addClass(elem, params.customClass[className]);
        }
    };
    /**
   * @param {HTMLElement} popup
   * @param {import('./renderers/renderInput').InputClass | SweetAlertInput} inputClass
   * @returns {HTMLInputElement | null}
   */ var getInput$1 = function getInput(popup, inputClass) {
        if (!inputClass) return null;
        switch(inputClass){
            case "select":
            case "textarea":
            case "file":
                return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses[inputClass]));
            case "checkbox":
                return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.checkbox, " input"));
            case "radio":
                return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.radio, " input:checked")) || popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.radio, " input:first-child"));
            case "range":
                return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.range, " input"));
            default:
                return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.input));
        }
    };
    /**
   * @param {HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement} input
   */ var focusInput = function focusInput(input) {
        input.focus();
        // place cursor at end of text in text input
        if (input.type !== "file") {
            // http://stackoverflow.com/a/2345915
            var val = input.value;
            input.value = "";
            input.value = val;
        }
    };
    /**
   * @param {HTMLElement | HTMLElement[] | null} target
   * @param {string | string[] | readonly string[] | undefined} classList
   * @param {boolean} condition
   */ var toggleClass = function toggleClass(target, classList, condition) {
        if (!target || !classList) return;
        if (typeof classList === "string") classList = classList.split(/\s+/).filter(Boolean);
        classList.forEach(function(className) {
            if (Array.isArray(target)) target.forEach(function(elem) {
                condition ? elem.classList.add(className) : elem.classList.remove(className);
            });
            else condition ? target.classList.add(className) : target.classList.remove(className);
        });
    };
    /**
   * @param {HTMLElement | HTMLElement[] | null} target
   * @param {string | string[] | readonly string[] | undefined} classList
   */ var addClass = function addClass(target, classList) {
        toggleClass(target, classList, true);
    };
    /**
   * @param {HTMLElement | HTMLElement[] | null} target
   * @param {string | string[] | readonly string[] | undefined} classList
   */ var removeClass = function removeClass(target, classList) {
        toggleClass(target, classList, false);
    };
    /**
   * Get direct child of an element by class name
   *
   * @param {HTMLElement} elem
   * @param {string} className
   * @returns {HTMLElement | undefined}
   */ var getDirectChildByClass = function getDirectChildByClass(elem, className) {
        var children = Array.from(elem.children);
        for(var i = 0; i < children.length; i++){
            var child = children[i];
            if (child instanceof HTMLElement && hasClass(child, className)) return child;
        }
    };
    /**
   * @param {HTMLElement} elem
   * @param {string} property
   * @param {*} value
   */ var applyNumericalStyle = function applyNumericalStyle(elem, property, value) {
        if (value === "".concat(parseInt(value))) value = parseInt(value);
        if (value || parseInt(value) === 0) elem.style.setProperty(property, typeof value === "number" ? "".concat(value, "px") : value);
        else elem.style.removeProperty(property);
    };
    /**
   * @param {HTMLElement | null} elem
   * @param {string} display
   */ var show = function show(elem) {
        var display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "flex";
        elem && (elem.style.display = display);
    };
    /**
   * @param {HTMLElement | null} elem
   */ var hide = function hide(elem) {
        elem && (elem.style.display = "none");
    };
    /**
   * @param {HTMLElement | null} elem
   * @param {string} display
   */ var showWhenInnerHtmlPresent = function showWhenInnerHtmlPresent(elem) {
        var display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "block";
        if (!elem) return;
        new MutationObserver(function() {
            toggle(elem, elem.innerHTML, display);
        }).observe(elem, {
            childList: true,
            subtree: true
        });
    };
    /**
   * @param {HTMLElement} parent
   * @param {string} selector
   * @param {string} property
   * @param {string} value
   */ var setStyle = function setStyle(parent, selector, property, value) {
        /** @type {HTMLElement | null} */ var el = parent.querySelector(selector);
        if (el) el.style.setProperty(property, value);
    };
    /**
   * @param {HTMLElement} elem
   * @param {any} condition
   * @param {string} display
   */ var toggle = function toggle(elem, condition) {
        var display = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "flex";
        condition ? show(elem, display) : hide(elem);
    };
    /**
   * borrowed from jquery $(elem).is(':visible') implementation
   *
   * @param {HTMLElement | null} elem
   * @returns {boolean}
   */ var isVisible$1 = function isVisible(elem) {
        return !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
    };
    /**
   * @returns {boolean}
   */ var allButtonsAreHidden = function allButtonsAreHidden() {
        return !isVisible$1(getConfirmButton()) && !isVisible$1(getDenyButton()) && !isVisible$1(getCancelButton());
    };
    /**
   * @param {HTMLElement} elem
   * @returns {boolean}
   */ var isScrollable = function isScrollable(elem) {
        return !!(elem.scrollHeight > elem.clientHeight);
    };
    /**
   * borrowed from https://stackoverflow.com/a/46352119
   *
   * @param {HTMLElement} elem
   * @returns {boolean}
   */ var hasCssAnimation = function hasCssAnimation(elem) {
        var style = window.getComputedStyle(elem);
        var animDuration = parseFloat(style.getPropertyValue("animation-duration") || "0");
        var transDuration = parseFloat(style.getPropertyValue("transition-duration") || "0");
        return animDuration > 0 || transDuration > 0;
    };
    /**
   * @param {number} timer
   * @param {boolean} reset
   */ var animateTimerProgressBar = function animateTimerProgressBar(timer) {
        var reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var timerProgressBar = getTimerProgressBar();
        if (!timerProgressBar) return;
        if (isVisible$1(timerProgressBar)) {
            if (reset) {
                timerProgressBar.style.transition = "none";
                timerProgressBar.style.width = "100%";
            }
            setTimeout(function() {
                timerProgressBar.style.transition = "width ".concat(timer / 1000, "s linear");
                timerProgressBar.style.width = "0%";
            }, 10);
        }
    };
    var stopTimerProgressBar = function stopTimerProgressBar() {
        var timerProgressBar = getTimerProgressBar();
        if (!timerProgressBar) return;
        var timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
        timerProgressBar.style.removeProperty("transition");
        timerProgressBar.style.width = "100%";
        var timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
        var timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;
        timerProgressBar.style.width = "".concat(timerProgressBarPercent, "%");
    };
    /**
   * Detect Node env
   *
   * @returns {boolean}
   */ var isNodeEnv = function isNodeEnv() {
        return typeof window === "undefined" || typeof document === "undefined";
    };
    var sweetHTML = '\n <div aria-labelledby="'.concat(swalClasses.title, '" aria-describedby="').concat(swalClasses["html-container"], '" class="').concat(swalClasses.popup, '" tabindex="-1">\n   <button type="button" class="').concat(swalClasses.close, '"></button>\n   <ul class="').concat(swalClasses["progress-steps"], '"></ul>\n   <div class="').concat(swalClasses.icon, '"></div>\n   <img class="').concat(swalClasses.image, '" />\n   <h2 class="').concat(swalClasses.title, '" id="').concat(swalClasses.title, '"></h2>\n   <div class="').concat(swalClasses["html-container"], '" id="').concat(swalClasses["html-container"], '"></div>\n   <input class="').concat(swalClasses.input, '" id="').concat(swalClasses.input, '" />\n   <input type="file" class="').concat(swalClasses.file, '" />\n   <div class="').concat(swalClasses.range, '">\n     <input type="range" />\n     <output></output>\n   </div>\n   <select class="').concat(swalClasses.select, '" id="').concat(swalClasses.select, '"></select>\n   <div class="').concat(swalClasses.radio, '"></div>\n   <label class="').concat(swalClasses.checkbox, '">\n     <input type="checkbox" id="').concat(swalClasses.checkbox, '" />\n     <span class="').concat(swalClasses.label, '"></span>\n   </label>\n   <textarea class="').concat(swalClasses.textarea, '" id="').concat(swalClasses.textarea, '"></textarea>\n   <div class="').concat(swalClasses["validation-message"], '" id="').concat(swalClasses["validation-message"], '"></div>\n   <div class="').concat(swalClasses.actions, '">\n     <div class="').concat(swalClasses.loader, '"></div>\n     <button type="button" class="').concat(swalClasses.confirm, '"></button>\n     <button type="button" class="').concat(swalClasses.deny, '"></button>\n     <button type="button" class="').concat(swalClasses.cancel, '"></button>\n   </div>\n   <div class="').concat(swalClasses.footer, '"></div>\n   <div class="').concat(swalClasses["timer-progress-bar-container"], '">\n     <div class="').concat(swalClasses["timer-progress-bar"], '"></div>\n   </div>\n </div>\n').replace(/(^|\n)\s*/g, "");
    /**
   * @returns {boolean}
   */ var resetOldContainer = function resetOldContainer() {
        var oldContainer = getContainer();
        if (!oldContainer) return false;
        oldContainer.remove();
        removeClass([
            document.documentElement,
            document.body
        ], [
            swalClasses["no-backdrop"],
            swalClasses["toast-shown"],
            swalClasses["has-column"]
        ]);
        return true;
    };
    var resetValidationMessage$1 = function resetValidationMessage() {
        globalState.currentInstance.resetValidationMessage();
    };
    var addInputChangeListeners = function addInputChangeListeners() {
        var popup = getPopup();
        var input = getDirectChildByClass(popup, swalClasses.input);
        var file = getDirectChildByClass(popup, swalClasses.file);
        /** @type {HTMLInputElement} */ var range = popup.querySelector(".".concat(swalClasses.range, " input"));
        /** @type {HTMLOutputElement} */ var rangeOutput = popup.querySelector(".".concat(swalClasses.range, " output"));
        var select = getDirectChildByClass(popup, swalClasses.select);
        /** @type {HTMLInputElement} */ var checkbox = popup.querySelector(".".concat(swalClasses.checkbox, " input"));
        var textarea = getDirectChildByClass(popup, swalClasses.textarea);
        input.oninput = resetValidationMessage$1;
        file.onchange = resetValidationMessage$1;
        select.onchange = resetValidationMessage$1;
        checkbox.onchange = resetValidationMessage$1;
        textarea.oninput = resetValidationMessage$1;
        range.oninput = function() {
            resetValidationMessage$1();
            rangeOutput.value = range.value;
        };
        range.onchange = function() {
            resetValidationMessage$1();
            rangeOutput.value = range.value;
        };
    };
    /**
   * @param {string | HTMLElement} target
   * @returns {HTMLElement}
   */ var getTarget = function getTarget(target) {
        return typeof target === "string" ? document.querySelector(target) : target;
    };
    /**
   * @param {SweetAlertOptions} params
   */ var setupAccessibility = function setupAccessibility(params) {
        var popup = getPopup();
        popup.setAttribute("role", params.toast ? "alert" : "dialog");
        popup.setAttribute("aria-live", params.toast ? "polite" : "assertive");
        if (!params.toast) popup.setAttribute("aria-modal", "true");
    };
    /**
   * @param {HTMLElement} targetElement
   */ var setupRTL = function setupRTL(targetElement) {
        if (window.getComputedStyle(targetElement).direction === "rtl") addClass(getContainer(), swalClasses.rtl);
    };
    /**
   * Add modal + backdrop + no-war message for Russians to DOM
   *
   * @param {SweetAlertOptions} params
   */ var init = function init(params) {
        // Clean up the old popup container if it exists
        var oldContainerExisted = resetOldContainer();
        if (isNodeEnv()) {
            error("SweetAlert2 requires document to initialize");
            return;
        }
        var container = document.createElement("div");
        container.className = swalClasses.container;
        if (oldContainerExisted) addClass(container, swalClasses["no-transition"]);
        setInnerHtml(container, sweetHTML);
        var targetElement = getTarget(params.target);
        targetElement.appendChild(container);
        setupAccessibility(params);
        setupRTL(targetElement);
        addInputChangeListeners();
    };
    /**
   * @param {HTMLElement | object | string} param
   * @param {HTMLElement} target
   */ var parseHtmlToContainer = function parseHtmlToContainer(param, target) {
        // DOM element
        if (param instanceof HTMLElement) target.appendChild(param);
        else if (_typeof(param) === "object") handleObject(param, target);
        else if (param) setInnerHtml(target, param);
    };
    /**
   * @param {any} param
   * @param {HTMLElement} target
   */ var handleObject = function handleObject(param, target) {
        // JQuery element(s)
        if (param.jquery) handleJqueryElem(target, param);
        else setInnerHtml(target, param.toString());
    };
    /**
   * @param {HTMLElement} target
   * @param {any} elem
   */ var handleJqueryElem = function handleJqueryElem(target, elem) {
        target.textContent = "";
        if (0 in elem) for(var i = 0; (i in elem); i++)target.appendChild(elem[i].cloneNode(true));
        else target.appendChild(elem.cloneNode(true));
    };
    /**
   * @returns {'webkitAnimationEnd' | 'animationend' | false}
   */ var animationEndEvent = function() {
        // Prevent run in Node env
        if (isNodeEnv()) return false;
        var testEl = document.createElement("div");
        // Chrome, Safari and Opera
        if (typeof testEl.style.webkitAnimation !== "undefined") return "webkitAnimationEnd";
        // Standard syntax
        if (typeof testEl.style.animation !== "undefined") return "animationend";
        return false;
    }();
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderActions = function renderActions(instance, params) {
        var actions = getActions();
        var loader = getLoader();
        if (!actions || !loader) return;
        // Actions (buttons) wrapper
        if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) hide(actions);
        else show(actions);
        // Custom class
        applyCustomClass(actions, params, "actions");
        // Render all the buttons
        renderButtons(actions, loader, params);
        // Loader
        setInnerHtml(loader, params.loaderHtml || "");
        applyCustomClass(loader, params, "loader");
    };
    /**
   * @param {HTMLElement} actions
   * @param {HTMLElement} loader
   * @param {SweetAlertOptions} params
   */ function renderButtons(actions, loader, params) {
        var confirmButton = getConfirmButton();
        var denyButton = getDenyButton();
        var cancelButton = getCancelButton();
        if (!confirmButton || !denyButton || !cancelButton) return;
        // Render buttons
        renderButton(confirmButton, "confirm", params);
        renderButton(denyButton, "deny", params);
        renderButton(cancelButton, "cancel", params);
        handleButtonsStyling(confirmButton, denyButton, cancelButton, params);
        if (params.reverseButtons) {
            if (params.toast) {
                actions.insertBefore(cancelButton, confirmButton);
                actions.insertBefore(denyButton, confirmButton);
            } else {
                actions.insertBefore(cancelButton, loader);
                actions.insertBefore(denyButton, loader);
                actions.insertBefore(confirmButton, loader);
            }
        }
    }
    /**
   * @param {HTMLElement} confirmButton
   * @param {HTMLElement} denyButton
   * @param {HTMLElement} cancelButton
   * @param {SweetAlertOptions} params
   */ function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {
        if (!params.buttonsStyling) {
            removeClass([
                confirmButton,
                denyButton,
                cancelButton
            ], swalClasses.styled);
            return;
        }
        addClass([
            confirmButton,
            denyButton,
            cancelButton
        ], swalClasses.styled);
        // Buttons background colors
        if (params.confirmButtonColor) {
            confirmButton.style.backgroundColor = params.confirmButtonColor;
            addClass(confirmButton, swalClasses["default-outline"]);
        }
        if (params.denyButtonColor) {
            denyButton.style.backgroundColor = params.denyButtonColor;
            addClass(denyButton, swalClasses["default-outline"]);
        }
        if (params.cancelButtonColor) {
            cancelButton.style.backgroundColor = params.cancelButtonColor;
            addClass(cancelButton, swalClasses["default-outline"]);
        }
    }
    /**
   * @param {HTMLElement} button
   * @param {'confirm' | 'deny' | 'cancel'} buttonType
   * @param {SweetAlertOptions} params
   */ function renderButton(button, buttonType, params) {
        var buttonName = /** @type {'Confirm' | 'Deny' | 'Cancel'} */ capitalizeFirstLetter(buttonType);
        toggle(button, params["show".concat(buttonName, "Button")], "inline-block");
        setInnerHtml(button, params["".concat(buttonType, "ButtonText")] || ""); // Set caption text
        button.setAttribute("aria-label", params["".concat(buttonType, "ButtonAriaLabel")] || ""); // ARIA label
        // Add buttons custom classes
        button.className = swalClasses[buttonType];
        applyCustomClass(button, params, "".concat(buttonType, "Button"));
    }
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderCloseButton = function renderCloseButton(instance, params) {
        var closeButton = getCloseButton();
        if (!closeButton) return;
        setInnerHtml(closeButton, params.closeButtonHtml || "");
        // Custom class
        applyCustomClass(closeButton, params, "closeButton");
        toggle(closeButton, params.showCloseButton);
        closeButton.setAttribute("aria-label", params.closeButtonAriaLabel || "");
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderContainer = function renderContainer(instance, params) {
        var container = getContainer();
        if (!container) return;
        handleBackdropParam(container, params.backdrop);
        handlePositionParam(container, params.position);
        handleGrowParam(container, params.grow);
        // Custom class
        applyCustomClass(container, params, "container");
    };
    /**
   * @param {HTMLElement} container
   * @param {SweetAlertOptions['backdrop']} backdrop
   */ function handleBackdropParam(container, backdrop) {
        if (typeof backdrop === "string") container.style.background = backdrop;
        else if (!backdrop) addClass([
            document.documentElement,
            document.body
        ], swalClasses["no-backdrop"]);
    }
    /**
   * @param {HTMLElement} container
   * @param {SweetAlertOptions['position']} position
   */ function handlePositionParam(container, position) {
        if (!position) return;
        if (position in swalClasses) addClass(container, swalClasses[position]);
        else {
            warn('The "position" parameter is not valid, defaulting to "center"');
            addClass(container, swalClasses.center);
        }
    }
    /**
   * @param {HTMLElement} container
   * @param {SweetAlertOptions['grow']} grow
   */ function handleGrowParam(container, grow) {
        if (!grow) return;
        addClass(container, swalClasses["grow-".concat(grow)]);
    }
    /**
   * This module contains `WeakMap`s for each effectively-"private  property" that a `Swal` has.
   * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
   * This is the approach that Babel will probably take to implement private methods/fields
   *   https://github.com/tc39/proposal-private-methods
   *   https://github.com/babel/babel/pull/7555
   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
   *   then we can use that language feature.
   */ var privateProps = {
        innerParams: new WeakMap(),
        domCache: new WeakMap()
    };
    /** @type {InputClass[]} */ var inputClasses = [
        "input",
        "file",
        "range",
        "select",
        "radio",
        "checkbox",
        "textarea"
    ];
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderInput = function renderInput(instance, params) {
        var popup = getPopup();
        if (!popup) return;
        var innerParams = privateProps.innerParams.get(instance);
        var rerender = !innerParams || params.input !== innerParams.input;
        inputClasses.forEach(function(inputClass) {
            var inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]);
            if (!inputContainer) return;
            // set attributes
            setAttributes(inputClass, params.inputAttributes);
            // set class
            inputContainer.className = swalClasses[inputClass];
            if (rerender) hide(inputContainer);
        });
        if (params.input) {
            if (rerender) showInput(params);
            // set custom class
            setCustomClass(params);
        }
    };
    /**
   * @param {SweetAlertOptions} params
   */ var showInput = function showInput(params) {
        if (!params.input) return;
        if (!renderInputType[params.input]) {
            error("Unexpected type of input! Expected ".concat(Object.keys(renderInputType).join(" | "), ', got "').concat(params.input, '"'));
            return;
        }
        var inputContainer = getInputContainer(params.input);
        var input = renderInputType[params.input](inputContainer, params);
        show(inputContainer);
        // input autofocus
        if (params.inputAutoFocus) setTimeout(function() {
            focusInput(input);
        });
    };
    /**
   * @param {HTMLInputElement} input
   */ var removeAttributes = function removeAttributes(input) {
        for(var i = 0; i < input.attributes.length; i++){
            var attrName = input.attributes[i].name;
            if (![
                "id",
                "type",
                "value",
                "style"
            ].includes(attrName)) input.removeAttribute(attrName);
        }
    };
    /**
   * @param {InputClass} inputClass
   * @param {SweetAlertOptions['inputAttributes']} inputAttributes
   */ var setAttributes = function setAttributes(inputClass, inputAttributes) {
        var input = getInput$1(getPopup(), inputClass);
        if (!input) return;
        removeAttributes(input);
        for(var attr in inputAttributes)input.setAttribute(attr, inputAttributes[attr]);
    };
    /**
   * @param {SweetAlertOptions} params
   */ var setCustomClass = function setCustomClass(params) {
        var inputContainer = getInputContainer(params.input);
        if (_typeof(params.customClass) === "object") addClass(inputContainer, params.customClass.input);
    };
    /**
   * @param {HTMLInputElement | HTMLTextAreaElement} input
   * @param {SweetAlertOptions} params
   */ var setInputPlaceholder = function setInputPlaceholder(input, params) {
        if (!input.placeholder || params.inputPlaceholder) input.placeholder = params.inputPlaceholder;
    };
    /**
   * @param {Input} input
   * @param {Input} prependTo
   * @param {SweetAlertOptions} params
   */ var setInputLabel = function setInputLabel(input, prependTo, params) {
        if (params.inputLabel) {
            var label = document.createElement("label");
            var labelClass = swalClasses["input-label"];
            label.setAttribute("for", input.id);
            label.className = labelClass;
            if (_typeof(params.customClass) === "object") addClass(label, params.customClass.inputLabel);
            label.innerText = params.inputLabel;
            prependTo.insertAdjacentElement("beforebegin", label);
        }
    };
    /**
   * @param {SweetAlertOptions['input']} inputType
   * @returns {HTMLElement}
   */ var getInputContainer = function getInputContainer(inputType) {
        return getDirectChildByClass(getPopup(), swalClasses[inputType] || swalClasses.input);
    };
    /**
   * @param {HTMLInputElement | HTMLOutputElement | HTMLTextAreaElement} input
   * @param {SweetAlertOptions['inputValue']} inputValue
   */ var checkAndSetInputValue = function checkAndSetInputValue(input, inputValue) {
        if ([
            "string",
            "number"
        ].includes(_typeof(inputValue))) input.value = "".concat(inputValue);
        else if (!isPromise(inputValue)) warn('Unexpected type of inputValue! Expected "string", "number" or "Promise", got "'.concat(_typeof(inputValue), '"'));
    };
    /** @type {Record<SweetAlertInput, (input: Input | HTMLElement, params: SweetAlertOptions) => Input>} */ var renderInputType = {};
    /**
   * @param {HTMLInputElement} input
   * @param {SweetAlertOptions} params
   * @returns {HTMLInputElement}
   */ renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = renderInputType.search = renderInputType.date = renderInputType["datetime-local"] = renderInputType.time = renderInputType.week = renderInputType.month = function(input, params) {
        checkAndSetInputValue(input, params.inputValue);
        setInputLabel(input, input, params);
        setInputPlaceholder(input, params);
        input.type = params.input;
        return input;
    };
    /**
   * @param {HTMLInputElement} input
   * @param {SweetAlertOptions} params
   * @returns {HTMLInputElement}
   */ renderInputType.file = function(input, params) {
        setInputLabel(input, input, params);
        setInputPlaceholder(input, params);
        return input;
    };
    /**
   * @param {HTMLInputElement} range
   * @param {SweetAlertOptions} params
   * @returns {HTMLInputElement}
   */ renderInputType.range = function(range, params) {
        var rangeInput = range.querySelector("input");
        var rangeOutput = range.querySelector("output");
        checkAndSetInputValue(rangeInput, params.inputValue);
        rangeInput.type = params.input;
        checkAndSetInputValue(rangeOutput, params.inputValue);
        setInputLabel(rangeInput, range, params);
        return range;
    };
    /**
   * @param {HTMLSelectElement} select
   * @param {SweetAlertOptions} params
   * @returns {HTMLSelectElement}
   */ renderInputType.select = function(select, params) {
        select.textContent = "";
        if (params.inputPlaceholder) {
            var placeholder = document.createElement("option");
            setInnerHtml(placeholder, params.inputPlaceholder);
            placeholder.value = "";
            placeholder.disabled = true;
            placeholder.selected = true;
            select.appendChild(placeholder);
        }
        setInputLabel(select, select, params);
        return select;
    };
    /**
   * @param {HTMLInputElement} radio
   * @returns {HTMLInputElement}
   */ renderInputType.radio = function(radio) {
        radio.textContent = "";
        return radio;
    };
    /**
   * @param {HTMLLabelElement} checkboxContainer
   * @param {SweetAlertOptions} params
   * @returns {HTMLInputElement}
   */ renderInputType.checkbox = function(checkboxContainer, params) {
        var checkbox = getInput$1(getPopup(), "checkbox");
        checkbox.value = "1";
        checkbox.checked = Boolean(params.inputValue);
        var label = checkboxContainer.querySelector("span");
        setInnerHtml(label, params.inputPlaceholder);
        return checkbox;
    };
    /**
   * @param {HTMLTextAreaElement} textarea
   * @param {SweetAlertOptions} params
   * @returns {HTMLTextAreaElement}
   */ renderInputType.textarea = function(textarea, params) {
        checkAndSetInputValue(textarea, params.inputValue);
        setInputPlaceholder(textarea, params);
        setInputLabel(textarea, textarea, params);
        /**
     * @param {HTMLElement} el
     * @returns {number}
     */ var getMargin = function getMargin(el) {
            return parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);
        };
        // https://github.com/sweetalert2/sweetalert2/issues/2291
        setTimeout(function() {
            // https://github.com/sweetalert2/sweetalert2/issues/1699
            if ("MutationObserver" in window) {
                var initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
                var textareaResizeHandler = function textareaResizeHandler() {
                    // check if texarea is still in document (i.e. popup wasn't closed in the meantime)
                    if (!document.body.contains(textarea)) return;
                    var textareaWidth = textarea.offsetWidth + getMargin(textarea);
                    if (textareaWidth > initialPopupWidth) getPopup().style.width = "".concat(textareaWidth, "px");
                    else applyNumericalStyle(getPopup(), "width", params.width);
                };
                new MutationObserver(textareaResizeHandler).observe(textarea, {
                    attributes: true,
                    attributeFilter: [
                        "style"
                    ]
                });
            }
        });
        return textarea;
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderContent = function renderContent(instance, params) {
        var htmlContainer = getHtmlContainer();
        if (!htmlContainer) return;
        showWhenInnerHtmlPresent(htmlContainer);
        applyCustomClass(htmlContainer, params, "htmlContainer");
        // Content as HTML
        if (params.html) {
            parseHtmlToContainer(params.html, htmlContainer);
            show(htmlContainer, "block");
        } else if (params.text) {
            htmlContainer.textContent = params.text;
            show(htmlContainer, "block");
        } else hide(htmlContainer);
        renderInput(instance, params);
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderFooter = function renderFooter(instance, params) {
        var footer = getFooter();
        if (!footer) return;
        showWhenInnerHtmlPresent(footer);
        toggle(footer, params.footer, "block");
        if (params.footer) parseHtmlToContainer(params.footer, footer);
        // Custom class
        applyCustomClass(footer, params, "footer");
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderIcon = function renderIcon(instance, params) {
        var innerParams = privateProps.innerParams.get(instance);
        var icon = getIcon();
        if (!icon) return;
        // if the given icon already rendered, apply the styling without re-rendering the icon
        if (innerParams && params.icon === innerParams.icon) {
            // Custom or default content
            setContent(icon, params);
            applyStyles(icon, params);
            return;
        }
        if (!params.icon && !params.iconHtml) {
            hide(icon);
            return;
        }
        if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {
            error('Unknown icon! Expected "success", "error", "warning", "info" or "question", got "'.concat(params.icon, '"'));
            hide(icon);
            return;
        }
        show(icon);
        // Custom or default content
        setContent(icon, params);
        applyStyles(icon, params);
        // Animate icon
        addClass(icon, params.showClass && params.showClass.icon);
    };
    /**
   * @param {HTMLElement} icon
   * @param {SweetAlertOptions} params
   */ var applyStyles = function applyStyles(icon, params) {
        for(var _i = 0, _Object$entries = Object.entries(iconTypes); _i < _Object$entries.length; _i++){
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), iconType = _Object$entries$_i[0], iconClassName = _Object$entries$_i[1];
            if (params.icon !== iconType) removeClass(icon, iconClassName);
        }
        addClass(icon, params.icon && iconTypes[params.icon]);
        // Icon color
        setColor(icon, params);
        // Success icon background color
        adjustSuccessIconBackgroundColor();
        // Custom class
        applyCustomClass(icon, params, "icon");
    };
    // Adjust success icon background color to match the popup background color
    var adjustSuccessIconBackgroundColor = function adjustSuccessIconBackgroundColor() {
        var popup = getPopup();
        if (!popup) return;
        var popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue("background-color");
        /** @type {NodeListOf<HTMLElement>} */ var successIconParts = popup.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");
        for(var i = 0; i < successIconParts.length; i++)successIconParts[i].style.backgroundColor = popupBackgroundColor;
    };
    var successIconHtml = '\n  <div class="swal2-success-circular-line-left"></div>\n  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>\n  <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>\n  <div class="swal2-success-circular-line-right"></div>\n';
    var errorIconHtml = '\n  <span class="swal2-x-mark">\n    <span class="swal2-x-mark-line-left"></span>\n    <span class="swal2-x-mark-line-right"></span>\n  </span>\n';
    /**
   * @param {HTMLElement} icon
   * @param {SweetAlertOptions} params
   */ var setContent = function setContent(icon, params) {
        if (!params.icon && !params.iconHtml) return;
        var oldContent = icon.innerHTML;
        var newContent = "";
        if (params.iconHtml) newContent = iconContent(params.iconHtml);
        else if (params.icon === "success") {
            newContent = successIconHtml;
            oldContent = oldContent.replace(/ style=".*?"/g, ""); // undo adjustSuccessIconBackgroundColor()
        } else if (params.icon === "error") newContent = errorIconHtml;
        else if (params.icon) {
            var defaultIconHtml = {
                question: "?",
                warning: "!",
                info: "i"
            };
            newContent = iconContent(defaultIconHtml[params.icon]);
        }
        if (oldContent.trim() !== newContent.trim()) setInnerHtml(icon, newContent);
    };
    /**
   * @param {HTMLElement} icon
   * @param {SweetAlertOptions} params
   */ var setColor = function setColor(icon, params) {
        if (!params.iconColor) return;
        icon.style.color = params.iconColor;
        icon.style.borderColor = params.iconColor;
        for(var _i2 = 0, _arr = [
            ".swal2-success-line-tip",
            ".swal2-success-line-long",
            ".swal2-x-mark-line-left",
            ".swal2-x-mark-line-right"
        ]; _i2 < _arr.length; _i2++){
            var sel = _arr[_i2];
            setStyle(icon, sel, "backgroundColor", params.iconColor);
        }
        setStyle(icon, ".swal2-success-ring", "borderColor", params.iconColor);
    };
    /**
   * @param {string} content
   * @returns {string}
   */ var iconContent = function iconContent(content) {
        return '<div class="'.concat(swalClasses["icon-content"], '">').concat(content, "</div>");
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderImage = function renderImage(instance, params) {
        var image = getImage();
        if (!image) return;
        if (!params.imageUrl) {
            hide(image);
            return;
        }
        show(image, "");
        // Src, alt
        image.setAttribute("src", params.imageUrl);
        image.setAttribute("alt", params.imageAlt || "");
        // Width, height
        applyNumericalStyle(image, "width", params.imageWidth);
        applyNumericalStyle(image, "height", params.imageHeight);
        // Class
        image.className = swalClasses.image;
        applyCustomClass(image, params, "image");
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderPopup = function renderPopup(instance, params) {
        var container = getContainer();
        var popup = getPopup();
        if (!container || !popup) return;
        // Width
        // https://github.com/sweetalert2/sweetalert2/issues/2170
        if (params.toast) {
            applyNumericalStyle(container, "width", params.width);
            popup.style.width = "100%";
            var loader = getLoader();
            loader && popup.insertBefore(loader, getIcon());
        } else applyNumericalStyle(popup, "width", params.width);
        // Padding
        applyNumericalStyle(popup, "padding", params.padding);
        // Color
        if (params.color) popup.style.color = params.color;
        // Background
        if (params.background) popup.style.background = params.background;
        hide(getValidationMessage());
        // Classes
        addClasses$1(popup, params);
    };
    /**
   * @param {HTMLElement} popup
   * @param {SweetAlertOptions} params
   */ var addClasses$1 = function addClasses(popup, params) {
        var showClass = params.showClass || {};
        // Default Class + showClass when updating Swal.update({})
        popup.className = "".concat(swalClasses.popup, " ").concat(isVisible$1(popup) ? showClass.popup : "");
        if (params.toast) {
            addClass([
                document.documentElement,
                document.body
            ], swalClasses["toast-shown"]);
            addClass(popup, swalClasses.toast);
        } else addClass(popup, swalClasses.modal);
        // Custom class
        applyCustomClass(popup, params, "popup");
        if (typeof params.customClass === "string") addClass(popup, params.customClass);
        // Icon class (#1842)
        if (params.icon) addClass(popup, swalClasses["icon-".concat(params.icon)]);
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderProgressSteps = function renderProgressSteps(instance, params) {
        var progressStepsContainer = getProgressSteps();
        if (!progressStepsContainer) return;
        var progressSteps = params.progressSteps, currentProgressStep = params.currentProgressStep;
        if (!progressSteps || progressSteps.length === 0 || currentProgressStep === undefined) {
            hide(progressStepsContainer);
            return;
        }
        show(progressStepsContainer);
        progressStepsContainer.textContent = "";
        if (currentProgressStep >= progressSteps.length) warn("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)");
        progressSteps.forEach(function(step, index) {
            var stepEl = createStepElement(step);
            progressStepsContainer.appendChild(stepEl);
            if (index === currentProgressStep) addClass(stepEl, swalClasses["active-progress-step"]);
            if (index !== progressSteps.length - 1) {
                var lineEl = createLineElement(params);
                progressStepsContainer.appendChild(lineEl);
            }
        });
    };
    /**
   * @param {string} step
   * @returns {HTMLLIElement}
   */ var createStepElement = function createStepElement(step) {
        var stepEl = document.createElement("li");
        addClass(stepEl, swalClasses["progress-step"]);
        setInnerHtml(stepEl, step);
        return stepEl;
    };
    /**
   * @param {SweetAlertOptions} params
   * @returns {HTMLLIElement}
   */ var createLineElement = function createLineElement(params) {
        var lineEl = document.createElement("li");
        addClass(lineEl, swalClasses["progress-step-line"]);
        if (params.progressStepsDistance) applyNumericalStyle(lineEl, "width", params.progressStepsDistance);
        return lineEl;
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var renderTitle = function renderTitle(instance, params) {
        var title = getTitle();
        if (!title) return;
        showWhenInnerHtmlPresent(title);
        toggle(title, params.title || params.titleText, "block");
        if (params.title) parseHtmlToContainer(params.title, title);
        if (params.titleText) title.innerText = params.titleText;
        // Custom class
        applyCustomClass(title, params, "title");
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var render = function render(instance, params) {
        renderPopup(instance, params);
        renderContainer(instance, params);
        renderProgressSteps(instance, params);
        renderIcon(instance, params);
        renderImage(instance, params);
        renderTitle(instance, params);
        renderCloseButton(instance, params);
        renderContent(instance, params);
        renderActions(instance, params);
        renderFooter(instance, params);
        var popup = getPopup();
        if (typeof params.didRender === "function" && popup) params.didRender(popup);
    };
    /*
   * Global function to determine if SweetAlert2 popup is shown
   */ var isVisible = function isVisible() {
        return isVisible$1(getPopup());
    };
    /*
   * Global function to click 'Confirm' button
   */ var clickConfirm = function clickConfirm() {
        var _dom$getConfirmButton;
        return (_dom$getConfirmButton = getConfirmButton()) === null || _dom$getConfirmButton === void 0 ? void 0 : _dom$getConfirmButton.click();
    };
    /*
   * Global function to click 'Deny' button
   */ var clickDeny = function clickDeny() {
        var _dom$getDenyButton;
        return (_dom$getDenyButton = getDenyButton()) === null || _dom$getDenyButton === void 0 ? void 0 : _dom$getDenyButton.click();
    };
    /*
   * Global function to click 'Cancel' button
   */ var clickCancel = function clickCancel() {
        var _dom$getCancelButton;
        return (_dom$getCancelButton = getCancelButton()) === null || _dom$getCancelButton === void 0 ? void 0 : _dom$getCancelButton.click();
    };
    /** @typedef {'cancel' | 'backdrop' | 'close' | 'esc' | 'timer'} DismissReason */ /** @type {Record<DismissReason, DismissReason>} */ var DismissReason = Object.freeze({
        cancel: "cancel",
        backdrop: "backdrop",
        close: "close",
        esc: "esc",
        timer: "timer"
    });
    /**
   * @param {GlobalState} globalState
   */ var removeKeydownHandler = function removeKeydownHandler(globalState) {
        if (globalState.keydownTarget && globalState.keydownHandlerAdded) {
            globalState.keydownTarget.removeEventListener("keydown", globalState.keydownHandler, {
                capture: globalState.keydownListenerCapture
            });
            globalState.keydownHandlerAdded = false;
        }
    };
    /**
   * @param {GlobalState} globalState
   * @param {SweetAlertOptions} innerParams
   * @param {*} dismissWith
   */ var addKeydownHandler = function addKeydownHandler(globalState, innerParams, dismissWith) {
        removeKeydownHandler(globalState);
        if (!innerParams.toast) {
            globalState.keydownHandler = function(e) {
                return keydownHandler(innerParams, e, dismissWith);
            };
            globalState.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
            globalState.keydownListenerCapture = innerParams.keydownListenerCapture;
            globalState.keydownTarget.addEventListener("keydown", globalState.keydownHandler, {
                capture: globalState.keydownListenerCapture
            });
            globalState.keydownHandlerAdded = true;
        }
    };
    /**
   * @param {number} index
   * @param {number} increment
   */ var setFocus = function setFocus(index, increment) {
        var _dom$getPopup;
        var focusableElements = getFocusableElements();
        // search for visible elements and select the next possible match
        if (focusableElements.length) {
            index = index + increment;
            // rollover to first item
            if (index === focusableElements.length) index = 0;
            else if (index === -1) index = focusableElements.length - 1;
            focusableElements[index].focus();
            return;
        }
        // no visible focusable elements, focus the popup
        (_dom$getPopup = getPopup()) === null || _dom$getPopup === void 0 || _dom$getPopup.focus();
    };
    var arrowKeysNextButton = [
        "ArrowRight",
        "ArrowDown"
    ];
    var arrowKeysPreviousButton = [
        "ArrowLeft",
        "ArrowUp"
    ];
    /**
   * @param {SweetAlertOptions} innerParams
   * @param {KeyboardEvent} event
   * @param {Function} dismissWith
   */ var keydownHandler = function keydownHandler(innerParams, event, dismissWith) {
        if (!innerParams) return; // This instance has already been destroyed
        // Ignore keydown during IME composition
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event#ignoring_keydown_during_ime_composition
        // https://github.com/sweetalert2/sweetalert2/issues/720
        // https://github.com/sweetalert2/sweetalert2/issues/2406
        if (event.isComposing || event.keyCode === 229) return;
        if (innerParams.stopKeydownPropagation) event.stopPropagation();
        // ENTER
        if (event.key === "Enter") handleEnter(event, innerParams);
        else if (event.key === "Tab") handleTab(event);
        else if ([].concat(arrowKeysNextButton, arrowKeysPreviousButton).includes(event.key)) handleArrows(event.key);
        else if (event.key === "Escape") handleEsc(event, innerParams, dismissWith);
    };
    /**
   * @param {KeyboardEvent} event
   * @param {SweetAlertOptions} innerParams
   */ var handleEnter = function handleEnter(event, innerParams) {
        // https://github.com/sweetalert2/sweetalert2/issues/2386
        if (!callIfFunction(innerParams.allowEnterKey)) return;
        var input = getInput$1(getPopup(), innerParams.input);
        if (event.target && input && event.target instanceof HTMLElement && event.target.outerHTML === input.outerHTML) {
            if ([
                "textarea",
                "file"
            ].includes(innerParams.input)) return; // do not submit
            clickConfirm();
            event.preventDefault();
        }
    };
    /**
   * @param {KeyboardEvent} event
   */ var handleTab = function handleTab(event) {
        var targetElement = event.target;
        var focusableElements = getFocusableElements();
        var btnIndex = -1;
        for(var i = 0; i < focusableElements.length; i++)if (targetElement === focusableElements[i]) {
            btnIndex = i;
            break;
        }
        // Cycle to the next button
        if (!event.shiftKey) setFocus(btnIndex, 1);
        else setFocus(btnIndex, -1);
        event.stopPropagation();
        event.preventDefault();
    };
    /**
   * @param {string} key
   */ var handleArrows = function handleArrows(key) {
        var actions = getActions();
        var confirmButton = getConfirmButton();
        var denyButton = getDenyButton();
        var cancelButton = getCancelButton();
        if (!actions || !confirmButton || !denyButton || !cancelButton) return;
        /** @type HTMLElement[] */ var buttons = [
            confirmButton,
            denyButton,
            cancelButton
        ];
        if (document.activeElement instanceof HTMLElement && !buttons.includes(document.activeElement)) return;
        var sibling = arrowKeysNextButton.includes(key) ? "nextElementSibling" : "previousElementSibling";
        var buttonToFocus = document.activeElement;
        if (!buttonToFocus) return;
        for(var i = 0; i < actions.children.length; i++){
            buttonToFocus = buttonToFocus[sibling];
            if (!buttonToFocus) return;
            if (buttonToFocus instanceof HTMLButtonElement && isVisible$1(buttonToFocus)) break;
        }
        if (buttonToFocus instanceof HTMLButtonElement) buttonToFocus.focus();
    };
    /**
   * @param {KeyboardEvent} event
   * @param {SweetAlertOptions} innerParams
   * @param {Function} dismissWith
   */ var handleEsc = function handleEsc(event, innerParams, dismissWith) {
        if (callIfFunction(innerParams.allowEscapeKey)) {
            event.preventDefault();
            dismissWith(DismissReason.esc);
        }
    };
    /**
   * This module contains `WeakMap`s for each effectively-"private  property" that a `Swal` has.
   * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
   * This is the approach that Babel will probably take to implement private methods/fields
   *   https://github.com/tc39/proposal-private-methods
   *   https://github.com/babel/babel/pull/7555
   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
   *   then we can use that language feature.
   */ var privateMethods = {
        swalPromiseResolve: new WeakMap(),
        swalPromiseReject: new WeakMap()
    };
    // From https://developer.paciellogroup.com/blog/2018/06/the-current-state-of-modal-dialog-accessibility/
    // Adding aria-hidden="true" to elements outside of the active modal dialog ensures that
    // elements not within the active modal dialog will not be surfaced if a user opens a screen
    // readers list of elements (headings, form controls, landmarks, etc.) in the document.
    var setAriaHidden = function setAriaHidden() {
        var bodyChildren = Array.from(document.body.children);
        bodyChildren.forEach(function(el) {
            if (el === getContainer() || el.contains(getContainer())) return;
            if (el.hasAttribute("aria-hidden")) el.setAttribute("data-previous-aria-hidden", el.getAttribute("aria-hidden") || "");
            el.setAttribute("aria-hidden", "true");
        });
    };
    var unsetAriaHidden = function unsetAriaHidden() {
        var bodyChildren = Array.from(document.body.children);
        bodyChildren.forEach(function(el) {
            if (el.hasAttribute("data-previous-aria-hidden")) {
                el.setAttribute("aria-hidden", el.getAttribute("data-previous-aria-hidden") || "");
                el.removeAttribute("data-previous-aria-hidden");
            } else el.removeAttribute("aria-hidden");
        });
    };
    // @ts-ignore
    var isSafariOrIOS = typeof window !== "undefined" && !!window.GestureEvent; // true for Safari desktop + all iOS browsers https://stackoverflow.com/a/70585394
    /**
   * Fix iOS scrolling
   * http://stackoverflow.com/q/39626302
   */ var iOSfix = function iOSfix() {
        if (isSafariOrIOS && !hasClass(document.body, swalClasses.iosfix)) {
            var offset = document.body.scrollTop;
            document.body.style.top = "".concat(offset * -1, "px");
            addClass(document.body, swalClasses.iosfix);
            lockBodyScroll();
        }
    };
    /**
   * https://github.com/sweetalert2/sweetalert2/issues/1246
   */ var lockBodyScroll = function lockBodyScroll() {
        var container = getContainer();
        if (!container) return;
        /** @type {boolean} */ var preventTouchMove;
        /**
     * @param {TouchEvent} event
     */ container.ontouchstart = function(event) {
            preventTouchMove = shouldPreventTouchMove(event);
        };
        /**
     * @param {TouchEvent} event
     */ container.ontouchmove = function(event) {
            if (preventTouchMove) {
                event.preventDefault();
                event.stopPropagation();
            }
        };
    };
    /**
   * @param {TouchEvent} event
   * @returns {boolean}
   */ var shouldPreventTouchMove = function shouldPreventTouchMove(event) {
        var target = event.target;
        var container = getContainer();
        var htmlContainer = getHtmlContainer();
        if (!container || !htmlContainer) return false;
        if (isStylus(event) || isZoom(event)) return false;
        if (target === container) return true;
        if (!isScrollable(container) && target instanceof HTMLElement && target.tagName !== "INPUT" && // #1603
        target.tagName !== "TEXTAREA" && // #2266
        !(isScrollable(htmlContainer) && // #1944
        htmlContainer.contains(target))) return true;
        return false;
    };
    /**
   * https://github.com/sweetalert2/sweetalert2/issues/1786
   *
   * @param {*} event
   * @returns {boolean}
   */ var isStylus = function isStylus(event) {
        return event.touches && event.touches.length && event.touches[0].touchType === "stylus";
    };
    /**
   * https://github.com/sweetalert2/sweetalert2/issues/1891
   *
   * @param {TouchEvent} event
   * @returns {boolean}
   */ var isZoom = function isZoom(event) {
        return event.touches && event.touches.length > 1;
    };
    var undoIOSfix = function undoIOSfix() {
        if (hasClass(document.body, swalClasses.iosfix)) {
            var offset = parseInt(document.body.style.top, 10);
            removeClass(document.body, swalClasses.iosfix);
            document.body.style.top = "";
            document.body.scrollTop = offset * -1;
        }
    };
    /**
   * Measure scrollbar width for padding body during modal show/hide
   * https://github.com/twbs/bootstrap/blob/master/js/src/modal.js
   *
   * @returns {number}
   */ var measureScrollbar = function measureScrollbar() {
        var scrollDiv = document.createElement("div");
        scrollDiv.className = swalClasses["scrollbar-measure"];
        document.body.appendChild(scrollDiv);
        var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        return scrollbarWidth;
    };
    /**
   * Remember state in cases where opening and handling a modal will fiddle with it.
   * @type {number | null}
   */ var previousBodyPadding = null;
    /**
   * @param {string} initialBodyOverflow
   */ var replaceScrollbarWithPadding = function replaceScrollbarWithPadding(initialBodyOverflow) {
        // for queues, do not do this more than once
        if (previousBodyPadding !== null) return;
        // if the body has overflow
        if (document.body.scrollHeight > window.innerHeight || initialBodyOverflow === "scroll" // https://github.com/sweetalert2/sweetalert2/issues/2663
        ) {
            // add padding so the content doesn't shift after removal of scrollbar
            previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right"));
            document.body.style.paddingRight = "".concat(previousBodyPadding + measureScrollbar(), "px");
        }
    };
    var undoReplaceScrollbarWithPadding = function undoReplaceScrollbarWithPadding() {
        if (previousBodyPadding !== null) {
            document.body.style.paddingRight = "".concat(previousBodyPadding, "px");
            previousBodyPadding = null;
        }
    };
    /**
   * @param {SweetAlert} instance
   * @param {HTMLElement} container
   * @param {boolean} returnFocus
   * @param {Function} didClose
   */ function removePopupAndResetState(instance, container, returnFocus, didClose) {
        if (isToast()) triggerDidCloseAndDispose(instance, didClose);
        else {
            restoreActiveElement(returnFocus).then(function() {
                return triggerDidCloseAndDispose(instance, didClose);
            });
            removeKeydownHandler(globalState);
        }
        // workaround for https://github.com/sweetalert2/sweetalert2/issues/2088
        // for some reason removing the container in Safari will scroll the document to bottom
        if (isSafariOrIOS) {
            container.setAttribute("style", "display:none !important");
            container.removeAttribute("class");
            container.innerHTML = "";
        } else container.remove();
        if (isModal()) {
            undoReplaceScrollbarWithPadding();
            undoIOSfix();
            unsetAriaHidden();
        }
        removeBodyClasses();
    }
    /**
   * Remove SweetAlert2 classes from body
   */ function removeBodyClasses() {
        removeClass([
            document.documentElement,
            document.body
        ], [
            swalClasses.shown,
            swalClasses["height-auto"],
            swalClasses["no-backdrop"],
            swalClasses["toast-shown"]
        ]);
    }
    /**
   * Instance method to close sweetAlert
   *
   * @param {any} resolveValue
   */ function close(resolveValue) {
        resolveValue = prepareResolveValue(resolveValue);
        var swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
        var didClose = triggerClosePopup(this);
        if (this.isAwaitingPromise) // A swal awaiting for a promise (after a click on Confirm or Deny) cannot be dismissed anymore #2335
        {
            if (!resolveValue.isDismissed) {
                handleAwaitingPromise(this);
                swalPromiseResolve(resolveValue);
            }
        } else if (didClose) // Resolve Swal promise
        swalPromiseResolve(resolveValue);
    }
    var triggerClosePopup = function triggerClosePopup(instance) {
        var popup = getPopup();
        if (!popup) return false;
        var innerParams = privateProps.innerParams.get(instance);
        if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) return false;
        removeClass(popup, innerParams.showClass.popup);
        addClass(popup, innerParams.hideClass.popup);
        var backdrop = getContainer();
        removeClass(backdrop, innerParams.showClass.backdrop);
        addClass(backdrop, innerParams.hideClass.backdrop);
        handlePopupAnimation(instance, popup, innerParams);
        return true;
    };
    /**
   * @param {any} error
   */ function rejectPromise(error) {
        var _$rejectPromise = privateMethods.swalPromiseReject.get(this);
        handleAwaitingPromise(this);
        if (_$rejectPromise) // Reject Swal promise
        _$rejectPromise(error);
    }
    /**
   * @param {SweetAlert} instance
   */ var handleAwaitingPromise = function handleAwaitingPromise(instance) {
        if (instance.isAwaitingPromise) {
            delete instance.isAwaitingPromise;
            // The instance might have been previously partly destroyed, we must resume the destroy process in this case #2335
            if (!privateProps.innerParams.get(instance)) instance._destroy();
        }
    };
    /**
   * @param {any} resolveValue
   * @returns {SweetAlertResult}
   */ var prepareResolveValue = function prepareResolveValue(resolveValue) {
        // When user calls Swal.close()
        if (typeof resolveValue === "undefined") return {
            isConfirmed: false,
            isDenied: false,
            isDismissed: true
        };
        return Object.assign({
            isConfirmed: false,
            isDenied: false,
            isDismissed: false
        }, resolveValue);
    };
    /**
   * @param {SweetAlert} instance
   * @param {HTMLElement} popup
   * @param {SweetAlertOptions} innerParams
   */ var handlePopupAnimation = function handlePopupAnimation(instance, popup, innerParams) {
        var container = getContainer();
        // If animation is supported, animate
        var animationIsSupported = animationEndEvent && hasCssAnimation(popup);
        if (typeof innerParams.willClose === "function") innerParams.willClose(popup);
        if (animationIsSupported) animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);
        else // Otherwise, remove immediately
        removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);
    };
    /**
   * @param {SweetAlert} instance
   * @param {HTMLElement} popup
   * @param {HTMLElement} container
   * @param {boolean} returnFocus
   * @param {Function} didClose
   */ var animatePopup = function animatePopup(instance, popup, container, returnFocus, didClose) {
        if (!animationEndEvent) return;
        globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);
        popup.addEventListener(animationEndEvent, function(e) {
            if (e.target === popup) {
                globalState.swalCloseEventFinishedCallback();
                delete globalState.swalCloseEventFinishedCallback;
            }
        });
    };
    /**
   * @param {SweetAlert} instance
   * @param {Function} didClose
   */ var triggerDidCloseAndDispose = function triggerDidCloseAndDispose(instance, didClose) {
        setTimeout(function() {
            if (typeof didClose === "function") didClose.bind(instance.params)();
            // instance might have been destroyed already
            if (instance._destroy) instance._destroy();
        });
    };
    /**
   * Shows loader (spinner), this is useful with AJAX requests.
   * By default the loader be shown instead of the "Confirm" button.
   *
   * @param {HTMLButtonElement | null} [buttonToReplace]
   */ var showLoading = function showLoading(buttonToReplace) {
        var popup = getPopup();
        if (!popup) new Swal(); // eslint-disable-line no-new
        popup = getPopup();
        if (!popup) return;
        var loader = getLoader();
        if (isToast()) hide(getIcon());
        else replaceButton(popup, buttonToReplace);
        show(loader);
        popup.setAttribute("data-loading", "true");
        popup.setAttribute("aria-busy", "true");
        popup.focus();
    };
    /**
   * @param {HTMLElement} popup
   * @param {HTMLButtonElement | null} [buttonToReplace]
   */ var replaceButton = function replaceButton(popup, buttonToReplace) {
        var actions = getActions();
        var loader = getLoader();
        if (!actions || !loader) return;
        if (!buttonToReplace && isVisible$1(getConfirmButton())) buttonToReplace = getConfirmButton();
        show(actions);
        if (buttonToReplace) {
            hide(buttonToReplace);
            loader.setAttribute("data-button-to-replace", buttonToReplace.className);
            actions.insertBefore(loader, buttonToReplace);
        }
        addClass([
            popup,
            actions
        ], swalClasses.loading);
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var handleInputOptionsAndValue = function handleInputOptionsAndValue(instance, params) {
        if (params.input === "select" || params.input === "radio") handleInputOptions(instance, params);
        else if ([
            "text",
            "email",
            "number",
            "tel",
            "textarea"
        ].some(function(i) {
            return i === params.input;
        }) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {
            showLoading(getConfirmButton());
            handleInputValue(instance, params);
        }
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} innerParams
   * @returns {SweetAlertInputValue}
   */ var getInputValue = function getInputValue(instance, innerParams) {
        var input = instance.getInput();
        if (!input) return null;
        switch(innerParams.input){
            case "checkbox":
                return getCheckboxValue(input);
            case "radio":
                return getRadioValue(input);
            case "file":
                return getFileValue(input);
            default:
                return innerParams.inputAutoTrim ? input.value.trim() : input.value;
        }
    };
    /**
   * @param {HTMLInputElement} input
   * @returns {number}
   */ var getCheckboxValue = function getCheckboxValue(input) {
        return input.checked ? 1 : 0;
    };
    /**
   * @param {HTMLInputElement} input
   * @returns {string | null}
   */ var getRadioValue = function getRadioValue(input) {
        return input.checked ? input.value : null;
    };
    /**
   * @param {HTMLInputElement} input
   * @returns {FileList | File | null}
   */ var getFileValue = function getFileValue(input) {
        return input.files && input.files.length ? input.getAttribute("multiple") !== null ? input.files : input.files[0] : null;
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var handleInputOptions = function handleInputOptions(instance, params) {
        var popup = getPopup();
        if (!popup) return;
        /**
     * @param {Record<string, any>} inputOptions
     */ var processInputOptions = function processInputOptions(inputOptions) {
            if (params.input === "select") populateSelectOptions(popup, formatInputOptions(inputOptions), params);
            else if (params.input === "radio") populateRadioOptions(popup, formatInputOptions(inputOptions), params);
        };
        if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {
            showLoading(getConfirmButton());
            asPromise(params.inputOptions).then(function(inputOptions) {
                instance.hideLoading();
                processInputOptions(inputOptions);
            });
        } else if (_typeof(params.inputOptions) === "object") processInputOptions(params.inputOptions);
        else error("Unexpected type of inputOptions! Expected object, Map or Promise, got ".concat(_typeof(params.inputOptions)));
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertOptions} params
   */ var handleInputValue = function handleInputValue(instance, params) {
        var input = instance.getInput();
        if (!input) return;
        hide(input);
        asPromise(params.inputValue).then(function(inputValue) {
            input.value = params.input === "number" ? "".concat(parseFloat(inputValue) || 0) : "".concat(inputValue);
            show(input);
            input.focus();
            instance.hideLoading();
        })["catch"](function(err) {
            error("Error in inputValue promise: ".concat(err));
            input.value = "";
            show(input);
            input.focus();
            instance.hideLoading();
        });
    };
    /**
   * @param {HTMLElement} popup
   * @param {InputOptionFlattened[]} inputOptions
   * @param {SweetAlertOptions} params
   */ function populateSelectOptions(popup, inputOptions, params) {
        var select = getDirectChildByClass(popup, swalClasses.select);
        if (!select) return;
        /**
     * @param {HTMLElement} parent
     * @param {string} optionLabel
     * @param {string} optionValue
     */ var renderOption = function renderOption(parent, optionLabel, optionValue) {
            var option = document.createElement("option");
            option.value = optionValue;
            setInnerHtml(option, optionLabel);
            option.selected = isSelected(optionValue, params.inputValue);
            parent.appendChild(option);
        };
        inputOptions.forEach(function(inputOption) {
            var optionValue = inputOption[0];
            var optionLabel = inputOption[1];
            // <optgroup> spec:
            // https://www.w3.org/TR/html401/interact/forms.html#h-17.6
            // "...all OPTGROUP elements must be specified directly within a SELECT element (i.e., groups may not be nested)..."
            // check whether this is a <optgroup>
            if (Array.isArray(optionLabel)) {
                // if it is an array, then it is an <optgroup>
                var optgroup = document.createElement("optgroup");
                optgroup.label = optionValue;
                optgroup.disabled = false; // not configurable for now
                select.appendChild(optgroup);
                optionLabel.forEach(function(o) {
                    return renderOption(optgroup, o[1], o[0]);
                });
            } else // case of <option>
            renderOption(select, optionLabel, optionValue);
        });
        select.focus();
    }
    /**
   * @param {HTMLElement} popup
   * @param {InputOptionFlattened[]} inputOptions
   * @param {SweetAlertOptions} params
   */ function populateRadioOptions(popup, inputOptions, params) {
        var radio = getDirectChildByClass(popup, swalClasses.radio);
        if (!radio) return;
        inputOptions.forEach(function(inputOption) {
            var radioValue = inputOption[0];
            var radioLabel = inputOption[1];
            var radioInput = document.createElement("input");
            var radioLabelElement = document.createElement("label");
            radioInput.type = "radio";
            radioInput.name = swalClasses.radio;
            radioInput.value = radioValue;
            if (isSelected(radioValue, params.inputValue)) radioInput.checked = true;
            var label = document.createElement("span");
            setInnerHtml(label, radioLabel);
            label.className = swalClasses.label;
            radioLabelElement.appendChild(radioInput);
            radioLabelElement.appendChild(label);
            radio.appendChild(radioLabelElement);
        });
        var radios = radio.querySelectorAll("input");
        if (radios.length) radios[0].focus();
    }
    /**
   * Converts `inputOptions` into an array of `[value, label]`s
   *
   * @param {Record<string, any>} inputOptions
   * @typedef {string[]} InputOptionFlattened
   * @returns {InputOptionFlattened[]}
   */ var formatInputOptions = function formatInputOptions(inputOptions) {
        /** @type {InputOptionFlattened[]} */ var result = [];
        if (inputOptions instanceof Map) inputOptions.forEach(function(value, key) {
            var valueFormatted = value;
            if (_typeof(valueFormatted) === "object") // case of <optgroup>
            valueFormatted = formatInputOptions(valueFormatted);
            result.push([
                key,
                valueFormatted
            ]);
        });
        else Object.keys(inputOptions).forEach(function(key) {
            var valueFormatted = inputOptions[key];
            if (_typeof(valueFormatted) === "object") // case of <optgroup>
            valueFormatted = formatInputOptions(valueFormatted);
            result.push([
                key,
                valueFormatted
            ]);
        });
        return result;
    };
    /**
   * @param {string} optionValue
   * @param {SweetAlertInputValue} inputValue
   * @returns {boolean}
   */ var isSelected = function isSelected(optionValue, inputValue) {
        return !!inputValue && inputValue.toString() === optionValue.toString();
    };
    var _this = undefined;
    /**
   * @param {SweetAlert} instance
   */ var handleConfirmButtonClick = function handleConfirmButtonClick(instance) {
        var innerParams = privateProps.innerParams.get(instance);
        instance.disableButtons();
        if (innerParams.input) handleConfirmOrDenyWithInput(instance, "confirm");
        else confirm(instance, true);
    };
    /**
   * @param {SweetAlert} instance
   */ var handleDenyButtonClick = function handleDenyButtonClick(instance) {
        var innerParams = privateProps.innerParams.get(instance);
        instance.disableButtons();
        if (innerParams.returnInputValueOnDeny) handleConfirmOrDenyWithInput(instance, "deny");
        else deny(instance, false);
    };
    /**
   * @param {SweetAlert} instance
   * @param {Function} dismissWith
   */ var handleCancelButtonClick = function handleCancelButtonClick(instance, dismissWith) {
        instance.disableButtons();
        dismissWith(DismissReason.cancel);
    };
    /**
   * @param {SweetAlert} instance
   * @param {'confirm' | 'deny'} type
   */ var handleConfirmOrDenyWithInput = function handleConfirmOrDenyWithInput(instance, type) {
        var innerParams = privateProps.innerParams.get(instance);
        if (!innerParams.input) {
            error('The "input" parameter is needed to be set when using returnInputValueOn'.concat(capitalizeFirstLetter(type)));
            return;
        }
        var input = instance.getInput();
        var inputValue = getInputValue(instance, innerParams);
        if (innerParams.inputValidator) handleInputValidator(instance, inputValue, type);
        else if (input && !input.checkValidity()) {
            instance.enableButtons();
            instance.showValidationMessage(innerParams.validationMessage);
        } else if (type === "deny") deny(instance, inputValue);
        else confirm(instance, inputValue);
    };
    /**
   * @param {SweetAlert} instance
   * @param {SweetAlertInputValue} inputValue
   * @param {'confirm' | 'deny'} type
   */ var handleInputValidator = function handleInputValidator(instance, inputValue, type) {
        var innerParams = privateProps.innerParams.get(instance);
        instance.disableInput();
        var validationPromise = Promise.resolve().then(function() {
            return asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage));
        });
        validationPromise.then(function(validationMessage) {
            instance.enableButtons();
            instance.enableInput();
            if (validationMessage) instance.showValidationMessage(validationMessage);
            else if (type === "deny") deny(instance, inputValue);
            else confirm(instance, inputValue);
        });
    };
    /**
   * @param {SweetAlert} instance
   * @param {any} value
   */ var deny = function deny(instance, value) {
        var innerParams = privateProps.innerParams.get(instance || _this);
        if (innerParams.showLoaderOnDeny) showLoading(getDenyButton());
        if (innerParams.preDeny) {
            instance.isAwaitingPromise = true; // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preDeny's promise is received
            var preDenyPromise = Promise.resolve().then(function() {
                return asPromise(innerParams.preDeny(value, innerParams.validationMessage));
            });
            preDenyPromise.then(function(preDenyValue) {
                if (preDenyValue === false) {
                    instance.hideLoading();
                    handleAwaitingPromise(instance);
                } else instance.close({
                    isDenied: true,
                    value: typeof preDenyValue === "undefined" ? value : preDenyValue
                });
            })["catch"](function(error) {
                return rejectWith(instance || _this, error);
            });
        } else instance.close({
            isDenied: true,
            value: value
        });
    };
    /**
   * @param {SweetAlert} instance
   * @param {any} value
   */ var succeedWith = function succeedWith(instance, value) {
        instance.close({
            isConfirmed: true,
            value: value
        });
    };
    /**
   *
   * @param {SweetAlert} instance
   * @param {string} error
   */ var rejectWith = function rejectWith(instance, error) {
        instance.rejectPromise(error);
    };
    /**
   *
   * @param {SweetAlert} instance
   * @param {any} value
   */ var confirm = function confirm(instance, value) {
        var innerParams = privateProps.innerParams.get(instance || _this);
        if (innerParams.showLoaderOnConfirm) showLoading();
        if (innerParams.preConfirm) {
            instance.resetValidationMessage();
            instance.isAwaitingPromise = true; // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preConfirm's promise is received
            var preConfirmPromise = Promise.resolve().then(function() {
                return asPromise(innerParams.preConfirm(value, innerParams.validationMessage));
            });
            preConfirmPromise.then(function(preConfirmValue) {
                if (isVisible$1(getValidationMessage()) || preConfirmValue === false) {
                    instance.hideLoading();
                    handleAwaitingPromise(instance);
                } else succeedWith(instance, typeof preConfirmValue === "undefined" ? value : preConfirmValue);
            })["catch"](function(error) {
                return rejectWith(instance || _this, error);
            });
        } else succeedWith(instance, value);
    };
    /**
   * Hides loader and shows back the button which was hidden by .showLoading()
   */ function hideLoading() {
        // do nothing if popup is closed
        var innerParams = privateProps.innerParams.get(this);
        if (!innerParams) return;
        var domCache = privateProps.domCache.get(this);
        hide(domCache.loader);
        if (isToast()) {
            if (innerParams.icon) show(getIcon());
        } else showRelatedButton(domCache);
        removeClass([
            domCache.popup,
            domCache.actions
        ], swalClasses.loading);
        domCache.popup.removeAttribute("aria-busy");
        domCache.popup.removeAttribute("data-loading");
        domCache.confirmButton.disabled = false;
        domCache.denyButton.disabled = false;
        domCache.cancelButton.disabled = false;
    }
    var showRelatedButton = function showRelatedButton(domCache) {
        var buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute("data-button-to-replace"));
        if (buttonToReplace.length) show(buttonToReplace[0], "inline-block");
        else if (allButtonsAreHidden()) hide(domCache.actions);
    };
    /**
   * Gets the input DOM node, this method works with input parameter.
   *
   * @returns {HTMLInputElement | null}
   */ function getInput() {
        var innerParams = privateProps.innerParams.get(this);
        var domCache = privateProps.domCache.get(this);
        if (!domCache) return null;
        return getInput$1(domCache.popup, innerParams.input);
    }
    /**
   * @param {SweetAlert} instance
   * @param {string[]} buttons
   * @param {boolean} disabled
   */ function setButtonsDisabled(instance, buttons, disabled) {
        var domCache = privateProps.domCache.get(instance);
        buttons.forEach(function(button) {
            domCache[button].disabled = disabled;
        });
    }
    /**
   * @param {HTMLInputElement | null} input
   * @param {boolean} disabled
   */ function setInputDisabled(input, disabled) {
        var popup = getPopup();
        if (!popup || !input) return;
        if (input.type === "radio") {
            /** @type {NodeListOf<HTMLInputElement>} */ var radios = popup.querySelectorAll('[name="'.concat(swalClasses.radio, '"]'));
            for(var i = 0; i < radios.length; i++)radios[i].disabled = disabled;
        } else input.disabled = disabled;
    }
    /**
   * Enable all the buttons
   * @this {SweetAlert}
   */ function enableButtons() {
        setButtonsDisabled(this, [
            "confirmButton",
            "denyButton",
            "cancelButton"
        ], false);
    }
    /**
   * Disable all the buttons
   * @this {SweetAlert}
   */ function disableButtons() {
        setButtonsDisabled(this, [
            "confirmButton",
            "denyButton",
            "cancelButton"
        ], true);
    }
    /**
   * Enable the input field
   * @this {SweetAlert}
   */ function enableInput() {
        setInputDisabled(this.getInput(), false);
    }
    /**
   * Disable the input field
   * @this {SweetAlert}
   */ function disableInput() {
        setInputDisabled(this.getInput(), true);
    }
    /**
   * Show block with validation message
   *
   * @param {string} error
   * @this {SweetAlert}
   */ function showValidationMessage(error) {
        var domCache = privateProps.domCache.get(this);
        var params = privateProps.innerParams.get(this);
        setInnerHtml(domCache.validationMessage, error);
        domCache.validationMessage.className = swalClasses["validation-message"];
        if (params.customClass && params.customClass.validationMessage) addClass(domCache.validationMessage, params.customClass.validationMessage);
        show(domCache.validationMessage);
        var input = this.getInput();
        if (input) {
            input.setAttribute("aria-invalid", "true");
            input.setAttribute("aria-describedby", swalClasses["validation-message"]);
            focusInput(input);
            addClass(input, swalClasses.inputerror);
        }
    }
    /**
   * Hide block with validation message
   *
   * @this {SweetAlert}
   */ function resetValidationMessage() {
        var domCache = privateProps.domCache.get(this);
        if (domCache.validationMessage) hide(domCache.validationMessage);
        var input = this.getInput();
        if (input) {
            input.removeAttribute("aria-invalid");
            input.removeAttribute("aria-describedby");
            removeClass(input, swalClasses.inputerror);
        }
    }
    var defaultParams = {
        title: "",
        titleText: "",
        text: "",
        html: "",
        footer: "",
        icon: undefined,
        iconColor: undefined,
        iconHtml: undefined,
        template: undefined,
        toast: false,
        animation: true,
        showClass: {
            popup: "swal2-show",
            backdrop: "swal2-backdrop-show",
            icon: "swal2-icon-show"
        },
        hideClass: {
            popup: "swal2-hide",
            backdrop: "swal2-backdrop-hide",
            icon: "swal2-icon-hide"
        },
        customClass: {},
        target: "body",
        color: undefined,
        backdrop: true,
        heightAuto: true,
        allowOutsideClick: true,
        allowEscapeKey: true,
        allowEnterKey: true,
        stopKeydownPropagation: true,
        keydownListenerCapture: false,
        showConfirmButton: true,
        showDenyButton: false,
        showCancelButton: false,
        preConfirm: undefined,
        preDeny: undefined,
        confirmButtonText: "OK",
        confirmButtonAriaLabel: "",
        confirmButtonColor: undefined,
        denyButtonText: "No",
        denyButtonAriaLabel: "",
        denyButtonColor: undefined,
        cancelButtonText: "Cancel",
        cancelButtonAriaLabel: "",
        cancelButtonColor: undefined,
        buttonsStyling: true,
        reverseButtons: false,
        focusConfirm: true,
        focusDeny: false,
        focusCancel: false,
        returnFocus: true,
        showCloseButton: false,
        closeButtonHtml: "&times;",
        closeButtonAriaLabel: "Close this dialog",
        loaderHtml: "",
        showLoaderOnConfirm: false,
        showLoaderOnDeny: false,
        imageUrl: undefined,
        imageWidth: undefined,
        imageHeight: undefined,
        imageAlt: "",
        timer: undefined,
        timerProgressBar: false,
        width: undefined,
        padding: undefined,
        background: undefined,
        input: undefined,
        inputPlaceholder: "",
        inputLabel: "",
        inputValue: "",
        inputOptions: {},
        inputAutoFocus: true,
        inputAutoTrim: true,
        inputAttributes: {},
        inputValidator: undefined,
        returnInputValueOnDeny: false,
        validationMessage: undefined,
        grow: false,
        position: "center",
        progressSteps: [],
        currentProgressStep: undefined,
        progressStepsDistance: undefined,
        willOpen: undefined,
        didOpen: undefined,
        didRender: undefined,
        willClose: undefined,
        didClose: undefined,
        didDestroy: undefined,
        scrollbarPadding: true
    };
    var updatableParams = [
        "allowEscapeKey",
        "allowOutsideClick",
        "background",
        "buttonsStyling",
        "cancelButtonAriaLabel",
        "cancelButtonColor",
        "cancelButtonText",
        "closeButtonAriaLabel",
        "closeButtonHtml",
        "color",
        "confirmButtonAriaLabel",
        "confirmButtonColor",
        "confirmButtonText",
        "currentProgressStep",
        "customClass",
        "denyButtonAriaLabel",
        "denyButtonColor",
        "denyButtonText",
        "didClose",
        "didDestroy",
        "footer",
        "hideClass",
        "html",
        "icon",
        "iconColor",
        "iconHtml",
        "imageAlt",
        "imageHeight",
        "imageUrl",
        "imageWidth",
        "preConfirm",
        "preDeny",
        "progressSteps",
        "returnFocus",
        "reverseButtons",
        "showCancelButton",
        "showCloseButton",
        "showConfirmButton",
        "showDenyButton",
        "text",
        "title",
        "titleText",
        "willClose"
    ];
    /** @type {Record<string, string>} */ var deprecatedParams = {};
    var toastIncompatibleParams = [
        "allowOutsideClick",
        "allowEnterKey",
        "backdrop",
        "focusConfirm",
        "focusDeny",
        "focusCancel",
        "returnFocus",
        "heightAuto",
        "keydownListenerCapture"
    ];
    /**
   * Is valid parameter
   *
   * @param {string} paramName
   * @returns {boolean}
   */ var isValidParameter = function isValidParameter(paramName) {
        return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
    };
    /**
   * Is valid parameter for Swal.update() method
   *
   * @param {string} paramName
   * @returns {boolean}
   */ var isUpdatableParameter = function isUpdatableParameter(paramName) {
        return updatableParams.indexOf(paramName) !== -1;
    };
    /**
   * Is deprecated parameter
   *
   * @param {string} paramName
   * @returns {string | undefined}
   */ var isDeprecatedParameter = function isDeprecatedParameter(paramName) {
        return deprecatedParams[paramName];
    };
    /**
   * @param {string} param
   */ var checkIfParamIsValid = function checkIfParamIsValid(param) {
        if (!isValidParameter(param)) warn('Unknown parameter "'.concat(param, '"'));
    };
    /**
   * @param {string} param
   */ var checkIfToastParamIsValid = function checkIfToastParamIsValid(param) {
        if (toastIncompatibleParams.includes(param)) warn('The parameter "'.concat(param, '" is incompatible with toasts'));
    };
    /**
   * @param {string} param
   */ var checkIfParamIsDeprecated = function checkIfParamIsDeprecated(param) {
        var isDeprecated = isDeprecatedParameter(param);
        if (isDeprecated) warnAboutDeprecation(param, isDeprecated);
    };
    /**
   * Show relevant warnings for given params
   *
   * @param {SweetAlertOptions} params
   */ var showWarningsForParams = function showWarningsForParams(params) {
        if (params.backdrop === false && params.allowOutsideClick) warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
        for(var param in params){
            checkIfParamIsValid(param);
            if (params.toast) checkIfToastParamIsValid(param);
            checkIfParamIsDeprecated(param);
        }
    };
    /**
   * Updates popup parameters.
   *
   * @param {SweetAlertOptions} params
   */ function update(params) {
        var popup = getPopup();
        var innerParams = privateProps.innerParams.get(this);
        if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
            warn("You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.");
            return;
        }
        var validUpdatableParams = filterValidParams(params);
        var updatedParams = Object.assign({}, innerParams, validUpdatableParams);
        render(this, updatedParams);
        privateProps.innerParams.set(this, updatedParams);
        Object.defineProperties(this, {
            params: {
                value: Object.assign({}, this.params, params),
                writable: false,
                enumerable: true
            }
        });
    }
    /**
   * @param {SweetAlertOptions} params
   * @returns {SweetAlertOptions}
   */ var filterValidParams = function filterValidParams(params) {
        var validUpdatableParams = {};
        Object.keys(params).forEach(function(param) {
            if (isUpdatableParameter(param)) validUpdatableParams[param] = params[param];
            else warn("Invalid parameter to update: ".concat(param));
        });
        return validUpdatableParams;
    };
    /**
   * Dispose the current SweetAlert2 instance
   */ function _destroy() {
        var domCache = privateProps.domCache.get(this);
        var innerParams = privateProps.innerParams.get(this);
        if (!innerParams) {
            disposeWeakMaps(this); // The WeakMaps might have been partly destroyed, we must recall it to dispose any remaining WeakMaps #2335
            return; // This instance has already been destroyed
        }
        // Check if there is another Swal closing
        if (domCache.popup && globalState.swalCloseEventFinishedCallback) {
            globalState.swalCloseEventFinishedCallback();
            delete globalState.swalCloseEventFinishedCallback;
        }
        if (typeof innerParams.didDestroy === "function") innerParams.didDestroy();
        disposeSwal(this);
    }
    /**
   * @param {SweetAlert} instance
   */ var disposeSwal = function disposeSwal(instance) {
        disposeWeakMaps(instance);
        // Unset this.params so GC will dispose it (#1569)
        delete instance.params;
        // Unset globalState props so GC will dispose globalState (#1569)
        delete globalState.keydownHandler;
        delete globalState.keydownTarget;
        // Unset currentInstance
        delete globalState.currentInstance;
    };
    /**
   * @param {SweetAlert} instance
   */ var disposeWeakMaps = function disposeWeakMaps(instance) {
        // If the current instance is awaiting a promise result, we keep the privateMethods to call them once the promise result is retrieved #2335
        if (instance.isAwaitingPromise) {
            unsetWeakMaps(privateProps, instance);
            instance.isAwaitingPromise = true;
        } else {
            unsetWeakMaps(privateMethods, instance);
            unsetWeakMaps(privateProps, instance);
            delete instance.isAwaitingPromise;
            // Unset instance methods
            delete instance.disableButtons;
            delete instance.enableButtons;
            delete instance.getInput;
            delete instance.disableInput;
            delete instance.enableInput;
            delete instance.hideLoading;
            delete instance.disableLoading;
            delete instance.showValidationMessage;
            delete instance.resetValidationMessage;
            delete instance.close;
            delete instance.closePopup;
            delete instance.closeModal;
            delete instance.closeToast;
            delete instance.rejectPromise;
            delete instance.update;
            delete instance._destroy;
        }
    };
    /**
   * @param {object} obj
   * @param {SweetAlert} instance
   */ var unsetWeakMaps = function unsetWeakMaps(obj, instance) {
        for(var i in obj)obj[i]["delete"](instance);
    };
    var instanceMethods = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        _destroy: _destroy,
        close: close,
        closeModal: close,
        closePopup: close,
        closeToast: close,
        disableButtons: disableButtons,
        disableInput: disableInput,
        disableLoading: hideLoading,
        enableButtons: enableButtons,
        enableInput: enableInput,
        getInput: getInput,
        handleAwaitingPromise: handleAwaitingPromise,
        hideLoading: hideLoading,
        rejectPromise: rejectPromise,
        resetValidationMessage: resetValidationMessage,
        showValidationMessage: showValidationMessage,
        update: update
    });
    /**
   * @param {SweetAlertOptions} innerParams
   * @param {DomCache} domCache
   * @param {Function} dismissWith
   */ var handlePopupClick = function handlePopupClick(innerParams, domCache, dismissWith) {
        if (innerParams.toast) handleToastClick(innerParams, domCache, dismissWith);
        else {
            // Ignore click events that had mousedown on the popup but mouseup on the container
            // This can happen when the user drags a slider
            handleModalMousedown(domCache);
            // Ignore click events that had mousedown on the container but mouseup on the popup
            handleContainerMousedown(domCache);
            handleModalClick(innerParams, domCache, dismissWith);
        }
    };
    /**
   * @param {SweetAlertOptions} innerParams
   * @param {DomCache} domCache
   * @param {Function} dismissWith
   */ var handleToastClick = function handleToastClick(innerParams, domCache, dismissWith) {
        // Closing toast by internal click
        domCache.popup.onclick = function() {
            if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) return;
            dismissWith(DismissReason.close);
        };
    };
    /**
   * @param {SweetAlertOptions} innerParams
   * @returns {boolean}
   */ var isAnyButtonShown = function isAnyButtonShown(innerParams) {
        return !!(innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton);
    };
    var ignoreOutsideClick = false;
    /**
   * @param {DomCache} domCache
   */ var handleModalMousedown = function handleModalMousedown(domCache) {
        domCache.popup.onmousedown = function() {
            domCache.container.onmouseup = function(e) {
                domCache.container.onmouseup = function() {};
                // We only check if the mouseup target is the container because usually it doesn't
                // have any other direct children aside of the popup
                if (e.target === domCache.container) ignoreOutsideClick = true;
            };
        };
    };
    /**
   * @param {DomCache} domCache
   */ var handleContainerMousedown = function handleContainerMousedown(domCache) {
        domCache.container.onmousedown = function() {
            domCache.popup.onmouseup = function(e) {
                domCache.popup.onmouseup = function() {};
                // We also need to check if the mouseup target is a child of the popup
                if (e.target === domCache.popup || e.target instanceof HTMLElement && domCache.popup.contains(e.target)) ignoreOutsideClick = true;
            };
        };
    };
    /**
   * @param {SweetAlertOptions} innerParams
   * @param {DomCache} domCache
   * @param {Function} dismissWith
   */ var handleModalClick = function handleModalClick(innerParams, domCache, dismissWith) {
        domCache.container.onclick = function(e) {
            if (ignoreOutsideClick) {
                ignoreOutsideClick = false;
                return;
            }
            if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) dismissWith(DismissReason.backdrop);
        };
    };
    var isJqueryElement = function isJqueryElement(elem) {
        return _typeof(elem) === "object" && elem.jquery;
    };
    var isElement = function isElement(elem) {
        return elem instanceof Element || isJqueryElement(elem);
    };
    var argsToParams = function argsToParams(args) {
        var params = {};
        if (_typeof(args[0]) === "object" && !isElement(args[0])) Object.assign(params, args[0]);
        else [
            "title",
            "html",
            "icon"
        ].forEach(function(name, index) {
            var arg = args[index];
            if (typeof arg === "string" || isElement(arg)) params[name] = arg;
            else if (arg !== undefined) error("Unexpected type of ".concat(name, '! Expected "string" or "Element", got ').concat(_typeof(arg)));
        });
        return params;
    };
    /**
   * Main method to create a new SweetAlert2 popup
   *
   * @param  {...SweetAlertOptions} args
   * @returns {Promise<SweetAlertResult>}
   */ function fire() {
        var Swal = this; // eslint-disable-line @typescript-eslint/no-this-alias
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        return _construct(Swal, args);
    }
    /**
   * Returns an extended version of `Swal` containing `params` as defaults.
   * Useful for reusing Swal configuration.
   *
   * For example:
   *
   * Before:
   * const textPromptOptions = { input: 'text', showCancelButton: true }
   * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })
   * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })
   *
   * After:
   * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })
   * const {value: firstName} = await TextPrompt('What is your first name?')
   * const {value: lastName} = await TextPrompt('What is your last name?')
   *
   * @param {SweetAlertOptions} mixinParams
   * @returns {SweetAlert}
   */ function mixin(mixinParams) {
        var MixinSwal = /*#__PURE__*/ function(_this) {
            _inherits(MixinSwal, _this);
            var _super = _createSuper(MixinSwal);
            function MixinSwal() {
                _classCallCheck(this, MixinSwal);
                return _super.apply(this, arguments);
            }
            _createClass(MixinSwal, [
                {
                    key: "_main",
                    value: function _main(params, priorityMixinParams) {
                        return _get(_getPrototypeOf(MixinSwal.prototype), "_main", this).call(this, params, Object.assign({}, mixinParams, priorityMixinParams));
                    }
                }
            ]);
            return MixinSwal;
        }(this); // @ts-ignore
        return MixinSwal;
    }
    /**
   * If `timer` parameter is set, returns number of milliseconds of timer remained.
   * Otherwise, returns undefined.
   *
   * @returns {number | undefined}
   */ var getTimerLeft = function getTimerLeft() {
        return globalState.timeout && globalState.timeout.getTimerLeft();
    };
    /**
   * Stop timer. Returns number of milliseconds of timer remained.
   * If `timer` parameter isn't set, returns undefined.
   *
   * @returns {number | undefined}
   */ var stopTimer = function stopTimer() {
        if (globalState.timeout) {
            stopTimerProgressBar();
            return globalState.timeout.stop();
        }
    };
    /**
   * Resume timer. Returns number of milliseconds of timer remained.
   * If `timer` parameter isn't set, returns undefined.
   *
   * @returns {number | undefined}
   */ var resumeTimer = function resumeTimer() {
        if (globalState.timeout) {
            var remaining = globalState.timeout.start();
            animateTimerProgressBar(remaining);
            return remaining;
        }
    };
    /**
   * Resume timer. Returns number of milliseconds of timer remained.
   * If `timer` parameter isn't set, returns undefined.
   *
   * @returns {number | undefined}
   */ var toggleTimer = function toggleTimer() {
        var timer = globalState.timeout;
        return timer && (timer.running ? stopTimer() : resumeTimer());
    };
    /**
   * Increase timer. Returns number of milliseconds of an updated timer.
   * If `timer` parameter isn't set, returns undefined.
   *
   * @param {number} ms
   * @returns {number | undefined}
   */ var increaseTimer = function increaseTimer(ms) {
        if (globalState.timeout) {
            var remaining = globalState.timeout.increase(ms);
            animateTimerProgressBar(remaining, true);
            return remaining;
        }
    };
    /**
   * Check if timer is running. Returns true if timer is running
   * or false if timer is paused or stopped.
   * If `timer` parameter isn't set, returns undefined
   *
   * @returns {boolean}
   */ var isTimerRunning = function isTimerRunning() {
        return !!(globalState.timeout && globalState.timeout.isRunning());
    };
    var bodyClickListenerAdded = false;
    var clickHandlers = {};
    /**
   * @param {string} attr
   */ function bindClickHandler() {
        var attr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "data-swal-template";
        clickHandlers[attr] = this;
        if (!bodyClickListenerAdded) {
            document.body.addEventListener("click", bodyClickListener);
            bodyClickListenerAdded = true;
        }
    }
    var bodyClickListener = function bodyClickListener(event) {
        for(var el = event.target; el && el !== document; el = el.parentNode)for(var attr in clickHandlers){
            var template = el.getAttribute(attr);
            if (template) {
                clickHandlers[attr].fire({
                    template: template
                });
                return;
            }
        }
    };
    var staticMethods = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        argsToParams: argsToParams,
        bindClickHandler: bindClickHandler,
        clickCancel: clickCancel,
        clickConfirm: clickConfirm,
        clickDeny: clickDeny,
        enableLoading: showLoading,
        fire: fire,
        getActions: getActions,
        getCancelButton: getCancelButton,
        getCloseButton: getCloseButton,
        getConfirmButton: getConfirmButton,
        getContainer: getContainer,
        getDenyButton: getDenyButton,
        getFocusableElements: getFocusableElements,
        getFooter: getFooter,
        getHtmlContainer: getHtmlContainer,
        getIcon: getIcon,
        getIconContent: getIconContent,
        getImage: getImage,
        getInputLabel: getInputLabel,
        getLoader: getLoader,
        getPopup: getPopup,
        getProgressSteps: getProgressSteps,
        getTimerLeft: getTimerLeft,
        getTimerProgressBar: getTimerProgressBar,
        getTitle: getTitle,
        getValidationMessage: getValidationMessage,
        increaseTimer: increaseTimer,
        isDeprecatedParameter: isDeprecatedParameter,
        isLoading: isLoading,
        isTimerRunning: isTimerRunning,
        isUpdatableParameter: isUpdatableParameter,
        isValidParameter: isValidParameter,
        isVisible: isVisible,
        mixin: mixin,
        resumeTimer: resumeTimer,
        showLoading: showLoading,
        stopTimer: stopTimer,
        toggleTimer: toggleTimer
    });
    var Timer = /*#__PURE__*/ function() {
        /**
     * @param {Function} callback
     * @param {number} delay
     */ function Timer(callback, delay) {
            _classCallCheck(this, Timer);
            this.callback = callback;
            this.remaining = delay;
            this.running = false;
            this.start();
        }
        /**
     * @returns {number}
     */ _createClass(Timer, [
            {
                key: "start",
                value: function start() {
                    if (!this.running) {
                        this.running = true;
                        this.started = new Date();
                        this.id = setTimeout(this.callback, this.remaining);
                    }
                    return this.remaining;
                }
            },
            {
                key: "stop",
                value: function stop() {
                    if (this.started && this.running) {
                        this.running = false;
                        clearTimeout(this.id);
                        this.remaining -= new Date().getTime() - this.started.getTime();
                    }
                    return this.remaining;
                }
            },
            {
                key: "increase",
                value: function increase(n) {
                    var running = this.running;
                    if (running) this.stop();
                    this.remaining += n;
                    if (running) this.start();
                    return this.remaining;
                }
            },
            {
                key: "getTimerLeft",
                value: function getTimerLeft() {
                    if (this.running) {
                        this.stop();
                        this.start();
                    }
                    return this.remaining;
                }
            },
            {
                key: "isRunning",
                value: function isRunning() {
                    return this.running;
                }
            }
        ]);
        return Timer;
    }();
    var swalStringParams = [
        "swal-title",
        "swal-html",
        "swal-footer"
    ];
    /**
   * @param {SweetAlertOptions} params
   * @returns {SweetAlertOptions}
   */ var getTemplateParams = function getTemplateParams(params) {
        /** @type {HTMLTemplateElement} */ var template = typeof params.template === "string" ? document.querySelector(params.template) : params.template;
        if (!template) return {};
        /** @type {DocumentFragment} */ var templateContent = template.content;
        showWarningsForElements(templateContent);
        var result = Object.assign(getSwalParams(templateContent), getSwalFunctionParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));
        return result;
    };
    /**
   * @param {DocumentFragment} templateContent
   * @returns {SweetAlertOptions}
   */ var getSwalParams = function getSwalParams(templateContent) {
        var result = {};
        /** @type {HTMLElement[]} */ var swalParams = Array.from(templateContent.querySelectorAll("swal-param"));
        swalParams.forEach(function(param) {
            showWarningsForAttributes(param, [
                "name",
                "value"
            ]);
            var paramName = param.getAttribute("name");
            var value = param.getAttribute("value");
            if (typeof defaultParams[paramName] === "boolean") result[paramName] = value !== "false";
            else if (_typeof(defaultParams[paramName]) === "object") result[paramName] = JSON.parse(value);
            else result[paramName] = value;
        });
        return result;
    };
    /**
   * @param {DocumentFragment} templateContent
   * @returns {SweetAlertOptions}
   */ var getSwalFunctionParams = function getSwalFunctionParams(templateContent) {
        var result = {};
        /** @type {HTMLElement[]} */ var swalFunctions = Array.from(templateContent.querySelectorAll("swal-function-param"));
        swalFunctions.forEach(function(param) {
            var paramName = param.getAttribute("name");
            var value = param.getAttribute("value");
            result[paramName] = new Function("return ".concat(value))();
        });
        return result;
    };
    /**
   * @param {DocumentFragment} templateContent
   * @returns {SweetAlertOptions}
   */ var getSwalButtons = function getSwalButtons(templateContent) {
        var result = {};
        /** @type {HTMLElement[]} */ var swalButtons = Array.from(templateContent.querySelectorAll("swal-button"));
        swalButtons.forEach(function(button) {
            showWarningsForAttributes(button, [
                "type",
                "color",
                "aria-label"
            ]);
            var type = button.getAttribute("type");
            result["".concat(type, "ButtonText")] = button.innerHTML;
            result["show".concat(capitalizeFirstLetter(type), "Button")] = true;
            if (button.hasAttribute("color")) result["".concat(type, "ButtonColor")] = button.getAttribute("color");
            if (button.hasAttribute("aria-label")) result["".concat(type, "ButtonAriaLabel")] = button.getAttribute("aria-label");
        });
        return result;
    };
    /**
   * @param {DocumentFragment} templateContent
   * @returns {SweetAlertOptions}
   */ var getSwalImage = function getSwalImage(templateContent) {
        var result = {};
        /** @type {HTMLElement} */ var image = templateContent.querySelector("swal-image");
        if (image) {
            showWarningsForAttributes(image, [
                "src",
                "width",
                "height",
                "alt"
            ]);
            if (image.hasAttribute("src")) result.imageUrl = image.getAttribute("src");
            if (image.hasAttribute("width")) result.imageWidth = image.getAttribute("width");
            if (image.hasAttribute("height")) result.imageHeight = image.getAttribute("height");
            if (image.hasAttribute("alt")) result.imageAlt = image.getAttribute("alt");
        }
        return result;
    };
    /**
   * @param {DocumentFragment} templateContent
   * @returns {SweetAlertOptions}
   */ var getSwalIcon = function getSwalIcon(templateContent) {
        var result = {};
        /** @type {HTMLElement} */ var icon = templateContent.querySelector("swal-icon");
        if (icon) {
            showWarningsForAttributes(icon, [
                "type",
                "color"
            ]);
            if (icon.hasAttribute("type")) /** @type {SweetAlertIcon} */ // @ts-ignore
            result.icon = icon.getAttribute("type");
            if (icon.hasAttribute("color")) result.iconColor = icon.getAttribute("color");
            result.iconHtml = icon.innerHTML;
        }
        return result;
    };
    /**
   * @param {DocumentFragment} templateContent
   * @returns {SweetAlertOptions}
   */ var getSwalInput = function getSwalInput(templateContent) {
        var result = {};
        /** @type {HTMLElement} */ var input = templateContent.querySelector("swal-input");
        if (input) {
            showWarningsForAttributes(input, [
                "type",
                "label",
                "placeholder",
                "value"
            ]);
            /** @type {SweetAlertInput} */ // @ts-ignore
            result.input = input.getAttribute("type") || "text";
            if (input.hasAttribute("label")) result.inputLabel = input.getAttribute("label");
            if (input.hasAttribute("placeholder")) result.inputPlaceholder = input.getAttribute("placeholder");
            if (input.hasAttribute("value")) result.inputValue = input.getAttribute("value");
        }
        /** @type {HTMLElement[]} */ var inputOptions = Array.from(templateContent.querySelectorAll("swal-input-option"));
        if (inputOptions.length) {
            result.inputOptions = {};
            inputOptions.forEach(function(option) {
                showWarningsForAttributes(option, [
                    "value"
                ]);
                var optionValue = option.getAttribute("value");
                var optionName = option.innerHTML;
                result.inputOptions[optionValue] = optionName;
            });
        }
        return result;
    };
    /**
   * @param {DocumentFragment} templateContent
   * @param {string[]} paramNames
   * @returns {SweetAlertOptions}
   */ var getSwalStringParams = function getSwalStringParams(templateContent, paramNames) {
        var result = {};
        for(var i in paramNames){
            var paramName = paramNames[i];
            /** @type {HTMLElement} */ var tag = templateContent.querySelector(paramName);
            if (tag) {
                showWarningsForAttributes(tag, []);
                result[paramName.replace(/^swal-/, "")] = tag.innerHTML.trim();
            }
        }
        return result;
    };
    /**
   * @param {DocumentFragment} templateContent
   */ var showWarningsForElements = function showWarningsForElements(templateContent) {
        var allowedElements = swalStringParams.concat([
            "swal-param",
            "swal-function-param",
            "swal-button",
            "swal-image",
            "swal-icon",
            "swal-input",
            "swal-input-option"
        ]);
        Array.from(templateContent.children).forEach(function(el) {
            var tagName = el.tagName.toLowerCase();
            if (!allowedElements.includes(tagName)) warn("Unrecognized element <".concat(tagName, ">"));
        });
    };
    /**
   * @param {HTMLElement} el
   * @param {string[]} allowedAttributes
   */ var showWarningsForAttributes = function showWarningsForAttributes(el, allowedAttributes) {
        Array.from(el.attributes).forEach(function(attribute) {
            if (allowedAttributes.indexOf(attribute.name) === -1) warn([
                'Unrecognized attribute "'.concat(attribute.name, '" on <').concat(el.tagName.toLowerCase(), ">."),
                "".concat(allowedAttributes.length ? "Allowed attributes are: ".concat(allowedAttributes.join(", ")) : "To set the value, use HTML within the element.")
            ]);
        });
    };
    var SHOW_CLASS_TIMEOUT = 10;
    /**
   * Open popup, add necessary classes and styles, fix scrollbar
   *
   * @param {SweetAlertOptions} params
   */ var openPopup = function openPopup(params) {
        var container = getContainer();
        var popup = getPopup();
        if (typeof params.willOpen === "function") params.willOpen(popup);
        var bodyStyles = window.getComputedStyle(document.body);
        var initialBodyOverflow = bodyStyles.overflowY;
        addClasses(container, popup, params);
        // scrolling is 'hidden' until animation is done, after that 'auto'
        setTimeout(function() {
            setScrollingVisibility(container, popup);
        }, SHOW_CLASS_TIMEOUT);
        if (isModal()) {
            fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);
            setAriaHidden();
        }
        if (!isToast() && !globalState.previousActiveElement) globalState.previousActiveElement = document.activeElement;
        if (typeof params.didOpen === "function") setTimeout(function() {
            return params.didOpen(popup);
        });
        removeClass(container, swalClasses["no-transition"]);
    };
    /**
   * @param {AnimationEvent} event
   */ var swalOpenAnimationFinished = function swalOpenAnimationFinished(event) {
        var popup = getPopup();
        if (event.target !== popup || !animationEndEvent) return;
        var container = getContainer();
        popup.removeEventListener(animationEndEvent, swalOpenAnimationFinished);
        container.style.overflowY = "auto";
    };
    /**
   * @param {HTMLElement} container
   * @param {HTMLElement} popup
   */ var setScrollingVisibility = function setScrollingVisibility(container, popup) {
        if (animationEndEvent && hasCssAnimation(popup)) {
            container.style.overflowY = "hidden";
            popup.addEventListener(animationEndEvent, swalOpenAnimationFinished);
        } else container.style.overflowY = "auto";
    };
    /**
   * @param {HTMLElement} container
   * @param {boolean} scrollbarPadding
   * @param {string} initialBodyOverflow
   */ var fixScrollContainer = function fixScrollContainer(container, scrollbarPadding, initialBodyOverflow) {
        iOSfix();
        if (scrollbarPadding && initialBodyOverflow !== "hidden") replaceScrollbarWithPadding(initialBodyOverflow);
        // sweetalert2/issues/1247
        setTimeout(function() {
            container.scrollTop = 0;
        });
    };
    /**
   * @param {HTMLElement} container
   * @param {HTMLElement} popup
   * @param {SweetAlertOptions} params
   */ var addClasses = function addClasses(container, popup, params) {
        addClass(container, params.showClass.backdrop);
        if (params.animation) {
            // this workaround with opacity is needed for https://github.com/sweetalert2/sweetalert2/issues/2059
            popup.style.setProperty("opacity", "0", "important");
            show(popup, "grid");
            setTimeout(function() {
                // Animate popup right after showing it
                addClass(popup, params.showClass.popup);
                // and remove the opacity workaround
                popup.style.removeProperty("opacity");
            }, SHOW_CLASS_TIMEOUT); // 10ms in order to fix #2062
        } else show(popup, "grid");
        addClass([
            document.documentElement,
            document.body
        ], swalClasses.shown);
        if (params.heightAuto && params.backdrop && !params.toast) addClass([
            document.documentElement,
            document.body
        ], swalClasses["height-auto"]);
    };
    var defaultInputValidators = {
        /**
     * @param {string} string
     * @param {string} [validationMessage]
     * @returns {Promise<string | void>}
     */ email: function email(string, validationMessage) {
            return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid email address");
        },
        /**
     * @param {string} string
     * @param {string} [validationMessage]
     * @returns {Promise<string | void>}
     */ url: function url(string, validationMessage) {
            // taken from https://stackoverflow.com/a/3809435 with a small change from #1306 and #2013
            return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid URL");
        }
    };
    /**
   * @param {SweetAlertOptions} params
   */ function setDefaultInputValidators(params) {
        // Use default `inputValidator` for supported input types if not provided
        if (params.inputValidator) return;
        if (params.input === "email") params.inputValidator = defaultInputValidators["email"];
        if (params.input === "url") params.inputValidator = defaultInputValidators["url"];
    }
    /**
   * @param {SweetAlertOptions} params
   */ function validateCustomTargetElement(params) {
        // Determine if the custom target element is valid
        if (!params.target || typeof params.target === "string" && !document.querySelector(params.target) || typeof params.target !== "string" && !params.target.appendChild) {
            warn('Target parameter is not valid, defaulting to "body"');
            params.target = "body";
        }
    }
    /**
   * Set type, text and actions on popup
   *
   * @param {SweetAlertOptions} params
   */ function setParameters(params) {
        setDefaultInputValidators(params);
        // showLoaderOnConfirm && preConfirm
        if (params.showLoaderOnConfirm && !params.preConfirm) warn("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request");
        validateCustomTargetElement(params);
        // Replace newlines with <br> in title
        if (typeof params.title === "string") params.title = params.title.split("\n").join("<br />");
        init(params);
    }
    /** @type {SweetAlert} */ var currentInstance;
    var _promise = /*#__PURE__*/ new WeakMap();
    var SweetAlert = /*#__PURE__*/ function() {
        /**
     * @param {...any} args
     * @this {SweetAlert}
     */ function SweetAlert() {
            _classCallCheck(this, SweetAlert);
            /**
       * @type {Promise<SweetAlertResult>}
       */ _classPrivateFieldInitSpec(this, _promise, {
                writable: true,
                value: void 0
            });
            // Prevent run in Node env
            if (typeof window === "undefined") return;
            currentInstance = this;
            // @ts-ignore
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
            var outerParams = Object.freeze(this.constructor.argsToParams(args));
            /** @type {Readonly<SweetAlertOptions>} */ this.params = outerParams;
            /** @type {boolean} */ this.isAwaitingPromise = false;
            _classPrivateFieldSet(this, _promise, this._main(currentInstance.params));
        }
        _createClass(SweetAlert, [
            {
                key: "_main",
                value: function _main(userParams) {
                    var mixinParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    showWarningsForParams(Object.assign({}, mixinParams, userParams));
                    if (globalState.currentInstance) {
                        var swalPromiseResolve = privateMethods.swalPromiseResolve.get(globalState.currentInstance);
                        var isAwaitingPromise = globalState.currentInstance.isAwaitingPromise;
                        globalState.currentInstance._destroy();
                        if (!isAwaitingPromise) swalPromiseResolve({
                            isDismissed: true
                        });
                        if (isModal()) unsetAriaHidden();
                    }
                    globalState.currentInstance = currentInstance;
                    var innerParams = prepareParams(userParams, mixinParams);
                    setParameters(innerParams);
                    Object.freeze(innerParams);
                    // clear the previous timer
                    if (globalState.timeout) {
                        globalState.timeout.stop();
                        delete globalState.timeout;
                    }
                    // clear the restore focus timeout
                    clearTimeout(globalState.restoreFocusTimeout);
                    var domCache = populateDomCache(currentInstance);
                    render(currentInstance, innerParams);
                    privateProps.innerParams.set(currentInstance, innerParams);
                    return swalPromise(currentInstance, domCache, innerParams);
                }
            },
            {
                key: "then",
                value: function then(onFulfilled) {
                    return _classPrivateFieldGet(this, _promise).then(onFulfilled);
                }
            },
            {
                key: "finally",
                value: function _finally(onFinally) {
                    return _classPrivateFieldGet(this, _promise)["finally"](onFinally);
                }
            }
        ]);
        return SweetAlert;
    }();
    /**
   * @param {SweetAlert} instance
   * @param {DomCache} domCache
   * @param {SweetAlertOptions} innerParams
   * @returns {Promise}
   */ var swalPromise = function swalPromise(instance, domCache, innerParams) {
        return new Promise(function(resolve, reject) {
            // functions to handle all closings/dismissals
            /**
       * @param {DismissReason} dismiss
       */ var dismissWith = function dismissWith(dismiss) {
                instance.close({
                    isDismissed: true,
                    dismiss: dismiss
                });
            };
            privateMethods.swalPromiseResolve.set(instance, resolve);
            privateMethods.swalPromiseReject.set(instance, reject);
            domCache.confirmButton.onclick = function() {
                handleConfirmButtonClick(instance);
            };
            domCache.denyButton.onclick = function() {
                handleDenyButtonClick(instance);
            };
            domCache.cancelButton.onclick = function() {
                handleCancelButtonClick(instance, dismissWith);
            };
            domCache.closeButton.onclick = function() {
                dismissWith(DismissReason.close);
            };
            handlePopupClick(innerParams, domCache, dismissWith);
            addKeydownHandler(globalState, innerParams, dismissWith);
            handleInputOptionsAndValue(instance, innerParams);
            openPopup(innerParams);
            setupTimer(globalState, innerParams, dismissWith);
            initFocus(domCache, innerParams);
            // Scroll container to top on open (#1247, #1946)
            setTimeout(function() {
                domCache.container.scrollTop = 0;
            });
        });
    };
    /**
   * @param {SweetAlertOptions} userParams
   * @param {SweetAlertOptions} mixinParams
   * @returns {SweetAlertOptions}
   */ var prepareParams = function prepareParams(userParams, mixinParams) {
        var templateParams = getTemplateParams(userParams);
        var params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams); // precedence is described in #2131
        params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);
        params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);
        if (params.animation === false) {
            params.showClass = {
                backdrop: "swal2-noanimation"
            };
            params.hideClass = {};
        }
        return params;
    };
    /**
   * @param {SweetAlert} instance
   * @returns {DomCache}
   */ var populateDomCache = function populateDomCache(instance) {
        var domCache = {
            popup: getPopup(),
            container: getContainer(),
            actions: getActions(),
            confirmButton: getConfirmButton(),
            denyButton: getDenyButton(),
            cancelButton: getCancelButton(),
            loader: getLoader(),
            closeButton: getCloseButton(),
            validationMessage: getValidationMessage(),
            progressSteps: getProgressSteps()
        };
        privateProps.domCache.set(instance, domCache);
        return domCache;
    };
    /**
   * @param {GlobalState} globalState
   * @param {SweetAlertOptions} innerParams
   * @param {Function} dismissWith
   */ var setupTimer = function setupTimer(globalState, innerParams, dismissWith) {
        var timerProgressBar = getTimerProgressBar();
        hide(timerProgressBar);
        if (innerParams.timer) {
            globalState.timeout = new Timer(function() {
                dismissWith("timer");
                delete globalState.timeout;
            }, innerParams.timer);
            if (innerParams.timerProgressBar) {
                show(timerProgressBar);
                applyCustomClass(timerProgressBar, innerParams, "timerProgressBar");
                setTimeout(function() {
                    if (globalState.timeout && globalState.timeout.running) // timer can be already stopped or unset at this point
                    animateTimerProgressBar(innerParams.timer);
                });
            }
        }
    };
    /**
   * @param {DomCache} domCache
   * @param {SweetAlertOptions} innerParams
   */ var initFocus = function initFocus(domCache, innerParams) {
        if (innerParams.toast) return;
        if (!callIfFunction(innerParams.allowEnterKey)) {
            blurActiveElement();
            return;
        }
        if (!focusButton(domCache, innerParams)) setFocus(-1, 1);
    };
    /**
   * @param {DomCache} domCache
   * @param {SweetAlertOptions} innerParams
   * @returns {boolean}
   */ var focusButton = function focusButton(domCache, innerParams) {
        if (innerParams.focusDeny && isVisible$1(domCache.denyButton)) {
            domCache.denyButton.focus();
            return true;
        }
        if (innerParams.focusCancel && isVisible$1(domCache.cancelButton)) {
            domCache.cancelButton.focus();
            return true;
        }
        if (innerParams.focusConfirm && isVisible$1(domCache.confirmButton)) {
            domCache.confirmButton.focus();
            return true;
        }
        return false;
    };
    var blurActiveElement = function blurActiveElement() {
        if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === "function") document.activeElement.blur();
    };
    // Dear russian users visiting russian sites. Let's have fun.
    if (typeof window !== "undefined" && /^ru\b/.test(navigator.language) && location.host.match(/\.(ru|su|by|xn--p1ai)$/)) {
        var now = new Date();
        var initiationDate = localStorage.getItem("swal-initiation");
        if (!initiationDate) localStorage.setItem("swal-initiation", "".concat(now));
        else if ((now.getTime() - Date.parse(initiationDate)) / 86400000 > 3) setTimeout(function() {
            document.body.style.pointerEvents = "none";
            var ukrainianAnthem = document.createElement("audio");
            ukrainianAnthem.src = "https://flag-gimn.ru/wp-content/uploads/2021/09/Ukraina.mp3";
            ukrainianAnthem.loop = true;
            document.body.appendChild(ukrainianAnthem);
            setTimeout(function() {
                ukrainianAnthem.play()["catch"](function() {
                // ignore
                });
            }, 2500);
        }, 500);
    }
    // Assign instance methods from src/instanceMethods/*.js to prototype
    SweetAlert.prototype.disableButtons = disableButtons;
    SweetAlert.prototype.enableButtons = enableButtons;
    SweetAlert.prototype.getInput = getInput;
    SweetAlert.prototype.disableInput = disableInput;
    SweetAlert.prototype.enableInput = enableInput;
    SweetAlert.prototype.hideLoading = hideLoading;
    SweetAlert.prototype.disableLoading = hideLoading;
    SweetAlert.prototype.showValidationMessage = showValidationMessage;
    SweetAlert.prototype.resetValidationMessage = resetValidationMessage;
    SweetAlert.prototype.close = close;
    SweetAlert.prototype.closePopup = close;
    SweetAlert.prototype.closeModal = close;
    SweetAlert.prototype.closeToast = close;
    SweetAlert.prototype.rejectPromise = rejectPromise;
    SweetAlert.prototype.update = update;
    SweetAlert.prototype._destroy = _destroy;
    // Assign static methods from src/staticMethods/*.js to constructor
    Object.assign(SweetAlert, staticMethods);
    // Proxy to instance methods to constructor, for now, for backwards compatibility
    Object.keys(instanceMethods).forEach(function(key) {
        /**
     * @param {...any} args
     * @returns {any | undefined}
     */ SweetAlert[key] = function() {
            if (currentInstance && currentInstance[key]) {
                var _currentInstance;
                return (_currentInstance = currentInstance)[key].apply(_currentInstance, arguments);
            }
            return null;
        };
    });
    SweetAlert.DismissReason = DismissReason;
    SweetAlert.version = "11.10.2";
    var Swal = SweetAlert;
    // @ts-ignore
    Swal["default"] = Swal;
    return Swal;
});
if (typeof undefined !== "undefined" && undefined.Sweetalert2) undefined.swal = undefined.sweetAlert = undefined.Swal = undefined.SweetAlert = undefined.Sweetalert2;
"undefined" != typeof document && function(e, t) {
    var n = e.createElement("style");
    if (e.getElementsByTagName("head")[0].appendChild(n), n.styleSheet) n.styleSheet.disabled || (n.styleSheet.cssText = t);
    else try {
        n.innerHTML = t;
    } catch (e) {
        n.innerText = t;
    }
}(document, '.swal2-popup.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;background:#fff;box-shadow:0 0 1px rgba(0,0,0,.075),0 1px 2px rgba(0,0,0,.075),1px 2px 4px rgba(0,0,0,.075),1px 3px 8px rgba(0,0,0,.075),2px 4px 16px rgba(0,0,0,.075);pointer-events:all}.swal2-popup.swal2-toast>*{grid-column:2}.swal2-popup.swal2-toast .swal2-title{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-loading{justify-content:center}.swal2-popup.swal2-toast .swal2-input{height:2em;margin:.5em;font-size:1em}.swal2-popup.swal2-toast .swal2-validation-message{font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-popup.swal2-toast .swal2-html-container{margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-html-container:empty{padding:0}.swal2-popup.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-popup.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-popup.swal2-toast .swal2-styled{margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;transform:rotate(45deg);border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{animation:swal2-toast-hide .1s forwards}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:"top-start     top            top-end" "center-start  center         center-end" "bottom-start  bottom-center  bottom-end";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:rgba(0,0,0,.4)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;place-self:start center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;place-self:start end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;place-self:center center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;place-self:center end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;place-self:end center}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;place-self:end end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:32em;max-width:100%;padding:0 0 1.25em;border:none;border-radius:5px;background:#fff;color:#545454;font-family:inherit;font-size:1rem}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:.8em 1em 0;color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1))}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2))}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:box-shadow .1s;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled).swal2-confirm{border:0;border-radius:.25em;background:initial;background-color:#7066e0;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled).swal2-confirm:focus{box-shadow:0 0 0 3px rgba(112,102,224,.5)}div:where(.swal2-container) button:where(.swal2-styled).swal2-deny{border:0;border-radius:.25em;background:initial;background-color:#dc3741;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled).swal2-deny:focus{box-shadow:0 0 0 3px rgba(220,55,65,.5)}div:where(.swal2-container) button:where(.swal2-styled).swal2-cancel{border:0;border-radius:.25em;background:initial;background-color:#6e7881;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled).swal2-cancel:focus{box-shadow:0 0 0 3px rgba(110,120,129,.5)}div:where(.swal2-container) button:where(.swal2-styled).swal2-default-outline:focus{box-shadow:0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-styled):focus{outline:none}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){margin:1em 0 0;padding:1em 1em 0;border-top:1px solid #eee;color:inherit;font-size:1em;text-align:center}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:5px;border-bottom-left-radius:5px}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:rgba(0,0,0,.2)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em}div:where(.swal2-container) button:where(.swal2-close){z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:color .1s,box-shadow .1s;border:none;border-radius:5px;background:rgba(0,0,0,0);color:#ccc;font-family:monospace;font-size:2.5em;cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:none;background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus{outline:none;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) .swal2-html-container{z-index:1;justify-content:center;margin:1em 1.6em .3em;padding:0;overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:border-color .1s,box-shadow .1s;border:1px solid #d9d9d9;border-radius:.1875em;background:rgba(0,0,0,0);box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(0,0,0,0);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:1px solid #b4dbed;outline:none;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:#fff}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:rgba(0,0,0,0);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:rgba(0,0,0,0);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:#fff;color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:"!";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;border:0.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}div:where(.swal2-icon).swal2-warning{border-color:#facea8;color:#f8bb86}div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}div:where(.swal2-icon).swal2-info{border-color:#9de0f6;color:#3fc3ee}div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}div:where(.swal2-icon).swal2-question{border-color:#c9dae1;color:#87adbd}div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;transform:rotate(45deg);border-radius:50%}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:swal2-show .3s}.swal2-hide{animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-show{0%{transform:scale(0.7)}45%{transform:scale(1.05)}80%{transform:scale(0.95)}100%{transform:scale(1)}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(0.5);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static !important}}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}');

},{"@swc/helpers/_/_type_of":"b4wfg"}],"bpu2t":[function(require,module,exports) {
var global = arguments[3];
(function(a, b) {
    if ("function" == typeof define && define.amd) define([], b);
    else b();
})(this, function() {
    "use strict";
    function b(a, b) {
        return "undefined" == typeof b ? b = {
            autoBom: !1
        } : "object" != typeof b && (console.warn("Deprecated: Expected third argument to be a object"), b = {
            autoBom: !b
        }), b.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type) ? new Blob([
            "\uFEFF",
            a
        ], {
            type: a.type
        }) : a;
    }
    function c(a, b, c) {
        var d = new XMLHttpRequest;
        d.open("GET", a), d.responseType = "blob", d.onload = function() {
            g(d.response, b, c);
        }, d.onerror = function() {
            console.error("could not download file");
        }, d.send();
    }
    function d(a) {
        var b = new XMLHttpRequest;
        b.open("HEAD", a, !1);
        try {
            b.send();
        } catch (a) {}
        return 200 <= b.status && 299 >= b.status;
    }
    function e(a) {
        try {
            a.dispatchEvent(new MouseEvent("click"));
        } catch (c) {
            var b = document.createEvent("MouseEvents");
            b.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(b);
        }
    }
    var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {} : "download" in HTMLAnchorElement.prototype && !a ? function(b, g, h) {
        var i = f.URL || f.webkitURL, j = document.createElement("a");
        g = g || b.name || "download", j.download = g, j.rel = "noopener", "string" == typeof b ? (j.href = b, j.origin === location.origin ? e(j) : d(j.href) ? c(b, g, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b), setTimeout(function() {
            i.revokeObjectURL(j.href);
        }, 4E4), setTimeout(function() {
            e(j);
        }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(f, g, h) {
        if (g = g || f.name || "download", "string" != typeof f) navigator.msSaveOrOpenBlob(b(f, h), g);
        else if (d(f)) c(f, g, h);
        else {
            var i = document.createElement("a");
            i.href = f, i.target = "_blank", setTimeout(function() {
                e(i);
            });
        }
    } : function(b, d, e, g) {
        if (g = g || open("", "_blank"), g && (g.document.title = g.document.body.innerText = "downloading..."), "string" == typeof b) return c(b, d, e);
        var h = "application/octet-stream" === b.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((j || h && i || a) && "undefined" != typeof FileReader) {
            var k = new FileReader;
            k.onloadend = function() {
                var a = k.result;
                a = j ? a : a.replace(/^data:[^;]*;/, "data:attachment/file;"), g ? g.location.href = a : location = a, g = null;
            }, k.readAsDataURL(b);
        } else {
            var l = f.URL || f.webkitURL, m = l.createObjectURL(b);
            g ? g.location = m : location.href = m, g = null, setTimeout(function() {
                l.revokeObjectURL(m);
            }, 4E4);
        }
    });
    f.saveAs = g.saveAs = g, module.exports = g;
});

},{}],"hHQ1w":[function(require,module,exports) {
/*!
 * Chart.js v4.4.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Animation", function() {
    return Animation;
});
parcelHelpers.export(exports, "Animations", function() {
    return Animations;
});
parcelHelpers.export(exports, "ArcElement", function() {
    return ArcElement;
});
parcelHelpers.export(exports, "BarController", function() {
    return BarController;
});
parcelHelpers.export(exports, "BarElement", function() {
    return BarElement;
});
parcelHelpers.export(exports, "BasePlatform", function() {
    return BasePlatform;
});
parcelHelpers.export(exports, "BasicPlatform", function() {
    return BasicPlatform;
});
parcelHelpers.export(exports, "BubbleController", function() {
    return BubbleController;
});
parcelHelpers.export(exports, "CategoryScale", function() {
    return CategoryScale;
});
parcelHelpers.export(exports, "Chart", function() {
    return Chart;
});
parcelHelpers.export(exports, "Colors", function() {
    return plugin_colors;
});
parcelHelpers.export(exports, "DatasetController", function() {
    return DatasetController;
});
parcelHelpers.export(exports, "Decimation", function() {
    return plugin_decimation;
});
parcelHelpers.export(exports, "DomPlatform", function() {
    return DomPlatform;
});
parcelHelpers.export(exports, "DoughnutController", function() {
    return DoughnutController;
});
parcelHelpers.export(exports, "Element", function() {
    return Element;
});
parcelHelpers.export(exports, "Filler", function() {
    return index;
});
parcelHelpers.export(exports, "Interaction", function() {
    return Interaction;
});
parcelHelpers.export(exports, "Legend", function() {
    return plugin_legend;
});
parcelHelpers.export(exports, "LineController", function() {
    return LineController;
});
parcelHelpers.export(exports, "LineElement", function() {
    return LineElement;
});
parcelHelpers.export(exports, "LinearScale", function() {
    return LinearScale;
});
parcelHelpers.export(exports, "LogarithmicScale", function() {
    return LogarithmicScale;
});
parcelHelpers.export(exports, "PieController", function() {
    return PieController;
});
parcelHelpers.export(exports, "PointElement", function() {
    return PointElement;
});
parcelHelpers.export(exports, "PolarAreaController", function() {
    return PolarAreaController;
});
parcelHelpers.export(exports, "RadarController", function() {
    return RadarController;
});
parcelHelpers.export(exports, "RadialLinearScale", function() {
    return RadialLinearScale;
});
parcelHelpers.export(exports, "Scale", function() {
    return Scale;
});
parcelHelpers.export(exports, "ScatterController", function() {
    return ScatterController;
});
parcelHelpers.export(exports, "SubTitle", function() {
    return plugin_subtitle;
});
parcelHelpers.export(exports, "Ticks", function() {
    return 0, _helpersSegmentJs.aL;
});
parcelHelpers.export(exports, "TimeScale", function() {
    return TimeScale;
});
parcelHelpers.export(exports, "TimeSeriesScale", function() {
    return TimeSeriesScale;
});
parcelHelpers.export(exports, "Title", function() {
    return plugin_title;
});
parcelHelpers.export(exports, "Tooltip", function() {
    return plugin_tooltip;
});
parcelHelpers.export(exports, "_adapters", function() {
    return adapters;
});
parcelHelpers.export(exports, "_detectPlatform", function() {
    return _detectPlatform;
});
parcelHelpers.export(exports, "animator", function() {
    return animator;
});
parcelHelpers.export(exports, "controllers", function() {
    return controllers;
});
parcelHelpers.export(exports, "defaults", function() {
    return 0, _helpersSegmentJs.d;
});
parcelHelpers.export(exports, "elements", function() {
    return elements;
});
parcelHelpers.export(exports, "layouts", function() {
    return layouts;
});
parcelHelpers.export(exports, "plugins", function() {
    return plugins;
});
parcelHelpers.export(exports, "registerables", function() {
    return registerables;
});
parcelHelpers.export(exports, "registry", function() {
    return registry;
});
parcelHelpers.export(exports, "scales", function() {
    return scales;
});
var _assertThisInitialized = require("@swc/helpers/_/_assert_this_initialized");
var _classCallCheck = require("@swc/helpers/_/_class_call_check");
var _createClass = require("@swc/helpers/_/_create_class");
var _defineProperty = require("@swc/helpers/_/_define_property");
var _get = require("@swc/helpers/_/_get");
var _getPrototypeOf = require("@swc/helpers/_/_get_prototype_of");
var _inherits = require("@swc/helpers/_/_inherits");
var _objectSpread = require("@swc/helpers/_/_object_spread");
var _objectSpreadProps = require("@swc/helpers/_/_object_spread_props");
var _slicedToArray = require("@swc/helpers/_/_sliced_to_array");
var _toConsumableArray = require("@swc/helpers/_/_to_consumable_array");
var _typeOf = require("@swc/helpers/_/_type_of");
var _wrapNativeSuper = require("@swc/helpers/_/_wrap_native_super");
var _createSuper = require("@swc/helpers/_/_create_super");
var _helpersSegmentJs = require("./chunks/helpers.segment.js");
var _color = require("@kurkle/color");
var Animator = /*#__PURE__*/ function() {
    "use strict";
    function Animator() {
        (0, _classCallCheck._)(this, Animator);
        this._request = null;
        this._charts = new Map();
        this._running = false;
        this._lastDate = undefined;
    }
    (0, _createClass._)(Animator, [
        {
            key: "_notify",
            value: function _notify(chart, anims, date, type) {
                var callbacks = anims.listeners[type];
                var numSteps = anims.duration;
                callbacks.forEach(function(fn) {
                    return fn({
                        chart: chart,
                        initial: anims.initial,
                        numSteps: numSteps,
                        currentStep: Math.min(date - anims.start, numSteps)
                    });
                });
            }
        },
        {
            key: "_refresh",
            value: function _refresh() {
                var _this = this;
                if (this._request) return;
                this._running = true;
                this._request = (0, _helpersSegmentJs.r).call(window, function() {
                    _this._update();
                    _this._request = null;
                    if (_this._running) _this._refresh();
                });
            }
        },
        {
            key: "_update",
            value: function _update() {
                var date = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Date.now();
                var _this = this;
                var remaining = 0;
                this._charts.forEach(function(anims, chart) {
                    if (!anims.running || !anims.items.length) return;
                    var items = anims.items;
                    var i = items.length - 1;
                    var draw = false;
                    var item;
                    for(; i >= 0; --i){
                        item = items[i];
                        if (item._active) {
                            if (item._total > anims.duration) anims.duration = item._total;
                            item.tick(date);
                            draw = true;
                        } else {
                            items[i] = items[items.length - 1];
                            items.pop();
                        }
                    }
                    if (draw) {
                        chart.draw();
                        _this._notify(chart, anims, date, "progress");
                    }
                    if (!items.length) {
                        anims.running = false;
                        _this._notify(chart, anims, date, "complete");
                        anims.initial = false;
                    }
                    remaining += items.length;
                });
                this._lastDate = date;
                if (remaining === 0) this._running = false;
            }
        },
        {
            key: "_getAnims",
            value: function _getAnims(chart) {
                var charts = this._charts;
                var anims = charts.get(chart);
                if (!anims) {
                    anims = {
                        running: false,
                        initial: true,
                        items: [],
                        listeners: {
                            complete: [],
                            progress: []
                        }
                    };
                    charts.set(chart, anims);
                }
                return anims;
            }
        },
        {
            key: "listen",
            value: function listen(chart, event, cb) {
                this._getAnims(chart).listeners[event].push(cb);
            }
        },
        {
            key: "add",
            value: function add(chart, items) {
                var _this__getAnims_items;
                if (!items || !items.length) return;
                (_this__getAnims_items = this._getAnims(chart).items).push.apply(_this__getAnims_items, (0, _toConsumableArray._)(items));
            }
        },
        {
            key: "has",
            value: function has(chart) {
                return this._getAnims(chart).items.length > 0;
            }
        },
        {
            key: "start",
            value: function start(chart) {
                var anims = this._charts.get(chart);
                if (!anims) return;
                anims.running = true;
                anims.start = Date.now();
                anims.duration = anims.items.reduce(function(acc, cur) {
                    return Math.max(acc, cur._duration);
                }, 0);
                this._refresh();
            }
        },
        {
            key: "running",
            value: function running(chart) {
                if (!this._running) return false;
                var anims = this._charts.get(chart);
                if (!anims || !anims.running || !anims.items.length) return false;
                return true;
            }
        },
        {
            key: "stop",
            value: function stop(chart) {
                var anims = this._charts.get(chart);
                if (!anims || !anims.items.length) return;
                var items = anims.items;
                var i = items.length - 1;
                for(; i >= 0; --i)items[i].cancel();
                anims.items = [];
                this._notify(chart, anims, Date.now(), "complete");
            }
        },
        {
            key: "remove",
            value: function remove(chart) {
                return this._charts.delete(chart);
            }
        }
    ]);
    return Animator;
}();
var animator = /* #__PURE__ */ new Animator();
var transparent = "transparent";
var interpolators = {
    boolean: function(from, to, factor) {
        return factor > 0.5 ? to : from;
    },
    color: function(from, to, factor) {
        var c0 = (0, _helpersSegmentJs.c)(from || transparent);
        var c1 = c0.valid && (0, _helpersSegmentJs.c)(to || transparent);
        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
    },
    number: function(from, to, factor) {
        return from + (to - from) * factor;
    }
};
var Animation = /*#__PURE__*/ function() {
    "use strict";
    function Animation(cfg, target, prop, to) {
        (0, _classCallCheck._)(this, Animation);
        var currentValue = target[prop];
        to = (0, _helpersSegmentJs.a)([
            cfg.to,
            to,
            currentValue,
            cfg.from
        ]);
        var from = (0, _helpersSegmentJs.a)([
            cfg.from,
            currentValue,
            to
        ]);
        this._active = true;
        this._fn = cfg.fn || interpolators[cfg.type || (typeof from === "undefined" ? "undefined" : (0, _typeOf._)(from))];
        this._easing = (0, _helpersSegmentJs.e)[cfg.easing] || (0, _helpersSegmentJs.e).linear;
        this._start = Math.floor(Date.now() + (cfg.delay || 0));
        this._duration = this._total = Math.floor(cfg.duration);
        this._loop = !!cfg.loop;
        this._target = target;
        this._prop = prop;
        this._from = from;
        this._to = to;
        this._promises = undefined;
    }
    (0, _createClass._)(Animation, [
        {
            key: "active",
            value: function active() {
                return this._active;
            }
        },
        {
            key: "update",
            value: function update(cfg, to, date) {
                if (this._active) {
                    this._notify(false);
                    var currentValue = this._target[this._prop];
                    var elapsed = date - this._start;
                    var remain = this._duration - elapsed;
                    this._start = date;
                    this._duration = Math.floor(Math.max(remain, cfg.duration));
                    this._total += elapsed;
                    this._loop = !!cfg.loop;
                    this._to = (0, _helpersSegmentJs.a)([
                        cfg.to,
                        to,
                        currentValue,
                        cfg.from
                    ]);
                    this._from = (0, _helpersSegmentJs.a)([
                        cfg.from,
                        currentValue,
                        to
                    ]);
                }
            }
        },
        {
            key: "cancel",
            value: function cancel() {
                if (this._active) {
                    this.tick(Date.now());
                    this._active = false;
                    this._notify(false);
                }
            }
        },
        {
            key: "tick",
            value: function tick(date) {
                var elapsed = date - this._start;
                var duration = this._duration;
                var prop = this._prop;
                var from = this._from;
                var loop = this._loop;
                var to = this._to;
                var factor;
                this._active = from !== to && (loop || elapsed < duration);
                if (!this._active) {
                    this._target[prop] = to;
                    this._notify(true);
                    return;
                }
                if (elapsed < 0) {
                    this._target[prop] = from;
                    return;
                }
                factor = elapsed / duration % 2;
                factor = loop && factor > 1 ? 2 - factor : factor;
                factor = this._easing(Math.min(1, Math.max(0, factor)));
                this._target[prop] = this._fn(from, to, factor);
            }
        },
        {
            key: "wait",
            value: function wait() {
                var promises = this._promises || (this._promises = []);
                return new Promise(function(res, rej) {
                    promises.push({
                        res: res,
                        rej: rej
                    });
                });
            }
        },
        {
            key: "_notify",
            value: function _notify(resolved) {
                var method = resolved ? "res" : "rej";
                var promises = this._promises || [];
                for(var i = 0; i < promises.length; i++)promises[i][method]();
            }
        }
    ]);
    return Animation;
}();
var Animations = /*#__PURE__*/ function() {
    "use strict";
    function Animations(chart, config) {
        (0, _classCallCheck._)(this, Animations);
        this._chart = chart;
        this._properties = new Map();
        this.configure(config);
    }
    (0, _createClass._)(Animations, [
        {
            key: "configure",
            value: function configure(config) {
                if (!(0, _helpersSegmentJs.i)(config)) return;
                var animationOptions = Object.keys((0, _helpersSegmentJs.d).animation);
                var animatedProps = this._properties;
                Object.getOwnPropertyNames(config).forEach(function(key) {
                    var cfg = config[key];
                    if (!(0, _helpersSegmentJs.i)(cfg)) return;
                    var resolved = {};
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = animationOptions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var option = _step.value;
                            resolved[option] = cfg[option];
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    ((0, _helpersSegmentJs.b)(cfg.properties) && cfg.properties || [
                        key
                    ]).forEach(function(prop) {
                        if (prop === key || !animatedProps.has(prop)) animatedProps.set(prop, resolved);
                    });
                });
            }
        },
        {
            key: "_animateOptions",
            value: function _animateOptions(target, values) {
                var newOptions = values.options;
                var options = resolveTargetOptions(target, newOptions);
                if (!options) return [];
                var animations = this._createAnimations(options, newOptions);
                if (newOptions.$shared) awaitAll(target.options.$animations, newOptions).then(function() {
                    target.options = newOptions;
                }, function() {});
                return animations;
            }
        },
        {
            key: "_createAnimations",
            value: function _createAnimations(target, values) {
                var animatedProps = this._properties;
                var animations = [];
                var running = target.$animations || (target.$animations = {});
                var props = Object.keys(values);
                var date = Date.now();
                var i;
                for(i = props.length - 1; i >= 0; --i){
                    var prop = props[i];
                    if (prop.charAt(0) === "$") continue;
                    if (prop === "options") {
                        var _animations;
                        (_animations = animations).push.apply(_animations, (0, _toConsumableArray._)(this._animateOptions(target, values)));
                        continue;
                    }
                    var value = values[prop];
                    var animation = running[prop];
                    var cfg = animatedProps.get(prop);
                    if (animation) {
                        if (cfg && animation.active()) {
                            animation.update(cfg, value, date);
                            continue;
                        } else animation.cancel();
                    }
                    if (!cfg || !cfg.duration) {
                        target[prop] = value;
                        continue;
                    }
                    running[prop] = animation = new Animation(cfg, target, prop, value);
                    animations.push(animation);
                }
                return animations;
            }
        },
        {
            key: "update",
            value: function update(target, values) {
                if (this._properties.size === 0) {
                    Object.assign(target, values);
                    return;
                }
                var animations = this._createAnimations(target, values);
                if (animations.length) {
                    animator.add(this._chart, animations);
                    return true;
                }
            }
        }
    ]);
    return Animations;
}();
function awaitAll(animations, properties) {
    var running = [];
    var keys = Object.keys(properties);
    for(var i = 0; i < keys.length; i++){
        var anim = animations[keys[i]];
        if (anim && anim.active()) running.push(anim.wait());
    }
    return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
    if (!newOptions) return;
    var options = target.options;
    if (!options) {
        target.options = newOptions;
        return;
    }
    if (options.$shared) target.options = options = Object.assign({}, options, {
        $shared: false,
        $animations: {}
    });
    return options;
}
function scaleClip(scale, allowedOverflow) {
    var opts = scale && scale.options || {};
    var reverse = opts.reverse;
    var min = opts.min === undefined ? allowedOverflow : 0;
    var max = opts.max === undefined ? allowedOverflow : 0;
    return {
        start: reverse ? max : min,
        end: reverse ? min : max
    };
}
function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) return false;
    var x = scaleClip(xScale, allowedOverflow);
    var y = scaleClip(yScale, allowedOverflow);
    return {
        top: y.end,
        right: x.end,
        bottom: y.start,
        left: x.start
    };
}
function toClip(value) {
    var t, r, b, l;
    if ((0, _helpersSegmentJs.i)(value)) {
        t = value.top;
        r = value.right;
        b = value.bottom;
        l = value.left;
    } else t = r = b = l = value;
    return {
        top: t,
        right: r,
        bottom: b,
        left: l,
        disabled: value === false
    };
}
function getSortedDatasetIndices(chart, filterVisible) {
    var keys = [];
    var metasets = chart._getSortedDatasetMetas(filterVisible);
    var i, ilen;
    for(i = 0, ilen = metasets.length; i < ilen; ++i)keys.push(metasets[i].index);
    return keys;
}
function applyStack(stack, value, dsIndex) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var keys = stack.keys;
    var singleMode = options.mode === "single";
    var i, ilen, datasetIndex, otherValue;
    if (value === null) return;
    for(i = 0, ilen = keys.length; i < ilen; ++i){
        datasetIndex = +keys[i];
        if (datasetIndex === dsIndex) {
            if (options.all) continue;
            break;
        }
        otherValue = stack.values[datasetIndex];
        if ((0, _helpersSegmentJs.g)(otherValue) && (singleMode || value === 0 || (0, _helpersSegmentJs.s)(value) === (0, _helpersSegmentJs.s)(otherValue))) value += otherValue;
    }
    return value;
}
function convertObjectDataToArray(data) {
    var keys = Object.keys(data);
    var adata = new Array(keys.length);
    var i, ilen, key;
    for(i = 0, ilen = keys.length; i < ilen; ++i){
        key = keys[i];
        adata[i] = {
            x: key,
            y: data[key]
        };
    }
    return adata;
}
function isStacked(scale, meta) {
    var stacked = scale && scale.options.stacked;
    return stacked || stacked === undefined && meta.stack !== undefined;
}
function getStackKey(indexScale, valueScale, meta) {
    return "".concat(indexScale.id, ".").concat(valueScale.id, ".").concat(meta.stack || meta.type);
}
function getUserBounds(scale) {
    var _scale_getUserBounds = scale.getUserBounds(), min = _scale_getUserBounds.min, max = _scale_getUserBounds.max, minDefined = _scale_getUserBounds.minDefined, maxDefined = _scale_getUserBounds.maxDefined;
    return {
        min: minDefined ? min : Number.NEGATIVE_INFINITY,
        max: maxDefined ? max : Number.POSITIVE_INFINITY
    };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
    var subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = vScale.getMatchingVisibleMetas(type).reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var meta = _step.value;
            var value = stack[meta.index];
            if (positive && value > 0 || !positive && value < 0) return meta.index;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return null;
}
function updateStacks(controller, parsed) {
    var chart = controller.chart, meta = controller._cachedMeta;
    var stacks = chart._stacks || (chart._stacks = {});
    var iScale = meta.iScale, vScale = meta.vScale, datasetIndex = meta.index;
    var iAxis = iScale.axis;
    var vAxis = vScale.axis;
    var key = getStackKey(iScale, vScale, meta);
    var ilen = parsed.length;
    var stack;
    for(var i = 0; i < ilen; ++i){
        var item = parsed[i];
        var index = item[iAxis], value = item[vAxis];
        var itemStacks = item._stacks || (item._stacks = {});
        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
        stack[datasetIndex] = value;
        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
        var visualValues = stack._visualValues || (stack._visualValues = {});
        visualValues[datasetIndex] = value;
    }
}
function getFirstScaleId(chart, axis) {
    var scales = chart.scales;
    return Object.keys(scales).filter(function(key) {
        return scales[key].axis === axis;
    }).shift();
}
function createDatasetContext(parent, index) {
    return (0, _helpersSegmentJs.j)(parent, {
        active: false,
        dataset: undefined,
        datasetIndex: index,
        index: index,
        mode: "default",
        type: "dataset"
    });
}
function createDataContext(parent, index, element) {
    return (0, _helpersSegmentJs.j)(parent, {
        active: false,
        dataIndex: index,
        parsed: undefined,
        raw: undefined,
        element: element,
        index: index,
        mode: "default",
        type: "data"
    });
}
function clearStacks(meta, items) {
    var datasetIndex = meta.controller.index;
    var axis = meta.vScale && meta.vScale.axis;
    if (!axis) return;
    items = items || meta._parsed;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var parsed = _step.value;
            var stacks = parsed._stacks;
            if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) return;
            delete stacks[axis][datasetIndex];
            if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) delete stacks[axis]._visualValues[datasetIndex];
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}
var isDirectUpdateMode = function(mode) {
    return mode === "reset" || mode === "none";
};
var cloneIfNotShared = function(cached, shared) {
    return shared ? cached : Object.assign({}, cached);
};
var createStack = function(canStack, meta, chart) {
    return canStack && !meta.hidden && meta._stacked && {
        keys: getSortedDatasetIndices(chart, true),
        values: null
    };
};
var DatasetController = /*#__PURE__*/ function _target() {
    "use strict";
    function DatasetController(chart, datasetIndex) {
        (0, _classCallCheck._)(this, DatasetController);
        this.chart = chart;
        this._ctx = chart.ctx;
        this.index = datasetIndex;
        this._cachedDataOpts = {};
        this._cachedMeta = this.getMeta();
        this._type = this._cachedMeta.type;
        this.options = undefined;
        this._parsing = false;
        this._data = undefined;
        this._objectData = undefined;
        this._sharedOptions = undefined;
        this._drawStart = undefined;
        this._drawCount = undefined;
        this.enableOptionSharing = false;
        this.supportsDecimation = false;
        this.$context = undefined;
        this._syncList = [];
        this.datasetElementType = (this instanceof DatasetController ? this.constructor : void 0).datasetElementType;
        this.dataElementType = (this instanceof DatasetController ? this.constructor : void 0).dataElementType;
        this.initialize();
    }
    (0, _createClass._)(DatasetController, [
        {
            key: "initialize",
            value: function initialize() {
                var meta = this._cachedMeta;
                this.configure();
                this.linkScales();
                meta._stacked = isStacked(meta.vScale, meta);
                this.addElements();
                if (this.options.fill && !this.chart.isPluginEnabled("filler")) console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
            }
        },
        {
            key: "updateIndex",
            value: function updateIndex(datasetIndex) {
                if (this.index !== datasetIndex) clearStacks(this._cachedMeta);
                this.index = datasetIndex;
            }
        },
        {
            key: "linkScales",
            value: function linkScales() {
                var chart = this.chart;
                var meta = this._cachedMeta;
                var dataset = this.getDataset();
                var chooseId = function(axis, x, y, r) {
                    return axis === "x" ? x : axis === "r" ? r : y;
                };
                var xid = meta.xAxisID = (0, _helpersSegmentJs.v)(dataset.xAxisID, getFirstScaleId(chart, "x"));
                var yid = meta.yAxisID = (0, _helpersSegmentJs.v)(dataset.yAxisID, getFirstScaleId(chart, "y"));
                var rid = meta.rAxisID = (0, _helpersSegmentJs.v)(dataset.rAxisID, getFirstScaleId(chart, "r"));
                var indexAxis = meta.indexAxis;
                var iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
                var vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
                meta.xScale = this.getScaleForId(xid);
                meta.yScale = this.getScaleForId(yid);
                meta.rScale = this.getScaleForId(rid);
                meta.iScale = this.getScaleForId(iid);
                meta.vScale = this.getScaleForId(vid);
            }
        },
        {
            key: "getDataset",
            value: function getDataset() {
                return this.chart.data.datasets[this.index];
            }
        },
        {
            key: "getMeta",
            value: function getMeta() {
                return this.chart.getDatasetMeta(this.index);
            }
        },
        {
            key: "getScaleForId",
            value: function getScaleForId(scaleID) {
                return this.chart.scales[scaleID];
            }
        },
        {
            key: "_getOtherScale",
            value: function _getOtherScale(scale) {
                var meta = this._cachedMeta;
                return scale === meta.iScale ? meta.vScale : meta.iScale;
            }
        },
        {
            key: "reset",
            value: function reset() {
                this._update("reset");
            }
        },
        {
            key: "_destroy",
            value: function _destroy() {
                var meta = this._cachedMeta;
                if (this._data) (0, _helpersSegmentJs.u)(this._data, this);
                if (meta._stacked) clearStacks(meta);
            }
        },
        {
            key: "_dataCheck",
            value: function _dataCheck() {
                var dataset = this.getDataset();
                var data = dataset.data || (dataset.data = []);
                var _data = this._data;
                if ((0, _helpersSegmentJs.i)(data)) this._data = convertObjectDataToArray(data);
                else if (_data !== data) {
                    if (_data) {
                        (0, _helpersSegmentJs.u)(_data, this);
                        var meta = this._cachedMeta;
                        clearStacks(meta);
                        meta._parsed = [];
                    }
                    if (data && Object.isExtensible(data)) (0, _helpersSegmentJs.l)(data, this);
                    this._syncList = [];
                    this._data = data;
                }
            }
        },
        {
            key: "addElements",
            value: function addElements() {
                var meta = this._cachedMeta;
                this._dataCheck();
                if (this.datasetElementType) meta.dataset = new this.datasetElementType();
            }
        },
        {
            key: "buildOrUpdateElements",
            value: function buildOrUpdateElements(resetNewElements) {
                var meta = this._cachedMeta;
                var dataset = this.getDataset();
                var stackChanged = false;
                this._dataCheck();
                var oldStacked = meta._stacked;
                meta._stacked = isStacked(meta.vScale, meta);
                if (meta.stack !== dataset.stack) {
                    stackChanged = true;
                    clearStacks(meta);
                    meta.stack = dataset.stack;
                }
                this._resyncElements(resetNewElements);
                if (stackChanged || oldStacked !== meta._stacked) updateStacks(this, meta._parsed);
            }
        },
        {
            key: "configure",
            value: function configure() {
                var config = this.chart.config;
                var scopeKeys = config.datasetScopeKeys(this._type);
                var scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
                this.options = config.createResolver(scopes, this.getContext());
                this._parsing = this.options.parsing;
                this._cachedDataOpts = {};
            }
        },
        {
            key: "parse",
            value: function parse(start, count) {
                var _this = this, meta = _this._cachedMeta, data = _this._data;
                var iScale = meta.iScale, _stacked = meta._stacked;
                var iAxis = iScale.axis;
                var sorted = start === 0 && count === data.length ? true : meta._sorted;
                var prev = start > 0 && meta._parsed[start - 1];
                var i, cur, parsed;
                if (this._parsing === false) {
                    meta._parsed = data;
                    meta._sorted = true;
                    parsed = data;
                } else {
                    if ((0, _helpersSegmentJs.b)(data[start])) parsed = this.parseArrayData(meta, data, start, count);
                    else if ((0, _helpersSegmentJs.i)(data[start])) parsed = this.parseObjectData(meta, data, start, count);
                    else parsed = this.parsePrimitiveData(meta, data, start, count);
                    var isNotInOrderComparedToPrev = function() {
                        return cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
                    };
                    for(i = 0; i < count; ++i){
                        meta._parsed[i + start] = cur = parsed[i];
                        if (sorted) {
                            if (isNotInOrderComparedToPrev()) sorted = false;
                            prev = cur;
                        }
                    }
                    meta._sorted = sorted;
                }
                if (_stacked) updateStacks(this, parsed);
            }
        },
        {
            key: "parsePrimitiveData",
            value: function parsePrimitiveData(meta, data, start, count) {
                var iScale = meta.iScale, vScale = meta.vScale;
                var iAxis = iScale.axis;
                var vAxis = vScale.axis;
                var labels = iScale.getLabels();
                var singleScale = iScale === vScale;
                var parsed = new Array(count);
                var i, ilen, index;
                for(i = 0, ilen = count; i < ilen; ++i){
                    index = i + start;
                    var _obj;
                    parsed[i] = (_obj = {}, (0, _defineProperty._)(_obj, iAxis, singleScale || iScale.parse(labels[index], index)), (0, _defineProperty._)(_obj, vAxis, vScale.parse(data[index], index)), _obj);
                }
                return parsed;
            }
        },
        {
            key: "parseArrayData",
            value: function parseArrayData(meta, data, start, count) {
                var xScale = meta.xScale, yScale = meta.yScale;
                var parsed = new Array(count);
                var i, ilen, index, item;
                for(i = 0, ilen = count; i < ilen; ++i){
                    index = i + start;
                    item = data[index];
                    parsed[i] = {
                        x: xScale.parse(item[0], index),
                        y: yScale.parse(item[1], index)
                    };
                }
                return parsed;
            }
        },
        {
            key: "parseObjectData",
            value: function parseObjectData(meta, data, start, count) {
                var xScale = meta.xScale, yScale = meta.yScale;
                var _this__parsing = this._parsing, _this__parsing_xAxisKey = _this__parsing.xAxisKey, xAxisKey = _this__parsing_xAxisKey === void 0 ? "x" : _this__parsing_xAxisKey, _this__parsing_yAxisKey = _this__parsing.yAxisKey, yAxisKey = _this__parsing_yAxisKey === void 0 ? "y" : _this__parsing_yAxisKey;
                var parsed = new Array(count);
                var i, ilen, index, item;
                for(i = 0, ilen = count; i < ilen; ++i){
                    index = i + start;
                    item = data[index];
                    parsed[i] = {
                        x: xScale.parse((0, _helpersSegmentJs.f)(item, xAxisKey), index),
                        y: yScale.parse((0, _helpersSegmentJs.f)(item, yAxisKey), index)
                    };
                }
                return parsed;
            }
        },
        {
            key: "getParsed",
            value: function getParsed(index) {
                return this._cachedMeta._parsed[index];
            }
        },
        {
            key: "getDataElement",
            value: function getDataElement(index) {
                return this._cachedMeta.data[index];
            }
        },
        {
            key: "applyStack",
            value: function applyStack1(scale, parsed, mode) {
                var chart = this.chart;
                var meta = this._cachedMeta;
                var value = parsed[scale.axis];
                var stack = {
                    keys: getSortedDatasetIndices(chart, true),
                    values: parsed._stacks[scale.axis]._visualValues
                };
                return applyStack(stack, value, meta.index, {
                    mode: mode
                });
            }
        },
        {
            key: "updateRangeFromParsed",
            value: function updateRangeFromParsed(range, scale, parsed, stack) {
                var parsedValue = parsed[scale.axis];
                var value = parsedValue === null ? NaN : parsedValue;
                var values = stack && parsed._stacks[scale.axis];
                if (stack && values) {
                    stack.values = values;
                    value = applyStack(stack, parsedValue, this._cachedMeta.index);
                }
                range.min = Math.min(range.min, value);
                range.max = Math.max(range.max, value);
            }
        },
        {
            key: "getMinMax",
            value: function getMinMax(scale, canStack) {
                var meta = this._cachedMeta;
                var _parsed = meta._parsed;
                var sorted = meta._sorted && scale === meta.iScale;
                var ilen = _parsed.length;
                var otherScale = this._getOtherScale(scale);
                var stack = createStack(canStack, meta, this.chart);
                var range = {
                    min: Number.POSITIVE_INFINITY,
                    max: Number.NEGATIVE_INFINITY
                };
                var _getUserBounds = getUserBounds(otherScale), otherMin = _getUserBounds.min, otherMax = _getUserBounds.max;
                var i, parsed;
                function _skip() {
                    parsed = _parsed[i];
                    var otherValue = parsed[otherScale.axis];
                    return !(0, _helpersSegmentJs.g)(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
                }
                for(i = 0; i < ilen; ++i){
                    if (_skip()) continue;
                    this.updateRangeFromParsed(range, scale, parsed, stack);
                    if (sorted) break;
                }
                if (sorted) for(i = ilen - 1; i >= 0; --i){
                    if (_skip()) continue;
                    this.updateRangeFromParsed(range, scale, parsed, stack);
                    break;
                }
                return range;
            }
        },
        {
            key: "getAllParsedValues",
            value: function getAllParsedValues(scale) {
                var parsed = this._cachedMeta._parsed;
                var values = [];
                var i, ilen, value;
                for(i = 0, ilen = parsed.length; i < ilen; ++i){
                    value = parsed[i][scale.axis];
                    if ((0, _helpersSegmentJs.g)(value)) values.push(value);
                }
                return values;
            }
        },
        {
            key: "getMaxOverflow",
            value: function getMaxOverflow() {
                return false;
            }
        },
        {
            key: "getLabelAndValue",
            value: function getLabelAndValue(index) {
                var meta = this._cachedMeta;
                var iScale = meta.iScale;
                var vScale = meta.vScale;
                var parsed = this.getParsed(index);
                return {
                    label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
                    value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
                };
            }
        },
        {
            key: "_update",
            value: function _update(mode) {
                var meta = this._cachedMeta;
                this.update(mode || "default");
                meta._clip = toClip((0, _helpersSegmentJs.v)(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
            }
        },
        {
            key: "update",
            value: function update(mode) {}
        },
        {
            key: "draw",
            value: function draw() {
                var ctx = this._ctx;
                var chart = this.chart;
                var meta = this._cachedMeta;
                var elements = meta.data || [];
                var area = chart.chartArea;
                var active = [];
                var start = this._drawStart || 0;
                var count = this._drawCount || elements.length - start;
                var drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
                var i;
                if (meta.dataset) meta.dataset.draw(ctx, area, start, count);
                for(i = start; i < start + count; ++i){
                    var element = elements[i];
                    if (element.hidden) continue;
                    if (element.active && drawActiveElementsOnTop) active.push(element);
                    else element.draw(ctx, area);
                }
                for(i = 0; i < active.length; ++i)active[i].draw(ctx, area);
            }
        },
        {
            key: "getStyle",
            value: function getStyle(index, active) {
                var mode = active ? "active" : "default";
                return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
            }
        },
        {
            key: "getContext",
            value: function getContext(index, active, mode) {
                var dataset = this.getDataset();
                var context;
                if (index >= 0 && index < this._cachedMeta.data.length) {
                    var element = this._cachedMeta.data[index];
                    context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
                    context.parsed = this.getParsed(index);
                    context.raw = dataset.data[index];
                    context.index = context.dataIndex = index;
                } else {
                    context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
                    context.dataset = dataset;
                    context.index = context.datasetIndex = this.index;
                }
                context.active = !!active;
                context.mode = mode;
                return context;
            }
        },
        {
            key: "resolveDatasetElementOptions",
            value: function resolveDatasetElementOptions(mode) {
                return this._resolveElementOptions(this.datasetElementType.id, mode);
            }
        },
        {
            key: "resolveDataElementOptions",
            value: function resolveDataElementOptions(index, mode) {
                return this._resolveElementOptions(this.dataElementType.id, mode, index);
            }
        },
        {
            key: "_resolveElementOptions",
            value: function _resolveElementOptions(elementType) {
                var mode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default", index = arguments.length > 2 ? arguments[2] : void 0;
                var _this = this;
                var active = mode === "active";
                var cache = this._cachedDataOpts;
                var cacheKey = elementType + "-" + mode;
                var cached = cache[cacheKey];
                var sharing = this.enableOptionSharing && (0, _helpersSegmentJs.h)(index);
                if (cached) return cloneIfNotShared(cached, sharing);
                var config = this.chart.config;
                var scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
                var prefixes = active ? [
                    "".concat(elementType, "Hover"),
                    "hover",
                    elementType,
                    ""
                ] : [
                    elementType,
                    ""
                ];
                var scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
                var names = Object.keys((0, _helpersSegmentJs.d).elements[elementType]);
                var context = function() {
                    return _this.getContext(index, active, mode);
                };
                var values = config.resolveNamedOptions(scopes, names, context, prefixes);
                if (values.$shared) {
                    values.$shared = sharing;
                    cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
                }
                return values;
            }
        },
        {
            key: "_resolveAnimations",
            value: function _resolveAnimations(index, transition, active) {
                var chart = this.chart;
                var cache = this._cachedDataOpts;
                var cacheKey = "animation-".concat(transition);
                var cached = cache[cacheKey];
                if (cached) return cached;
                var options;
                if (chart.options.animation !== false) {
                    var config = this.chart.config;
                    var scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
                    var scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
                    options = config.createResolver(scopes, this.getContext(index, active, transition));
                }
                var animations = new Animations(chart, options && options.animations);
                if (options && options._cacheable) cache[cacheKey] = Object.freeze(animations);
                return animations;
            }
        },
        {
            key: "getSharedOptions",
            value: function getSharedOptions(options) {
                if (!options.$shared) return;
                return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
            }
        },
        {
            key: "includeOptions",
            value: function includeOptions(mode, sharedOptions) {
                return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
            }
        },
        {
            key: "_getSharedOptions",
            value: function _getSharedOptions(start, mode) {
                var firstOpts = this.resolveDataElementOptions(start, mode);
                var previouslySharedOptions = this._sharedOptions;
                var sharedOptions = this.getSharedOptions(firstOpts);
                var includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
                this.updateSharedOptions(sharedOptions, mode, firstOpts);
                return {
                    sharedOptions: sharedOptions,
                    includeOptions: includeOptions
                };
            }
        },
        {
            key: "updateElement",
            value: function updateElement(element, index, properties, mode) {
                if (isDirectUpdateMode(mode)) Object.assign(element, properties);
                else this._resolveAnimations(index, mode).update(element, properties);
            }
        },
        {
            key: "updateSharedOptions",
            value: function updateSharedOptions(sharedOptions, mode, newOptions) {
                if (sharedOptions && !isDirectUpdateMode(mode)) this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
            }
        },
        {
            key: "_setStyle",
            value: function _setStyle(element, index, mode, active) {
                element.active = active;
                var options = this.getStyle(index, active);
                this._resolveAnimations(index, mode, active).update(element, {
                    options: !active && this.getSharedOptions(options) || options
                });
            }
        },
        {
            key: "removeHoverStyle",
            value: function removeHoverStyle(element, datasetIndex, index) {
                this._setStyle(element, index, "active", false);
            }
        },
        {
            key: "setHoverStyle",
            value: function setHoverStyle(element, datasetIndex, index) {
                this._setStyle(element, index, "active", true);
            }
        },
        {
            key: "_removeDatasetHoverStyle",
            value: function _removeDatasetHoverStyle() {
                var element = this._cachedMeta.dataset;
                if (element) this._setStyle(element, undefined, "active", false);
            }
        },
        {
            key: "_setDatasetHoverStyle",
            value: function _setDatasetHoverStyle() {
                var element = this._cachedMeta.dataset;
                if (element) this._setStyle(element, undefined, "active", true);
            }
        },
        {
            key: "_resyncElements",
            value: function _resyncElements(resetNewElements) {
                var data = this._data;
                var elements = this._cachedMeta.data;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this._syncList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _step_value = (0, _slicedToArray._)(_step.value, 3), method = _step_value[0], arg1 = _step_value[1], arg2 = _step_value[2];
                        this[method](arg1, arg2);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                this._syncList = [];
                var numMeta = elements.length;
                var numData = data.length;
                var count = Math.min(numData, numMeta);
                if (count) this.parse(0, count);
                if (numData > numMeta) this._insertElements(numMeta, numData - numMeta, resetNewElements);
                else if (numData < numMeta) this._removeElements(numData, numMeta - numData);
            }
        },
        {
            key: "_insertElements",
            value: function _insertElements(start, count) {
                var resetNewElements = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
                var meta = this._cachedMeta;
                var data = meta.data;
                var end = start + count;
                var i;
                var move = function(arr) {
                    arr.length += count;
                    for(i = arr.length - 1; i >= end; i--)arr[i] = arr[i - count];
                };
                move(data);
                for(i = start; i < end; ++i)data[i] = new this.dataElementType();
                if (this._parsing) move(meta._parsed);
                this.parse(start, count);
                if (resetNewElements) this.updateElements(data, start, count, "reset");
            }
        },
        {
            key: "updateElements",
            value: function updateElements(element, start, count, mode) {}
        },
        {
            key: "_removeElements",
            value: function _removeElements(start, count) {
                var meta = this._cachedMeta;
                if (this._parsing) {
                    var removed = meta._parsed.splice(start, count);
                    if (meta._stacked) clearStacks(meta, removed);
                }
                meta.data.splice(start, count);
            }
        },
        {
            key: "_sync",
            value: function _sync(args) {
                if (this._parsing) this._syncList.push(args);
                else {
                    var _args = (0, _slicedToArray._)(args, 3), method = _args[0], arg1 = _args[1], arg2 = _args[2];
                    this[method](arg1, arg2);
                }
                this.chart._dataChanges.push([
                    this.index
                ].concat((0, _toConsumableArray._)(args)));
            }
        },
        {
            key: "_onDataPush",
            value: function _onDataPush() {
                var count = arguments.length;
                this._sync([
                    "_insertElements",
                    this.getDataset().data.length - count,
                    count
                ]);
            }
        },
        {
            key: "_onDataPop",
            value: function _onDataPop() {
                this._sync([
                    "_removeElements",
                    this._cachedMeta.data.length - 1,
                    1
                ]);
            }
        },
        {
            key: "_onDataShift",
            value: function _onDataShift() {
                this._sync([
                    "_removeElements",
                    0,
                    1
                ]);
            }
        },
        {
            key: "_onDataSplice",
            value: function _onDataSplice(start, count) {
                if (count) this._sync([
                    "_removeElements",
                    start,
                    count
                ]);
                var newCount = arguments.length - 2;
                if (newCount) this._sync([
                    "_insertElements",
                    start,
                    newCount
                ]);
            }
        },
        {
            key: "_onDataUnshift",
            value: function _onDataUnshift() {
                this._sync([
                    "_insertElements",
                    0,
                    arguments.length
                ]);
            }
        }
    ]);
    return DatasetController;
}();
(0, _defineProperty._)(DatasetController, "defaults", {});
(0, _defineProperty._)(DatasetController, "datasetElementType", null);
(0, _defineProperty._)(DatasetController, "dataElementType", null);
function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
        var visibleMetas = scale.getMatchingVisibleMetas(type);
        var values = [];
        for(var i = 0, ilen = visibleMetas.length; i < ilen; i++)values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
        scale._cache.$bar = (0, _helpersSegmentJs._)(values.sort(function(a, b) {
            return a - b;
        }));
    }
    return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
    var scale = meta.iScale;
    var values = getAllScaleValues(scale, meta.type);
    var min = scale._length;
    var i, ilen, curr, prev;
    var updateMinAndPrev = function() {
        if (curr === 32767 || curr === -32768) return;
        if ((0, _helpersSegmentJs.h)(prev)) min = Math.min(min, Math.abs(curr - prev) || min);
        prev = curr;
    };
    for(i = 0, ilen = values.length; i < ilen; ++i){
        curr = scale.getPixelForValue(values[i]);
        updateMinAndPrev();
    }
    prev = undefined;
    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){
        curr = scale.getPixelForTick(i);
        updateMinAndPrev();
    }
    return min;
}
function computeFitCategoryTraits(index, ruler, options, stackCount) {
    var thickness = options.barThickness;
    var size, ratio;
    if ((0, _helpersSegmentJs.k)(thickness)) {
        size = ruler.min * options.categoryPercentage;
        ratio = options.barPercentage;
    } else {
        size = thickness * stackCount;
        ratio = 1;
    }
    return {
        chunk: size / stackCount,
        ratio: ratio,
        start: ruler.pixels[index] - size / 2
    };
}
function computeFlexCategoryTraits(index, ruler, options, stackCount) {
    var pixels = ruler.pixels;
    var curr = pixels[index];
    var prev = index > 0 ? pixels[index - 1] : null;
    var next = index < pixels.length - 1 ? pixels[index + 1] : null;
    var percent = options.categoryPercentage;
    if (prev === null) prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    if (next === null) next = curr + curr - prev;
    var start = curr - (curr - Math.min(prev, next)) / 2 * percent;
    var size = Math.abs(next - prev) / 2 * percent;
    return {
        chunk: size / stackCount,
        ratio: options.barPercentage,
        start: start
    };
}
function parseFloatBar(entry, item, vScale, i) {
    var startValue = vScale.parse(entry[0], i);
    var endValue = vScale.parse(entry[1], i);
    var min = Math.min(startValue, endValue);
    var max = Math.max(startValue, endValue);
    var barStart = min;
    var barEnd = max;
    if (Math.abs(min) > Math.abs(max)) {
        barStart = max;
        barEnd = min;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
        barStart: barStart,
        barEnd: barEnd,
        start: startValue,
        end: endValue,
        min: min,
        max: max
    };
}
function parseValue(entry, item, vScale, i) {
    if ((0, _helpersSegmentJs.b)(entry)) parseFloatBar(entry, item, vScale, i);
    else item[vScale.axis] = vScale.parse(entry, i);
    return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
    var iScale = meta.iScale;
    var vScale = meta.vScale;
    var labels = iScale.getLabels();
    var singleScale = iScale === vScale;
    var parsed = [];
    var i, ilen, item, entry;
    for(i = start, ilen = start + count; i < ilen; ++i){
        entry = data[i];
        item = {};
        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
        parsed.push(parseValue(entry, item, vScale, i));
    }
    return parsed;
}
function isFloatBar(custom) {
    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
}
function barSign(size, vScale, actualBase) {
    if (size !== 0) return (0, _helpersSegmentJs.s)(size);
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
    var reverse, start, end, top, bottom;
    if (properties.horizontal) {
        reverse = properties.base > properties.x;
        start = "left";
        end = "right";
    } else {
        reverse = properties.base < properties.y;
        start = "bottom";
        end = "top";
    }
    if (reverse) {
        top = "end";
        bottom = "start";
    } else {
        top = "start";
        bottom = "end";
    }
    return {
        start: start,
        end: end,
        reverse: reverse,
        top: top,
        bottom: bottom
    };
}
function setBorderSkipped(properties, options, stack, index) {
    var edge = options.borderSkipped;
    var res = {};
    if (!edge) {
        properties.borderSkipped = res;
        return;
    }
    if (edge === true) {
        properties.borderSkipped = {
            top: true,
            right: true,
            bottom: true,
            left: true
        };
        return;
    }
    var _borderProps = borderProps(properties), start = _borderProps.start, end = _borderProps.end, reverse = _borderProps.reverse, top = _borderProps.top, bottom = _borderProps.bottom;
    if (edge === "middle" && stack) {
        properties.enableBorderRadius = true;
        if ((stack._top || 0) === index) edge = top;
        else if ((stack._bottom || 0) === index) edge = bottom;
        else {
            res[parseEdge(bottom, start, end, reverse)] = true;
            edge = top;
        }
    }
    res[parseEdge(edge, start, end, reverse)] = true;
    properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
    if (reverse) {
        edge = swap(edge, a, b);
        edge = startEnd(edge, b, a);
    } else edge = startEnd(edge, a, b);
    return edge;
}
function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
    return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, param, ratio) {
    var inflateAmount = param.inflateAmount;
    properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = /*#__PURE__*/ function(DatasetController) {
    "use strict";
    (0, _inherits._)(BarController, DatasetController);
    var _super = (0, _createSuper._)(BarController);
    function BarController() {
        (0, _classCallCheck._)(this, BarController);
        return _super.apply(this, arguments);
    }
    (0, _createClass._)(BarController, [
        {
            key: "parsePrimitiveData",
            value: function parsePrimitiveData(meta, data, start, count) {
                return parseArrayOrPrimitive(meta, data, start, count);
            }
        },
        {
            key: "parseArrayData",
            value: function parseArrayData(meta, data, start, count) {
                return parseArrayOrPrimitive(meta, data, start, count);
            }
        },
        {
            key: "parseObjectData",
            value: function parseObjectData(meta, data, start, count) {
                var iScale = meta.iScale, vScale = meta.vScale;
                var _this__parsing = this._parsing, _this__parsing_xAxisKey = _this__parsing.xAxisKey, xAxisKey = _this__parsing_xAxisKey === void 0 ? "x" : _this__parsing_xAxisKey, _this__parsing_yAxisKey = _this__parsing.yAxisKey, yAxisKey = _this__parsing_yAxisKey === void 0 ? "y" : _this__parsing_yAxisKey;
                var iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
                var vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
                var parsed = [];
                var i, ilen, item, obj;
                for(i = start, ilen = start + count; i < ilen; ++i){
                    obj = data[i];
                    item = {};
                    item[iScale.axis] = iScale.parse((0, _helpersSegmentJs.f)(obj, iAxisKey), i);
                    parsed.push(parseValue((0, _helpersSegmentJs.f)(obj, vAxisKey), item, vScale, i));
                }
                return parsed;
            }
        },
        {
            key: "updateRangeFromParsed",
            value: function updateRangeFromParsed(range, scale, parsed, stack) {
                (0, _get._)((0, _getPrototypeOf._)(BarController.prototype), "updateRangeFromParsed", this).call(this, range, scale, parsed, stack);
                var custom = parsed._custom;
                if (custom && scale === this._cachedMeta.vScale) {
                    range.min = Math.min(range.min, custom.min);
                    range.max = Math.max(range.max, custom.max);
                }
            }
        },
        {
            key: "getMaxOverflow",
            value: function getMaxOverflow() {
                return 0;
            }
        },
        {
            key: "getLabelAndValue",
            value: function getLabelAndValue(index) {
                var meta = this._cachedMeta;
                var iScale = meta.iScale, vScale = meta.vScale;
                var parsed = this.getParsed(index);
                var custom = parsed._custom;
                var value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
                return {
                    label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
                    value: value
                };
            }
        },
        {
            key: "initialize",
            value: function initialize() {
                this.enableOptionSharing = true;
                (0, _get._)((0, _getPrototypeOf._)(BarController.prototype), "initialize", this).call(this);
                var meta = this._cachedMeta;
                meta.stack = this.getDataset().stack;
            }
        },
        {
            key: "update",
            value: function update(mode) {
                var meta = this._cachedMeta;
                this.updateElements(meta.data, 0, meta.data.length, mode);
            }
        },
        {
            key: "updateElements",
            value: function updateElements(bars, start, count, mode) {
                var reset = mode === "reset";
                var _this = this, index = _this.index, vScale = _this._cachedMeta.vScale;
                var base = vScale.getBasePixel();
                var horizontal = vScale.isHorizontal();
                var ruler = this._getRuler();
                var _this__getSharedOptions = this._getSharedOptions(start, mode), sharedOptions = _this__getSharedOptions.sharedOptions, includeOptions = _this__getSharedOptions.includeOptions;
                for(var i = start; i < start + count; i++){
                    var parsed = this.getParsed(i);
                    var vpixels = reset || (0, _helpersSegmentJs.k)(parsed[vScale.axis]) ? {
                        base: base,
                        head: base
                    } : this._calculateBarValuePixels(i);
                    var ipixels = this._calculateBarIndexPixels(i, ruler);
                    var stack = (parsed._stacks || {})[vScale.axis];
                    var properties = {
                        horizontal: horizontal,
                        base: vpixels.base,
                        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
                        x: horizontal ? vpixels.head : ipixels.center,
                        y: horizontal ? ipixels.center : vpixels.head,
                        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
                    };
                    if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
                    var options = properties.options || bars[i].options;
                    setBorderSkipped(properties, options, stack, index);
                    setInflateAmount(properties, options, ruler.ratio);
                    this.updateElement(bars[i], i, properties, mode);
                }
            }
        },
        {
            key: "_getStacks",
            value: function _getStacks(last, dataIndex) {
                var iScale = this._cachedMeta.iScale;
                var metasets = iScale.getMatchingVisibleMetas(this._type).filter(function(meta) {
                    return meta.controller.options.grouped;
                });
                var stacked = iScale.options.stacked;
                var stacks = [];
                var skipNull = function(meta) {
                    var parsed = meta.controller.getParsed(dataIndex);
                    var val = parsed && parsed[meta.vScale.axis];
                    if ((0, _helpersSegmentJs.k)(val) || isNaN(val)) return true;
                };
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = metasets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var meta = _step.value;
                        if (dataIndex !== undefined && skipNull(meta)) continue;
                        if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) stacks.push(meta.stack);
                        if (meta.index === last) break;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                if (!stacks.length) stacks.push(undefined);
                return stacks;
            }
        },
        {
            key: "_getStackCount",
            value: function _getStackCount(index) {
                return this._getStacks(undefined, index).length;
            }
        },
        {
            key: "_getStackIndex",
            value: function _getStackIndex(datasetIndex, name, dataIndex) {
                var stacks = this._getStacks(datasetIndex, dataIndex);
                var index = name !== undefined ? stacks.indexOf(name) : -1;
                return index === -1 ? stacks.length - 1 : index;
            }
        },
        {
            key: "_getRuler",
            value: function _getRuler() {
                var opts = this.options;
                var meta = this._cachedMeta;
                var iScale = meta.iScale;
                var pixels = [];
                var i, ilen;
                for(i = 0, ilen = meta.data.length; i < ilen; ++i)pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
                var barThickness = opts.barThickness;
                var min = barThickness || computeMinSampleSize(meta);
                return {
                    min: min,
                    pixels: pixels,
                    start: iScale._startPixel,
                    end: iScale._endPixel,
                    stackCount: this._getStackCount(),
                    scale: iScale,
                    grouped: opts.grouped,
                    ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
                };
            }
        },
        {
            key: "_calculateBarValuePixels",
            value: function _calculateBarValuePixels(index) {
                var _this = this, _this__cachedMeta = _this._cachedMeta, vScale = _this__cachedMeta.vScale, _stacked = _this__cachedMeta._stacked, datasetIndex = _this__cachedMeta.index, _this_options = _this.options, baseValue = _this_options.base, minBarLength = _this_options.minBarLength;
                var actualBase = baseValue || 0;
                var parsed = this.getParsed(index);
                var custom = parsed._custom;
                var floating = isFloatBar(custom);
                var value = parsed[vScale.axis];
                var start = 0;
                var length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
                var head, size;
                if (length !== value) {
                    start = length - value;
                    length = value;
                }
                if (floating) {
                    value = custom.barStart;
                    length = custom.barEnd - custom.barStart;
                    if (value !== 0 && (0, _helpersSegmentJs.s)(value) !== (0, _helpersSegmentJs.s)(custom.barEnd)) start = 0;
                    start += value;
                }
                var startValue = !(0, _helpersSegmentJs.k)(baseValue) && !floating ? baseValue : start;
                var base = vScale.getPixelForValue(startValue);
                if (this.chart.getDataVisibility(index)) head = vScale.getPixelForValue(start + length);
                else head = base;
                size = head - base;
                if (Math.abs(size) < minBarLength) {
                    size = barSign(size, vScale, actualBase) * minBarLength;
                    if (value === actualBase) base -= size / 2;
                    var startPixel = vScale.getPixelForDecimal(0);
                    var endPixel = vScale.getPixelForDecimal(1);
                    var min = Math.min(startPixel, endPixel);
                    var max = Math.max(startPixel, endPixel);
                    base = Math.max(Math.min(base, max), min);
                    head = base + size;
                    if (_stacked && !floating) parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
                }
                if (base === vScale.getPixelForValue(actualBase)) {
                    var halfGrid = (0, _helpersSegmentJs.s)(size) * vScale.getLineWidthForValue(actualBase) / 2;
                    base += halfGrid;
                    size -= halfGrid;
                }
                return {
                    size: size,
                    base: base,
                    head: head,
                    center: head + size / 2
                };
            }
        },
        {
            key: "_calculateBarIndexPixels",
            value: function _calculateBarIndexPixels(index, ruler) {
                var scale = ruler.scale;
                var options = this.options;
                var skipNull = options.skipNull;
                var maxBarThickness = (0, _helpersSegmentJs.v)(options.maxBarThickness, Infinity);
                var center, size;
                if (ruler.grouped) {
                    var stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
                    var range = options.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
                    var stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);
                    center = range.start + range.chunk * stackIndex + range.chunk / 2;
                    size = Math.min(maxBarThickness, range.chunk * range.ratio);
                } else {
                    center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
                    size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
                }
                return {
                    base: center - size / 2,
                    head: center + size / 2,
                    center: center,
                    size: size
                };
            }
        },
        {
            key: "draw",
            value: function draw() {
                var meta = this._cachedMeta;
                var vScale = meta.vScale;
                var rects = meta.data;
                var ilen = rects.length;
                var i = 0;
                for(; i < ilen; ++i)if (this.getParsed(i)[vScale.axis] !== null) rects[i].draw(this._ctx);
            }
        }
    ]);
    return BarController;
}(DatasetController);
(0, _defineProperty._)(BarController, "id", "bar");
(0, _defineProperty._)(BarController, "defaults", {
    datasetElementType: false,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
        numbers: {
            type: "number",
            properties: [
                "x",
                "y",
                "base",
                "width",
                "height"
            ]
        }
    }
});
(0, _defineProperty._)(BarController, "overrides", {
    scales: {
        _index_: {
            type: "category",
            offset: true,
            grid: {
                offset: true
            }
        },
        _value_: {
            type: "linear",
            beginAtZero: true
        }
    }
});
var BubbleController = /*#__PURE__*/ function(DatasetController) {
    "use strict";
    (0, _inherits._)(BubbleController, DatasetController);
    var _super = (0, _createSuper._)(BubbleController);
    function BubbleController() {
        (0, _classCallCheck._)(this, BubbleController);
        return _super.apply(this, arguments);
    }
    (0, _createClass._)(BubbleController, [
        {
            key: "initialize",
            value: function initialize() {
                this.enableOptionSharing = true;
                (0, _get._)((0, _getPrototypeOf._)(BubbleController.prototype), "initialize", this).call(this);
            }
        },
        {
            key: "parsePrimitiveData",
            value: function parsePrimitiveData(meta, data, start, count) {
                var parsed = (0, _get._)((0, _getPrototypeOf._)(BubbleController.prototype), "parsePrimitiveData", this).call(this, meta, data, start, count);
                for(var i = 0; i < parsed.length; i++)parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
                return parsed;
            }
        },
        {
            key: "parseArrayData",
            value: function parseArrayData(meta, data, start, count) {
                var parsed = (0, _get._)((0, _getPrototypeOf._)(BubbleController.prototype), "parseArrayData", this).call(this, meta, data, start, count);
                for(var i = 0; i < parsed.length; i++){
                    var item = data[start + i];
                    parsed[i]._custom = (0, _helpersSegmentJs.v)(item[2], this.resolveDataElementOptions(i + start).radius);
                }
                return parsed;
            }
        },
        {
            key: "parseObjectData",
            value: function parseObjectData(meta, data, start, count) {
                var parsed = (0, _get._)((0, _getPrototypeOf._)(BubbleController.prototype), "parseObjectData", this).call(this, meta, data, start, count);
                for(var i = 0; i < parsed.length; i++){
                    var item = data[start + i];
                    parsed[i]._custom = (0, _helpersSegmentJs.v)(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
                }
                return parsed;
            }
        },
        {
            key: "getMaxOverflow",
            value: function getMaxOverflow() {
                var data = this._cachedMeta.data;
                var max = 0;
                for(var i = data.length - 1; i >= 0; --i)max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
                return max > 0 && max;
            }
        },
        {
            key: "getLabelAndValue",
            value: function getLabelAndValue(index) {
                var meta = this._cachedMeta;
                var labels = this.chart.data.labels || [];
                var xScale = meta.xScale, yScale = meta.yScale;
                var parsed = this.getParsed(index);
                var x = xScale.getLabelForValue(parsed.x);
                var y = yScale.getLabelForValue(parsed.y);
                var r = parsed._custom;
                return {
                    label: labels[index] || "",
                    value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
                };
            }
        },
        {
            key: "update",
            value: function update(mode) {
                var points = this._cachedMeta.data;
                this.updateElements(points, 0, points.length, mode);
            }
        },
        {
            key: "updateElements",
            value: function updateElements(points, start, count, mode) {
                var reset = mode === "reset";
                var _this__cachedMeta = this._cachedMeta, iScale = _this__cachedMeta.iScale, vScale = _this__cachedMeta.vScale;
                var _this__getSharedOptions = this._getSharedOptions(start, mode), sharedOptions = _this__getSharedOptions.sharedOptions, includeOptions = _this__getSharedOptions.includeOptions;
                var iAxis = iScale.axis;
                var vAxis = vScale.axis;
                for(var i = start; i < start + count; i++){
                    var point = points[i];
                    var parsed = !reset && this.getParsed(i);
                    var properties = {};
                    var iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
                    var vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
                    properties.skip = isNaN(iPixel) || isNaN(vPixel);
                    if (includeOptions) {
                        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
                        if (reset) properties.options.radius = 0;
                    }
                    this.updateElement(point, i, properties, mode);
                }
            }
        },
        {
            key: "resolveDataElementOptions",
            value: function resolveDataElementOptions(index, mode) {
                var parsed = this.getParsed(index);
                var values = (0, _get._)((0, _getPrototypeOf._)(BubbleController.prototype), "resolveDataElementOptions", this).call(this, index, mode);
                if (values.$shared) values = Object.assign({}, values, {
                    $shared: false
                });
                var radius = values.radius;
                if (mode !== "active") values.radius = 0;
                values.radius += (0, _helpersSegmentJs.v)(parsed && parsed._custom, radius);
                return values;
            }
        }
    ]);
    return BubbleController;
}(DatasetController);
(0, _defineProperty._)(BubbleController, "id", "bubble");
(0, _defineProperty._)(BubbleController, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    animations: {
        numbers: {
            type: "number",
            properties: [
                "x",
                "y",
                "borderWidth",
                "radius"
            ]
        }
    }
});
(0, _defineProperty._)(BubbleController, "overrides", {
    scales: {
        x: {
            type: "linear"
        },
        y: {
            type: "linear"
        }
    }
});
function getRatioAndOffset(rotation, circumference, cutout) {
    var ratioX = 1;
    var ratioY = 1;
    var offsetX = 0;
    var offsetY = 0;
    if (circumference < (0, _helpersSegmentJs.T)) {
        var startAngle = rotation;
        var endAngle = startAngle + circumference;
        var startX = Math.cos(startAngle);
        var startY = Math.sin(startAngle);
        var endX = Math.cos(endAngle);
        var endY = Math.sin(endAngle);
        var calcMax = function(angle, a, b) {
            return (0, _helpersSegmentJs.p)(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
        };
        var calcMin = function(angle, a, b) {
            return (0, _helpersSegmentJs.p)(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
        };
        var maxX = calcMax(0, startX, endX);
        var maxY = calcMax((0, _helpersSegmentJs.H), startY, endY);
        var minX = calcMin((0, _helpersSegmentJs.P), startX, endX);
        var minY = calcMin((0, _helpersSegmentJs.P) + (0, _helpersSegmentJs.H), startY, endY);
        ratioX = (maxX - minX) / 2;
        ratioY = (maxY - minY) / 2;
        offsetX = -(maxX + minX) / 2;
        offsetY = -(maxY + minY) / 2;
    }
    return {
        ratioX: ratioX,
        ratioY: ratioY,
        offsetX: offsetX,
        offsetY: offsetY
    };
}
var DoughnutController = /*#__PURE__*/ function(DatasetController) {
    "use strict";
    (0, _inherits._)(DoughnutController, DatasetController);
    var _super = (0, _createSuper._)(DoughnutController);
    function DoughnutController(chart, datasetIndex) {
        (0, _classCallCheck._)(this, DoughnutController);
        var _this;
        _this = _super.call(this, chart, datasetIndex);
        _this.enableOptionSharing = true;
        _this.innerRadius = undefined;
        _this.outerRadius = undefined;
        _this.offsetX = undefined;
        _this.offsetY = undefined;
        return _this;
    }
    (0, _createClass._)(DoughnutController, [
        {
            key: "linkScales",
            value: function linkScales() {}
        },
        {
            key: "parse",
            value: function parse(start, count) {
                var data = this.getDataset().data;
                var meta = this._cachedMeta;
                if (this._parsing === false) meta._parsed = data;
                else {
                    var getter = function(i) {
                        return +data[i];
                    };
                    if ((0, _helpersSegmentJs.i)(data[start])) {
                        var _this__parsing = this._parsing, _this__parsing_key = _this__parsing.key, key = _this__parsing_key === void 0 ? "value" : _this__parsing_key;
                        getter = function(i) {
                            return +(0, _helpersSegmentJs.f)(data[i], key);
                        };
                    }
                    var i, ilen;
                    for(i = start, ilen = start + count; i < ilen; ++i)meta._parsed[i] = getter(i);
                }
            }
        },
        {
            key: "_getRotation",
            value: function _getRotation() {
                return (0, _helpersSegmentJs.t)(this.options.rotation - 90);
            }
        },
        {
            key: "_getCircumference",
            value: function _getCircumference() {
                return (0, _helpersSegmentJs.t)(this.options.circumference);
            }
        },
        {
            key: "_getRotationExtents",
            value: function _getRotationExtents() {
                var min = (0, _helpersSegmentJs.T);
                var max = -(0, _helpersSegmentJs.T);
                for(var i = 0; i < this.chart.data.datasets.length; ++i)if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
                    var controller = this.chart.getDatasetMeta(i).controller;
                    var rotation = controller._getRotation();
                    var circumference = controller._getCircumference();
                    min = Math.min(min, rotation);
                    max = Math.max(max, rotation + circumference);
                }
                return {
                    rotation: min,
                    circumference: max - min
                };
            }
        },
        {
            key: "update",
            value: function update(mode) {
                var chart = this.chart;
                var chartArea = chart.chartArea;
                var meta = this._cachedMeta;
                var arcs = meta.data;
                var spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
                var maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
                var cutout = Math.min((0, _helpersSegmentJs.m)(this.options.cutout, maxSize), 1);
                var chartWeight = this._getRingWeight(this.index);
                var _this__getRotationExtents = this._getRotationExtents(), circumference = _this__getRotationExtents.circumference, rotation = _this__getRotationExtents.rotation;
                var _getRatioAndOffset = getRatioAndOffset(rotation, circumference, cutout), ratioX = _getRatioAndOffset.ratioX, ratioY = _getRatioAndOffset.ratioY, offsetX = _getRatioAndOffset.offsetX, offsetY = _getRatioAndOffset.offsetY;
                var maxWidth = (chartArea.width - spacing) / ratioX;
                var maxHeight = (chartArea.height - spacing) / ratioY;
                var maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
                var outerRadius = (0, _helpersSegmentJs.n)(this.options.radius, maxRadius);
                var innerRadius = Math.max(outerRadius * cutout, 0);
                var radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
                this.offsetX = offsetX * outerRadius;
                this.offsetY = offsetY * outerRadius;
                meta.total = this.calculateTotal();
                this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
                this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
                this.updateElements(arcs, 0, arcs.length, mode);
            }
        },
        {
            key: "_circumference",
            value: function _circumference(i, reset) {
                var opts = this.options;
                var meta = this._cachedMeta;
                var circumference = this._getCircumference();
                if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) return 0;
                return this.calculateCircumference(meta._parsed[i] * circumference / (0, _helpersSegmentJs.T));
            }
        },
        {
            key: "updateElements",
            value: function updateElements(arcs, start, count, mode) {
                var reset = mode === "reset";
                var chart = this.chart;
                var chartArea = chart.chartArea;
                var opts = chart.options;
                var animationOpts = opts.animation;
                var centerX = (chartArea.left + chartArea.right) / 2;
                var centerY = (chartArea.top + chartArea.bottom) / 2;
                var animateScale = reset && animationOpts.animateScale;
                var innerRadius = animateScale ? 0 : this.innerRadius;
                var outerRadius = animateScale ? 0 : this.outerRadius;
                var _this__getSharedOptions = this._getSharedOptions(start, mode), sharedOptions = _this__getSharedOptions.sharedOptions, includeOptions = _this__getSharedOptions.includeOptions;
                var startAngle = this._getRotation();
                var i;
                for(i = 0; i < start; ++i)startAngle += this._circumference(i, reset);
                for(i = start; i < start + count; ++i){
                    var circumference = this._circumference(i, reset);
                    var arc = arcs[i];
                    var properties = {
                        x: centerX + this.offsetX,
                        y: centerY + this.offsetY,
                        startAngle: startAngle,
                        endAngle: startAngle + circumference,
                        circumference: circumference,
                        outerRadius: outerRadius,
                        innerRadius: innerRadius
                    };
                    if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
                    startAngle += circumference;
                    this.updateElement(arc, i, properties, mode);
                }
            }
        },
        {
            key: "calculateTotal",
            value: function calculateTotal() {
                var meta = this._cachedMeta;
                var metaData = meta.data;
                var total = 0;
                var i;
                for(i = 0; i < metaData.length; i++){
                    var value = meta._parsed[i];
                    if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) total += Math.abs(value);
                }
                return total;
            }
        },
        {
            key: "calculateCircumference",
            value: function calculateCircumference(value) {
                var total = this._cachedMeta.total;
                if (total > 0 && !isNaN(value)) return (0, _helpersSegmentJs.T) * (Math.abs(value) / total);
                return 0;
            }
        },
        {
            key: "getLabelAndValue",
            value: function getLabelAndValue(index) {
                var meta = this._cachedMeta;
                var chart = this.chart;
                var labels = chart.data.labels || [];
                var value = (0, _helpersSegmentJs.o)(meta._parsed[index], chart.options.locale);
                return {
                    label: labels[index] || "",
                    value: value
                };
            }
        },
        {
            key: "getMaxBorderWidth",
            value: function getMaxBorderWidth(arcs) {
                var max = 0;
                var chart = this.chart;
                var i, ilen, meta, controller, options;
                if (!arcs) {
                    for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i)if (chart.isDatasetVisible(i)) {
                        meta = chart.getDatasetMeta(i);
                        arcs = meta.data;
                        controller = meta.controller;
                        break;
                    }
                }
                if (!arcs) return 0;
                for(i = 0, ilen = arcs.length; i < ilen; ++i){
                    options = controller.resolveDataElementOptions(i);
                    if (options.borderAlign !== "inner") max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
                }
                return max;
            }
        },
        {
            key: "getMaxOffset",
            value: function getMaxOffset(arcs) {
                var max = 0;
                for(var i = 0, ilen = arcs.length; i < ilen; ++i){
                    var options = this.resolveDataElementOptions(i);
                    max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
                }
                return max;
            }
        },
        {
            key: "_getRingWeightOffset",
            value: function _getRingWeightOffset(datasetIndex) {
                var ringWeightOffset = 0;
                for(var i = 0; i < datasetIndex; ++i)if (this.chart.isDatasetVisible(i)) ringWeightOffset += this._getRingWeight(i);
                return ringWeightOffset;
            }
        },
        {
            key: "_getRingWeight",
            value: function _getRingWeight(datasetIndex) {
                return Math.max((0, _helpersSegmentJs.v)(this.chart.data.datasets[datasetIndex].weight, 1), 0);
            }
        },
        {
            key: "_getVisibleDatasetWeightTotal",
            value: function _getVisibleDatasetWeightTotal() {
                return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
            }
        }
    ]);
    return DoughnutController;
}(DatasetController);
(0, _defineProperty._)(DoughnutController, "id", "doughnut");
(0, _defineProperty._)(DoughnutController, "defaults", {
    datasetElementType: false,
    dataElementType: "arc",
    animation: {
        animateRotate: true,
        animateScale: false
    },
    animations: {
        numbers: {
            type: "number",
            properties: [
                "circumference",
                "endAngle",
                "innerRadius",
                "outerRadius",
                "startAngle",
                "x",
                "y",
                "offset",
                "borderWidth",
                "spacing"
            ]
        }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
});
(0, _defineProperty._)(DoughnutController, "descriptors", {
    _scriptable: function(name) {
        return name !== "spacing";
    },
    _indexable: function(name) {
        return name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash");
    }
});
(0, _defineProperty._)(DoughnutController, "overrides", {
    aspectRatio: 1,
    plugins: {
        legend: {
            labels: {
                generateLabels: function(chart) {
                    var data = chart.data;
                    if (data.labels.length && data.datasets.length) {
                        var _chart_legend_options = chart.legend.options, _chart_legend_options_labels = _chart_legend_options.labels, pointStyle = _chart_legend_options_labels.pointStyle, color = _chart_legend_options_labels.color;
                        return data.labels.map(function(label, i) {
                            var meta = chart.getDatasetMeta(0);
                            var style = meta.controller.getStyle(i);
                            return {
                                text: label,
                                fillStyle: style.backgroundColor,
                                strokeStyle: style.borderColor,
                                fontColor: color,
                                lineWidth: style.borderWidth,
                                pointStyle: pointStyle,
                                hidden: !chart.getDataVisibility(i),
                                index: i
                            };
                        });
                    }
                    return [];
                }
            },
            onClick: function(e, legendItem, legend) {
                legend.chart.toggleDataVisibility(legendItem.index);
                legend.chart.update();
            }
        }
    }
});
var LineController = /*#__PURE__*/ function(DatasetController) {
    "use strict";
    (0, _inherits._)(LineController, DatasetController);
    var _super = (0, _createSuper._)(LineController);
    function LineController() {
        (0, _classCallCheck._)(this, LineController);
        return _super.apply(this, arguments);
    }
    (0, _createClass._)(LineController, [
        {
            key: "initialize",
            value: function initialize() {
                this.enableOptionSharing = true;
                this.supportsDecimation = true;
                (0, _get._)((0, _getPrototypeOf._)(LineController.prototype), "initialize", this).call(this);
            }
        },
        {
            key: "update",
            value: function update(mode) {
                var meta = this._cachedMeta;
                var line = meta.dataset, tmp = meta.data, points = tmp === void 0 ? [] : tmp, _dataset = meta._dataset;
                var animationsDisabled = this.chart._animationsDisabled;
                var _$_getStartAndCountOfVisiblePoints = (0, _helpersSegmentJs.q)(meta, points, animationsDisabled), start = _$_getStartAndCountOfVisiblePoints.start, count = _$_getStartAndCountOfVisiblePoints.count;
                this._drawStart = start;
                this._drawCount = count;
                if ((0, _helpersSegmentJs.w)(meta)) {
                    start = 0;
                    count = points.length;
                }
                line._chart = this.chart;
                line._datasetIndex = this.index;
                line._decimated = !!_dataset._decimated;
                line.points = points;
                var options = this.resolveDatasetElementOptions(mode);
                if (!this.options.showLine) options.borderWidth = 0;
                options.segment = this.options.segment;
                this.updateElement(line, undefined, {
                    animated: !animationsDisabled,
                    options: options
                }, mode);
                this.updateElements(points, start, count, mode);
            }
        },
        {
            key: "updateElements",
            value: function updateElements(points, start, count, mode) {
                var reset = mode === "reset";
                var _this__cachedMeta = this._cachedMeta, iScale = _this__cachedMeta.iScale, vScale = _this__cachedMeta.vScale, _stacked = _this__cachedMeta._stacked, _dataset = _this__cachedMeta._dataset;
                var _this__getSharedOptions = this._getSharedOptions(start, mode), sharedOptions = _this__getSharedOptions.sharedOptions, includeOptions = _this__getSharedOptions.includeOptions;
                var iAxis = iScale.axis;
                var vAxis = vScale.axis;
                var _this_options = this.options, spanGaps = _this_options.spanGaps, segment = _this_options.segment;
                var maxGapLength = (0, _helpersSegmentJs.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
                var directUpdate = this.chart._animationsDisabled || reset || mode === "none";
                var end = start + count;
                var pointsCount = points.length;
                var prevParsed = start > 0 && this.getParsed(start - 1);
                for(var i = 0; i < pointsCount; ++i){
                    var point = points[i];
                    var properties = directUpdate ? point : {};
                    if (i < start || i >= end) {
                        properties.skip = true;
                        continue;
                    }
                    var parsed = this.getParsed(i);
                    var nullData = (0, _helpersSegmentJs.k)(parsed[vAxis]);
                    var iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
                    var vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
                    properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
                    properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
                    if (segment) {
                        properties.parsed = parsed;
                        properties.raw = _dataset.data[i];
                    }
                    if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
                    if (!directUpdate) this.updateElement(point, i, properties, mode);
                    prevParsed = parsed;
                }
            }
        },
        {
            key: "getMaxOverflow",
            value: function getMaxOverflow() {
                var meta = this._cachedMeta;
                var dataset = meta.dataset;
                var border = dataset.options && dataset.options.borderWidth || 0;
                var data = meta.data || [];
                if (!data.length) return border;
                var firstPoint = data[0].size(this.resolveDataElementOptions(0));
                var lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
                return Math.max(border, firstPoint, lastPoint) / 2;
            }
        },
        {
            key: "draw",
            value: function draw() {
                var meta = this._cachedMeta;
                meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
                (0, _get._)((0, _getPrototypeOf._)(LineController.prototype), "draw", this).call(this);
            }
        }
    ]);
    return LineController;
}(DatasetController);
(0, _defineProperty._)(LineController, "id", "line");
(0, _defineProperty._)(LineController, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: true,
    spanGaps: false
});
(0, _defineProperty._)(LineController, "overrides", {
    scales: {
        _index_: {
            type: "category"
        },
        _value_: {
            type: "linear"
        }
    }
});
var PolarAreaController = /*#__PURE__*/ function(DatasetController) {
    "use strict";
    (0, _inherits._)(PolarAreaController, DatasetController);
    var _super = (0, _createSuper._)(PolarAreaController);
    function PolarAreaController(chart, datasetIndex) {
        (0, _classCallCheck._)(this, PolarAreaController);
        var _this;
        _this = _super.call(this, chart, datasetIndex);
        _this.innerRadius = undefined;
        _this.outerRadius = undefined;
        return _this;
    }
    (0, _createClass._)(PolarAreaController, [
        {
            key: "getLabelAndValue",
            value: function getLabelAndValue(index) {
                var meta = this._cachedMeta;
                var chart = this.chart;
                var labels = chart.data.labels || [];
                var value = (0, _helpersSegmentJs.o)(meta._parsed[index].r, chart.options.locale);
                return {
                    label: labels[index] || "",
                    value: value
                };
            }
        },
        {
            key: "parseObjectData",
            value: function parseObjectData(meta, data, start, count) {
                return (0, _helpersSegmentJs.y).bind(this)(meta, data, start, count);
            }
        },
        {
            key: "update",
            value: function update(mode) {
                var arcs = this._cachedMeta.data;
                this._updateRadius();
                this.updateElements(arcs, 0, arcs.length, mode);
            }
        },
        {
            key: "getMinMax",
            value: function getMinMax() {
                var _this = this;
                var meta = this._cachedMeta;
                var range = {
                    min: Number.POSITIVE_INFINITY,
                    max: Number.NEGATIVE_INFINITY
                };
                meta.data.forEach(function(element, index) {
                    var parsed = _this.getParsed(index).r;
                    if (!isNaN(parsed) && _this.chart.getDataVisibility(index)) {
                        if (parsed < range.min) range.min = parsed;
                        if (parsed > range.max) range.max = parsed;
                    }
                });
                return range;
            }
        },
        {
            key: "_updateRadius",
            value: function _updateRadius() {
                var chart = this.chart;
                var chartArea = chart.chartArea;
                var opts = chart.options;
                var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
                var outerRadius = Math.max(minSize / 2, 0);
                var innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
                var radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
                this.outerRadius = outerRadius - radiusLength * this.index;
                this.innerRadius = this.outerRadius - radiusLength;
            }
        },
        {
            key: "updateElements",
            value: function updateElements(arcs, start, count, mode) {
                var reset = mode === "reset";
                var chart = this.chart;
                var opts = chart.options;
                var animationOpts = opts.animation;
                var scale = this._cachedMeta.rScale;
                var centerX = scale.xCenter;
                var centerY = scale.yCenter;
                var datasetStartAngle = scale.getIndexAngle(0) - 0.5 * (0, _helpersSegmentJs.P);
                var angle = datasetStartAngle;
                var i;
                var defaultAngle = 360 / this.countVisibleElements();
                for(i = 0; i < start; ++i)angle += this._computeAngle(i, mode, defaultAngle);
                for(i = start; i < start + count; i++){
                    var arc = arcs[i];
                    var startAngle = angle;
                    var endAngle = angle + this._computeAngle(i, mode, defaultAngle);
                    var outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
                    angle = endAngle;
                    if (reset) {
                        if (animationOpts.animateScale) outerRadius = 0;
                        if (animationOpts.animateRotate) startAngle = endAngle = datasetStartAngle;
                    }
                    var properties = {
                        x: centerX,
                        y: centerY,
                        innerRadius: 0,
                        outerRadius: outerRadius,
                        startAngle: startAngle,
                        endAngle: endAngle,
                        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
                    };
                    this.updateElement(arc, i, properties, mode);
                }
            }
        },
        {
            key: "countVisibleElements",
            value: function countVisibleElements() {
                var _this = this;
                var meta = this._cachedMeta;
                var count = 0;
                meta.data.forEach(function(element, index) {
                    if (!isNaN(_this.getParsed(index).r) && _this.chart.getDataVisibility(index)) count++;
                });
                return count;
            }
        },
        {
            key: "_computeAngle",
            value: function _computeAngle(index, mode, defaultAngle) {
                return this.chart.getDataVisibility(index) ? (0, _helpersSegmentJs.t)(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
            }
        }
    ]);
    return PolarAreaController;
}(DatasetController);
(0, _defineProperty._)(PolarAreaController, "id", "polarArea");
(0, _defineProperty._)(PolarAreaController, "defaults", {
    dataElementType: "arc",
    animation: {
        animateRotate: true,
        animateScale: true
    },
    animations: {
        numbers: {
            type: "number",
            properties: [
                "x",
                "y",
                "startAngle",
                "endAngle",
                "innerRadius",
                "outerRadius"
            ]
        }
    },
    indexAxis: "r",
    startAngle: 0
});
(0, _defineProperty._)(PolarAreaController, "overrides", {
    aspectRatio: 1,
    plugins: {
        legend: {
            labels: {
                generateLabels: function(chart) {
                    var data = chart.data;
                    if (data.labels.length && data.datasets.length) {
                        var _chart_legend_options = chart.legend.options, _chart_legend_options_labels = _chart_legend_options.labels, pointStyle = _chart_legend_options_labels.pointStyle, color = _chart_legend_options_labels.color;
                        return data.labels.map(function(label, i) {
                            var meta = chart.getDatasetMeta(0);
                            var style = meta.controller.getStyle(i);
                            return {
                                text: label,
                                fillStyle: style.backgroundColor,
                                strokeStyle: style.borderColor,
                                fontColor: color,
                                lineWidth: style.borderWidth,
                                pointStyle: pointStyle,
                                hidden: !chart.getDataVisibility(i),
                                index: i
                            };
                        });
                    }
                    return [];
                }
            },
            onClick: function(e, legendItem, legend) {
                legend.chart.toggleDataVisibility(legendItem.index);
                legend.chart.update();
            }
        }
    },
    scales: {
        r: {
            type: "radialLinear",
            angleLines: {
                display: false
            },
            beginAtZero: true,
            grid: {
                circular: true
            },
            pointLabels: {
                display: false
            },
            startAngle: 0
        }
    }
});
var PieController = /*#__PURE__*/ function(DoughnutController) {
    "use strict";
    (0, _inherits._)(PieController, DoughnutController);
    var _super = (0, _createSuper._)(PieController);
    function PieController() {
        (0, _classCallCheck._)(this, PieController);
        return _super.apply(this, arguments);
    }
    return PieController;
}(DoughnutController);
(0, _defineProperty._)(PieController, "id", "pie");
(0, _defineProperty._)(PieController, "defaults", {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
});
var RadarController = /*#__PURE__*/ function(DatasetController) {
    "use strict";
    (0, _inherits._)(RadarController, DatasetController);
    var _super = (0, _createSuper._)(RadarController);
    function RadarController() {
        (0, _classCallCheck._)(this, RadarController);
        return _super.apply(this, arguments);
    }
    (0, _createClass._)(RadarController, [
        {
            key: "getLabelAndValue",
            value: function getLabelAndValue(index) {
                var vScale = this._cachedMeta.vScale;
                var parsed = this.getParsed(index);
                return {
                    label: vScale.getLabels()[index],
                    value: "" + vScale.getLabelForValue(parsed[vScale.axis])
                };
            }
        },
        {
            key: "parseObjectData",
            value: function parseObjectData(meta, data, start, count) {
                return (0, _helpersSegmentJs.y).bind(this)(meta, data, start, count);
            }
        },
        {
            key: "update",
            value: function update(mode) {
                var meta = this._cachedMeta;
                var line = meta.dataset;
                var points = meta.data || [];
                var labels = meta.iScale.getLabels();
                line.points = points;
                if (mode !== "resize") {
                    var options = this.resolveDatasetElementOptions(mode);
                    if (!this.options.showLine) options.borderWidth = 0;
                    var properties = {
                        _loop: true,
                        _fullLoop: labels.length === points.length,
                        options: options
                    };
                    this.updateElement(line, undefined, properties, mode);
                }
                this.updateElements(points, 0, points.length, mode);
            }
        },
        {
            key: "updateElements",
            value: function updateElements(points, start, count, mode) {
                var scale = this._cachedMeta.rScale;
                var reset = mode === "reset";
                for(var i = start; i < start + count; i++){
                    var point = points[i];
                    var options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
                    var pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
                    var x = reset ? scale.xCenter : pointPosition.x;
                    var y = reset ? scale.yCenter : pointPosition.y;
                    var properties = {
                        x: x,
                        y: y,
                        angle: pointPosition.angle,
                        skip: isNaN(x) || isNaN(y),
                        options: options
                    };
                    this.updateElement(point, i, properties, mode);
                }
            }
        }
    ]);
    return RadarController;
}(DatasetController);
(0, _defineProperty._)(RadarController, "id", "radar");
(0, _defineProperty._)(RadarController, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    indexAxis: "r",
    showLine: true,
    elements: {
        line: {
            fill: "start"
        }
    }
});
(0, _defineProperty._)(RadarController, "overrides", {
    aspectRatio: 1,
    scales: {
        r: {
            type: "radialLinear"
        }
    }
});
var ScatterController = /*#__PURE__*/ function(DatasetController) {
    "use strict";
    (0, _inherits._)(ScatterController, DatasetController);
    var _super = (0, _createSuper._)(ScatterController);
    function ScatterController() {
        (0, _classCallCheck._)(this, ScatterController);
        return _super.apply(this, arguments);
    }
    (0, _createClass._)(ScatterController, [
        {
            key: "getLabelAndValue",
            value: function getLabelAndValue(index) {
                var meta = this._cachedMeta;
                var labels = this.chart.data.labels || [];
                var xScale = meta.xScale, yScale = meta.yScale;
                var parsed = this.getParsed(index);
                var x = xScale.getLabelForValue(parsed.x);
                var y = yScale.getLabelForValue(parsed.y);
                return {
                    label: labels[index] || "",
                    value: "(" + x + ", " + y + ")"
                };
            }
        },
        {
            key: "update",
            value: function update(mode) {
                var meta = this._cachedMeta;
                var tmp = meta.data, points = tmp === void 0 ? [] : tmp;
                var animationsDisabled = this.chart._animationsDisabled;
                var _$_getStartAndCountOfVisiblePoints = (0, _helpersSegmentJs.q)(meta, points, animationsDisabled), start = _$_getStartAndCountOfVisiblePoints.start, count = _$_getStartAndCountOfVisiblePoints.count;
                this._drawStart = start;
                this._drawCount = count;
                if ((0, _helpersSegmentJs.w)(meta)) {
                    start = 0;
                    count = points.length;
                }
                if (this.options.showLine) {
                    if (!this.datasetElementType) this.addElements();
                    var line = meta.dataset, _dataset = meta._dataset;
                    line._chart = this.chart;
                    line._datasetIndex = this.index;
                    line._decimated = !!_dataset._decimated;
                    line.points = points;
                    var options = this.resolveDatasetElementOptions(mode);
                    options.segment = this.options.segment;
                    this.updateElement(line, undefined, {
                        animated: !animationsDisabled,
                        options: options
                    }, mode);
                } else if (this.datasetElementType) {
                    delete meta.dataset;
                    this.datasetElementType = false;
                }
                this.updateElements(points, start, count, mode);
            }
        },
        {
            key: "addElements",
            value: function addElements() {
                var showLine = this.options.showLine;
                if (!this.datasetElementType && showLine) this.datasetElementType = this.chart.registry.getElement("line");
                (0, _get._)((0, _getPrototypeOf._)(ScatterController.prototype), "addElements", this).call(this);
            }
        },
        {
            key: "updateElements",
            value: function updateElements(points, start, count, mode) {
                var reset = mode === "reset";
                var _this__cachedMeta = this._cachedMeta, iScale = _this__cachedMeta.iScale, vScale = _this__cachedMeta.vScale, _stacked = _this__cachedMeta._stacked, _dataset = _this__cachedMeta._dataset;
                var firstOpts = this.resolveDataElementOptions(start, mode);
                var sharedOptions = this.getSharedOptions(firstOpts);
                var includeOptions = this.includeOptions(mode, sharedOptions);
                var iAxis = iScale.axis;
                var vAxis = vScale.axis;
                var _this_options = this.options, spanGaps = _this_options.spanGaps, segment = _this_options.segment;
                var maxGapLength = (0, _helpersSegmentJs.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
                var directUpdate = this.chart._animationsDisabled || reset || mode === "none";
                var prevParsed = start > 0 && this.getParsed(start - 1);
                for(var i = start; i < start + count; ++i){
                    var point = points[i];
                    var parsed = this.getParsed(i);
                    var properties = directUpdate ? point : {};
                    var nullData = (0, _helpersSegmentJs.k)(parsed[vAxis]);
                    var iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
                    var vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
                    properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
                    properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
                    if (segment) {
                        properties.parsed = parsed;
                        properties.raw = _dataset.data[i];
                    }
                    if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
                    if (!directUpdate) this.updateElement(point, i, properties, mode);
                    prevParsed = parsed;
                }
                this.updateSharedOptions(sharedOptions, mode, firstOpts);
            }
        },
        {
            key: "getMaxOverflow",
            value: function getMaxOverflow() {
                var meta = this._cachedMeta;
                var data = meta.data || [];
                if (!this.options.showLine) {
                    var max = 0;
                    for(var i = data.length - 1; i >= 0; --i)max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
                    return max > 0 && max;
                }
                var dataset = meta.dataset;
                var border = dataset.options && dataset.options.borderWidth || 0;
                if (!data.length) return border;
                var firstPoint = data[0].size(this.resolveDataElementOptions(0));
                var lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
                return Math.max(border, firstPoint, lastPoint) / 2;
            }
        }
    ]);
    return ScatterController;
}(DatasetController);
(0, _defineProperty._)(ScatterController, "id", "scatter");
(0, _defineProperty._)(ScatterController, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    showLine: false,
    fill: false
});
(0, _defineProperty._)(ScatterController, "overrides", {
    interaction: {
        mode: "point"
    },
    scales: {
        x: {
            type: "linear"
        },
        y: {
            type: "linear"
        }
    }
});
var controllers = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    BarController: BarController,
    BubbleController: BubbleController,
    DoughnutController: DoughnutController,
    LineController: LineController,
    PieController: PieController,
    PolarAreaController: PolarAreaController,
    RadarController: RadarController,
    ScatterController: ScatterController
});
/**
 * @namespace Chart._adapters
 * @since 2.8.0
 * @private
 */ function abstract() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
/**
 * Date adapter (current used by the time scale)
 * @namespace Chart._adapters._date
 * @memberof Chart._adapters
 * @private
 */ var DateAdapterBase = /*#__PURE__*/ function() {
    "use strict";
    function DateAdapterBase(options) {
        (0, _classCallCheck._)(this, DateAdapterBase);
        (0, _defineProperty._)(this, "options", void 0);
        this.options = options || {};
    }
    (0, _createClass._)(DateAdapterBase, [
        {
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            key: "init",
            value: function init() {}
        },
        {
            key: "formats",
            value: function formats() {
                return abstract();
            }
        },
        {
            key: "parse",
            value: function parse() {
                return abstract();
            }
        },
        {
            key: "format",
            value: function format() {
                return abstract();
            }
        },
        {
            key: "add",
            value: function add() {
                return abstract();
            }
        },
        {
            key: "diff",
            value: function diff() {
                return abstract();
            }
        },
        {
            key: "startOf",
            value: function startOf() {
                return abstract();
            }
        },
        {
            key: "endOf",
            value: function endOf() {
                return abstract();
            }
        }
    ], [
        {
            key: "override",
            value: /**
   * Override default date adapter methods.
   * Accepts type parameter to define options type.
   * @example
   * Chart._adapters._date.override<{myAdapterOption: string}>({
   *   init() {
   *     console.log(this.options.myAdapterOption);
   *   }
   * })
   */ function override(members) {
                Object.assign(DateAdapterBase.prototype, members);
            }
        }
    ]);
    return DateAdapterBase;
}();
var adapters = {
    _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
    var controller = metaset.controller, data = metaset.data, _sorted = metaset._sorted;
    var iScale = controller._cachedMeta.iScale;
    if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
        var lookupMethod = iScale._reversePixels ? (0, _helpersSegmentJs.A) : (0, _helpersSegmentJs.B);
        if (!intersect) return lookupMethod(data, axis, value);
        else if (controller._sharedOptions) {
            var el = data[0];
            var range = typeof el.getRange === "function" && el.getRange(axis);
            if (range) {
                var start = lookupMethod(data, axis, value - range);
                var end = lookupMethod(data, axis, value + range);
                return {
                    lo: start.lo,
                    hi: end.hi
                };
            }
        }
    }
    return {
        lo: 0,
        hi: data.length - 1
    };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
    var metasets = chart.getSortedVisibleDatasetMetas();
    var value = position[axis];
    for(var i = 0, ilen = metasets.length; i < ilen; ++i){
        var _metasets_i = metasets[i], index = _metasets_i.index, data = _metasets_i.data;
        var _binarySearch = binarySearch(metasets[i], axis, value, intersect), lo = _binarySearch.lo, hi = _binarySearch.hi;
        for(var j = lo; j <= hi; ++j){
            var element = data[j];
            if (!element.skip) handler(element, index, j);
        }
    }
}
function getDistanceMetricForAxis(axis) {
    var useX = axis.indexOf("x") !== -1;
    var useY = axis.indexOf("y") !== -1;
    return function(pt1, pt2) {
        var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    var items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) return items;
    var evaluationFunc = function evaluationFunc(element, datasetIndex, index) {
        if (!includeInvisible && !(0, _helpersSegmentJs.C)(element, chart.chartArea, 0)) return;
        if (element.inRange(position.x, position.y, useFinalPosition)) items.push({
            element: element,
            datasetIndex: datasetIndex,
            index: index
        });
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    var items = [];
    function evaluationFunc(element, datasetIndex, index) {
        var _element_getProps = element.getProps([
            "startAngle",
            "endAngle"
        ], useFinalPosition), startAngle = _element_getProps.startAngle, endAngle = _element_getProps.endAngle;
        var angle = (0, _helpersSegmentJs.D)(element, {
            x: position.x,
            y: position.y
        }).angle;
        if ((0, _helpersSegmentJs.p)(angle, startAngle, endAngle)) items.push({
            element: element,
            datasetIndex: datasetIndex,
            index: index
        });
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    var items = [];
    var distanceMetric = getDistanceMetricForAxis(axis);
    var minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index) {
        var inRange = element.inRange(position.x, position.y, useFinalPosition);
        if (intersect && !inRange) return;
        var center = element.getCenterPoint(useFinalPosition);
        var pointInArea = !!includeInvisible || chart.isPointInArea(center);
        if (!pointInArea && !inRange) return;
        var distance = distanceMetric(position, center);
        if (distance < minDistance) {
            items = [
                {
                    element: element,
                    datasetIndex: datasetIndex,
                    index: index
                }
            ];
            minDistance = distance;
        } else if (distance === minDistance) items.push({
            element: element,
            datasetIndex: datasetIndex,
            index: index
        });
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) return [];
    return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    var items = [];
    var rangeMethod = axis === "x" ? "inXRange" : "inYRange";
    var intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, function(element, datasetIndex, index) {
        if (element[rangeMethod](position[axis], useFinalPosition)) {
            items.push({
                element: element,
                datasetIndex: datasetIndex,
                index: index
            });
            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
        }
    });
    if (intersect && !intersectsItem) return [];
    return items;
}
var Interaction = {
    evaluateInteractionItems: evaluateInteractionItems,
    modes: {
        index: function(chart, e, options, useFinalPosition) {
            var position = (0, _helpersSegmentJs.z)(e, chart);
            var axis = options.axis || "x";
            var includeInvisible = options.includeInvisible || false;
            var items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            var elements = [];
            if (!items.length) return [];
            chart.getSortedVisibleDatasetMetas().forEach(function(meta) {
                var index = items[0].index;
                var element = meta.data[index];
                if (element && !element.skip) elements.push({
                    element: element,
                    datasetIndex: meta.index,
                    index: index
                });
            });
            return elements;
        },
        dataset: function(chart, e, options, useFinalPosition) {
            var position = (0, _helpersSegmentJs.z)(e, chart);
            var axis = options.axis || "xy";
            var includeInvisible = options.includeInvisible || false;
            var items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            if (items.length > 0) {
                var datasetIndex = items[0].datasetIndex;
                var data = chart.getDatasetMeta(datasetIndex).data;
                items = [];
                for(var i = 0; i < data.length; ++i)items.push({
                    element: data[i],
                    datasetIndex: datasetIndex,
                    index: i
                });
            }
            return items;
        },
        point: function(chart, e, options, useFinalPosition) {
            var position = (0, _helpersSegmentJs.z)(e, chart);
            var axis = options.axis || "xy";
            var includeInvisible = options.includeInvisible || false;
            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
        },
        nearest: function(chart, e, options, useFinalPosition) {
            var position = (0, _helpersSegmentJs.z)(e, chart);
            var axis = options.axis || "xy";
            var includeInvisible = options.includeInvisible || false;
            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
        },
        x: function(chart, e, options, useFinalPosition) {
            var position = (0, _helpersSegmentJs.z)(e, chart);
            return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
        },
        y: function(chart, e, options, useFinalPosition) {
            var position = (0, _helpersSegmentJs.z)(e, chart);
            return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
        }
    }
};
var STATIC_POSITIONS = [
    "left",
    "top",
    "right",
    "bottom"
];
function filterByPosition(array, position) {
    return array.filter(function(v) {
        return v.pos === position;
    });
}
function filterDynamicPositionByAxis(array, axis) {
    return array.filter(function(v) {
        return STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis;
    });
}
function sortByWeight(array, reverse) {
    return array.sort(function(a, b) {
        var v0 = reverse ? b : a;
        var v1 = reverse ? a : b;
        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
}
function wrapBoxes(boxes) {
    var layoutBoxes = [];
    var i, ilen, box, pos, stack, stackWeight;
    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){
        box = boxes[i];
        var ref, ref1, ref2;
        ref = box, pos = ref.position, ref1 = ref.options, stack = ref1.stack, ref2 = ref1.stackWeight, stackWeight = ref2 === void 0 ? 1 : ref2, ref1, ref;
        layoutBoxes.push({
            index: i,
            box: box,
            pos: pos,
            horizontal: box.isHorizontal(),
            weight: box.weight,
            stack: stack && pos + stack,
            stackWeight: stackWeight
        });
    }
    return layoutBoxes;
}
function buildStacks(layouts) {
    var stacks = {};
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = layouts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var wrap = _step.value;
            var stack = wrap.stack, pos = wrap.pos, stackWeight = wrap.stackWeight;
            if (!stack || !STATIC_POSITIONS.includes(pos)) continue;
            var _stack = stacks[stack] || (stacks[stack] = {
                count: 0,
                placed: 0,
                weight: 0,
                size: 0
            });
            _stack.count++;
            _stack.weight += stackWeight;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return stacks;
}
function setLayoutDims(layouts, params) {
    var stacks = buildStacks(layouts);
    var vBoxMaxWidth = params.vBoxMaxWidth, hBoxMaxHeight = params.hBoxMaxHeight;
    var i, ilen, layout;
    for(i = 0, ilen = layouts.length; i < ilen; ++i){
        layout = layouts[i];
        var fullSize = layout.box.fullSize;
        var stack = stacks[layout.stack];
        var factor = stack && layout.stackWeight / stack.weight;
        if (layout.horizontal) {
            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
            layout.height = hBoxMaxHeight;
        } else {
            layout.width = vBoxMaxWidth;
            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
        }
    }
    return stacks;
}
function buildLayoutBoxes(boxes) {
    var layoutBoxes = wrapBoxes(boxes);
    var fullSize = sortByWeight(layoutBoxes.filter(function(wrap) {
        return wrap.box.fullSize;
    }), true);
    var left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
    var right = sortByWeight(filterByPosition(layoutBoxes, "right"));
    var top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
    var bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
    var centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
    var centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
    return {
        fullSize: fullSize,
        leftAndTop: left.concat(top),
        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
        chartArea: filterByPosition(layoutBoxes, "chartArea"),
        vertical: left.concat(right).concat(centerVertical),
        horizontal: top.concat(bottom).concat(centerHorizontal)
    };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
    var pos = layout.pos, box = layout.box;
    var maxPadding = chartArea.maxPadding;
    if (!(0, _helpersSegmentJs.i)(pos)) {
        if (layout.size) chartArea[pos] -= layout.size;
        var stack = stacks[layout.stack] || {
            size: 0,
            count: 1
        };
        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
        layout.size = stack.size / stack.count;
        chartArea[pos] += layout.size;
    }
    if (box.getPadding) updateMaxPadding(maxPadding, box.getPadding());
    var newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
    var newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
    var widthChanged = newWidth !== chartArea.w;
    var heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? {
        same: widthChanged,
        other: heightChanged
    } : {
        same: heightChanged,
        other: widthChanged
    };
}
function handleMaxPadding(chartArea) {
    var maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
        var change = Math.max(maxPadding[pos] - chartArea[pos], 0);
        chartArea[pos] += change;
        return change;
    }
    chartArea.y += updatePos("top");
    chartArea.x += updatePos("left");
    updatePos("right");
    updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
    var maxPadding = chartArea.maxPadding;
    function marginForPositions(positions) {
        var margin = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
        };
        positions.forEach(function(pos) {
            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
        });
        return margin;
    }
    return horizontal ? marginForPositions([
        "left",
        "right"
    ]) : marginForPositions([
        "top",
        "bottom"
    ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
    var refitBoxes = [];
    var i, ilen, layout, box, refit, changed;
    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){
        layout = boxes[i];
        box = layout.box;
        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
        var _updateDims = updateDims(chartArea, params, layout, stacks), same = _updateDims.same, other = _updateDims.other;
        refit |= same && refitBoxes.length;
        changed = changed || other;
        if (!box.fullSize) refitBoxes.push(layout);
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
    box.top = top;
    box.left = left;
    box.right = left + width;
    box.bottom = top + height;
    box.width = width;
    box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
    var userPadding = params.padding;
    var x = chartArea.x, y = chartArea.y;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = boxes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var layout = _step.value;
            var box = layout.box;
            var stack = stacks[layout.stack] || {
                count: 1,
                placed: 0,
                weight: 1
            };
            var weight = layout.stackWeight / stack.weight || 1;
            if (layout.horizontal) {
                var width = chartArea.w * weight;
                var height = stack.size || box.height;
                if ((0, _helpersSegmentJs.h)(stack.start)) y = stack.start;
                if (box.fullSize) setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
                else setBoxDims(box, chartArea.left + stack.placed, y, width, height);
                stack.start = y;
                stack.placed += width;
                y = box.bottom;
            } else {
                var height1 = chartArea.h * weight;
                var width1 = stack.size || box.width;
                if ((0, _helpersSegmentJs.h)(stack.start)) x = stack.start;
                if (box.fullSize) setBoxDims(box, x, userPadding.top, width1, params.outerHeight - userPadding.bottom - userPadding.top);
                else setBoxDims(box, x, chartArea.top + stack.placed, width1, height1);
                stack.start = x;
                stack.placed += height1;
                x = box.right;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    chartArea.x = x;
    chartArea.y = y;
}
var layouts = {
    addBox: function(chart, item) {
        if (!chart.boxes) chart.boxes = [];
        item.fullSize = item.fullSize || false;
        item.position = item.position || "top";
        item.weight = item.weight || 0;
        item._layers = item._layers || function() {
            return [
                {
                    z: 0,
                    draw: function(chartArea) {
                        item.draw(chartArea);
                    }
                }
            ];
        };
        chart.boxes.push(item);
    },
    removeBox: function(chart, layoutItem) {
        var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
        if (index !== -1) chart.boxes.splice(index, 1);
    },
    configure: function(chart, item, options) {
        item.fullSize = options.fullSize;
        item.position = options.position;
        item.weight = options.weight;
    },
    update: function(chart, width, height, minPadding) {
        if (!chart) return;
        var padding = (0, _helpersSegmentJs.E)(chart.options.layout.padding);
        var availableWidth = Math.max(width - padding.width, 0);
        var availableHeight = Math.max(height - padding.height, 0);
        var boxes = buildLayoutBoxes(chart.boxes);
        var verticalBoxes = boxes.vertical;
        var horizontalBoxes = boxes.horizontal;
        (0, _helpersSegmentJs.F)(chart.boxes, function(box) {
            if (typeof box.beforeLayout === "function") box.beforeLayout();
        });
        var visibleVerticalBoxCount = verticalBoxes.reduce(function(total, wrap) {
            return wrap.box.options && wrap.box.options.display === false ? total : total + 1;
        }, 0) || 1;
        var params = Object.freeze({
            outerWidth: width,
            outerHeight: height,
            padding: padding,
            availableWidth: availableWidth,
            availableHeight: availableHeight,
            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
            hBoxMaxHeight: availableHeight / 2
        });
        var maxPadding = Object.assign({}, padding);
        updateMaxPadding(maxPadding, (0, _helpersSegmentJs.E)(minPadding));
        var chartArea = Object.assign({
            maxPadding: maxPadding,
            w: availableWidth,
            h: availableHeight,
            x: padding.left,
            y: padding.top
        }, padding);
        var stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
        fitBoxes(boxes.fullSize, chartArea, params, stacks);
        fitBoxes(verticalBoxes, chartArea, params, stacks);
        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) fitBoxes(verticalBoxes, chartArea, params, stacks);
        handleMaxPadding(chartArea);
        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
        chartArea.x += chartArea.w;
        chartArea.y += chartArea.h;
        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
        chart.chartArea = {
            left: chartArea.left,
            top: chartArea.top,
            right: chartArea.left + chartArea.w,
            bottom: chartArea.top + chartArea.h,
            height: chartArea.h,
            width: chartArea.w
        };
        (0, _helpersSegmentJs.F)(boxes.chartArea, function(layout) {
            var box = layout.box;
            Object.assign(box, chart.chartArea);
            box.update(chartArea.w, chartArea.h, {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
            });
        });
    }
};
var BasePlatform = /*#__PURE__*/ function() {
    "use strict";
    function BasePlatform() {
        (0, _classCallCheck._)(this, BasePlatform);
    }
    (0, _createClass._)(BasePlatform, [
        {
            key: "acquireContext",
            value: function acquireContext(canvas, aspectRatio) {}
        },
        {
            key: "releaseContext",
            value: function releaseContext(context) {
                return false;
            }
        },
        {
            key: "addEventListener",
            value: function addEventListener(chart, type, listener) {}
        },
        {
            key: "removeEventListener",
            value: function removeEventListener(chart, type, listener) {}
        },
        {
            key: "getDevicePixelRatio",
            value: function getDevicePixelRatio() {
                return 1;
            }
        },
        {
            key: "getMaximumSize",
            value: function getMaximumSize(element, width, height, aspectRatio) {
                width = Math.max(0, width || element.width);
                height = height || element.height;
                return {
                    width: width,
                    height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
                };
            }
        },
        {
            key: "isAttached",
            value: function isAttached(canvas) {
                return true;
            }
        },
        {
            key: "updateConfig",
            value: function updateConfig(config) {}
        }
    ]);
    return BasePlatform;
}();
var BasicPlatform = /*#__PURE__*/ function(BasePlatform) {
    "use strict";
    (0, _inherits._)(BasicPlatform, BasePlatform);
    var _super = (0, _createSuper._)(BasicPlatform);
    function BasicPlatform() {
        (0, _classCallCheck._)(this, BasicPlatform);
        return _super.apply(this, arguments);
    }
    (0, _createClass._)(BasicPlatform, [
        {
            key: "acquireContext",
            value: function acquireContext(item) {
                return item && item.getContext && item.getContext("2d") || null;
            }
        },
        {
            key: "updateConfig",
            value: function updateConfig(config) {
                config.options.animation = false;
            }
        }
    ]);
    return BasicPlatform;
}(BasePlatform);
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
};
var isNullOrEmpty = function(value) {
    return value === null || value === "";
};
function initCanvas(canvas, aspectRatio) {
    var style = canvas.style;
    var renderHeight = canvas.getAttribute("height");
    var renderWidth = canvas.getAttribute("width");
    canvas[EXPANDO_KEY] = {
        initial: {
            height: renderHeight,
            width: renderWidth,
            style: {
                display: style.display,
                height: style.height,
                width: style.width
            }
        }
    };
    style.display = style.display || "block";
    style.boxSizing = style.boxSizing || "border-box";
    if (isNullOrEmpty(renderWidth)) {
        var displayWidth = (0, _helpersSegmentJs.J)(canvas, "width");
        if (displayWidth !== undefined) canvas.width = displayWidth;
    }
    if (isNullOrEmpty(renderHeight)) {
        if (canvas.style.height === "") canvas.height = canvas.width / (aspectRatio || 2);
        else {
            var displayHeight = (0, _helpersSegmentJs.J)(canvas, "height");
            if (displayHeight !== undefined) canvas.height = displayHeight;
        }
    }
    return canvas;
}
var eventListenerOptions = (0, _helpersSegmentJs.K) ? {
    passive: true
} : false;
function addListener(node, type, listener) {
    node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
    var type = EVENT_TYPES[event.type] || event.type;
    var _getRelativePosition = (0, _helpersSegmentJs.z)(event, chart), x = _getRelativePosition.x, y = _getRelativePosition.y;
    return {
        type: type,
        chart: chart,
        native: event,
        x: x !== undefined ? x : null,
        y: y !== undefined ? y : null
    };
}
function nodeListContains(nodeList, canvas) {
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = nodeList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var node = _step.value;
            if (node === canvas || node.contains(canvas)) return true;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}
function createAttachObserver(chart, type, listener) {
    var canvas = chart.canvas;
    var observer = new MutationObserver(function(entries) {
        var trigger = false;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var entry = _step.value;
                trigger = trigger || nodeListContains(entry.addedNodes, canvas);
                trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        if (trigger) listener();
    });
    observer.observe(document, {
        childList: true,
        subtree: true
    });
    return observer;
}
function createDetachObserver(chart, type, listener) {
    var canvas = chart.canvas;
    var observer = new MutationObserver(function(entries) {
        var trigger = false;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var entry = _step.value;
                trigger = trigger || nodeListContains(entry.removedNodes, canvas);
                trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        if (trigger) listener();
    });
    observer.observe(document, {
        childList: true,
        subtree: true
    });
    return observer;
}
var drpListeningCharts = new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
    var dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) return;
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach(function(resize, chart) {
        if (chart.currentDevicePixelRatio !== dpr) resize();
    });
}
function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) window.addEventListener("resize", onWindowResize);
    drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) window.removeEventListener("resize", onWindowResize);
}
function createResizeObserver(chart, type, listener) {
    var canvas = chart.canvas;
    var container = canvas && (0, _helpersSegmentJs.I)(canvas);
    if (!container) return;
    var resize = (0, _helpersSegmentJs.L)(function(width, height) {
        var w = container.clientWidth;
        listener(width, height);
        if (w < container.clientWidth) listener();
    }, window);
    var observer = new ResizeObserver(function(entries) {
        var entry = entries[0];
        var width = entry.contentRect.width;
        var height = entry.contentRect.height;
        if (width === 0 && height === 0) return;
        resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
}
function releaseObserver(chart, type, observer) {
    if (observer) observer.disconnect();
    if (type === "resize") unlistenDevicePixelRatioChanges(chart);
}
function createProxyAndListen(chart, type, listener) {
    var canvas = chart.canvas;
    var proxy = (0, _helpersSegmentJs.L)(function(event) {
        if (chart.ctx !== null) listener(fromNativeEvent(event, chart));
    }, chart);
    addListener(canvas, type, proxy);
    return proxy;
}
var DomPlatform = /*#__PURE__*/ function(BasePlatform) {
    "use strict";
    (0, _inherits._)(DomPlatform, BasePlatform);
    var _super = (0, _createSuper._)(DomPlatform);
    function DomPlatform() {
        (0, _classCallCheck._)(this, DomPlatform);
        return _super.apply(this, arguments);
    }
    (0, _createClass._)(DomPlatform, [
        {
            key: "acquireContext",
            value: function acquireContext(canvas, aspectRatio) {
                var context = canvas && canvas.getContext && canvas.getContext("2d");
                if (context && context.canvas === canvas) {
                    initCanvas(canvas, aspectRatio);
                    return context;
                }
                return null;
            }
        },
        {
            key: "releaseContext",
            value: function releaseContext(context) {
                var canvas = context.canvas;
                if (!canvas[EXPANDO_KEY]) return false;
                var initial = canvas[EXPANDO_KEY].initial;
                [
                    "height",
                    "width"
                ].forEach(function(prop) {
                    var value = initial[prop];
                    if ((0, _helpersSegmentJs.k)(value)) canvas.removeAttribute(prop);
                    else canvas.setAttribute(prop, value);
                });
                var style = initial.style || {};
                Object.keys(style).forEach(function(key) {
                    canvas.style[key] = style[key];
                });
                canvas.width = canvas.width;
                delete canvas[EXPANDO_KEY];
                return true;
            }
        },
        {
            key: "addEventListener",
            value: function addEventListener(chart, type, listener) {
                this.removeEventListener(chart, type);
                var proxies = chart.$proxies || (chart.$proxies = {});
                var handlers = {
                    attach: createAttachObserver,
                    detach: createDetachObserver,
                    resize: createResizeObserver
                };
                var handler = handlers[type] || createProxyAndListen;
                proxies[type] = handler(chart, type, listener);
            }
        },
        {
            key: "removeEventListener",
            value: function removeEventListener(chart, type) {
                var proxies = chart.$proxies || (chart.$proxies = {});
                var proxy = proxies[type];
                if (!proxy) return;
                var handlers = {
                    attach: releaseObserver,
                    detach: releaseObserver,
                    resize: releaseObserver
                };
                var handler = handlers[type] || removeListener;
                handler(chart, type, proxy);
                proxies[type] = undefined;
            }
        },
        {
            key: "getDevicePixelRatio",
            value: function getDevicePixelRatio() {
                return window.devicePixelRatio;
            }
        },
        {
            key: "getMaximumSize",
            value: function getMaximumSize(canvas, width, height, aspectRatio) {
                return (0, _helpersSegmentJs.G)(canvas, width, height, aspectRatio);
            }
        },
        {
            key: "isAttached",
            value: function isAttached(canvas) {
                var container = (0, _helpersSegmentJs.I)(canvas);
                return !!(container && container.isConnected);
            }
        }
    ]);
    return DomPlatform;
}(BasePlatform);
function _detectPlatform(canvas) {
    if (!(0, _helpersSegmentJs.M)() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) return BasicPlatform;
    return DomPlatform;
}
var Element = /*#__PURE__*/ function() {
    "use strict";
    function Element() {
        (0, _classCallCheck._)(this, Element);
        (0, _defineProperty._)(this, "x", void 0);
        (0, _defineProperty._)(this, "y", void 0);
        (0, _defineProperty._)(this, "active", false);
        (0, _defineProperty._)(this, "options", void 0);
        (0, _defineProperty._)(this, "$animations", void 0);
    }
    (0, _createClass._)(Element, [
        {
            key: "tooltipPosition",
            value: function tooltipPosition(useFinalPosition) {
                var _this_getProps = this.getProps([
                    "x",
                    "y"
                ], useFinalPosition), x = _this_getProps.x, y = _this_getProps.y;
                return {
                    x: x,
                    y: y
                };
            }
        },
        {
            key: "hasValue",
            value: function hasValue() {
                return (0, _helpersSegmentJs.x)(this.x) && (0, _helpersSegmentJs.x)(this.y);
            }
        },
        {
            key: "getProps",
            value: function getProps(props, final) {
                var _this = this;
                var anims = this.$animations;
                if (!final || !anims) // let's not create an object, if not needed
                return this;
                var ret = {};
                props.forEach(function(prop) {
                    ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : _this[prop];
                });
                return ret;
            }
        }
    ]);
    return Element;
}();
(0, _defineProperty._)(Element, "defaults", {});
(0, _defineProperty._)(Element, "defaultRoutes", undefined);
function autoSkip(scale, ticks) {
    var tickOpts = scale.options.ticks;
    var determinedMaxTicks = determineMaxTicks(scale);
    var ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
    var majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    var numMajorIndices = majorIndices.length;
    var first = majorIndices[0];
    var last = majorIndices[numMajorIndices - 1];
    var newTicks = [];
    if (numMajorIndices > ticksLimit) {
        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
        return newTicks;
    }
    var spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
        var i, ilen;
        var avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
        skip(ticks, newTicks, spacing, (0, _helpersSegmentJs.k)(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++)skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
        skip(ticks, newTicks, spacing, last, (0, _helpersSegmentJs.k)(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
        return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
}
function determineMaxTicks(scale) {
    var offset = scale.options.offset;
    var tickLength = scale._tickSize();
    var maxScale = scale._length / tickLength + (offset ? 0 : 1);
    var maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
    var evenMajorSpacing = getEvenSpacing(majorIndices);
    var spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) return Math.max(spacing, 1);
    var factors = (0, _helpersSegmentJs.N)(evenMajorSpacing);
    for(var i = 0, ilen = factors.length - 1; i < ilen; i++){
        var factor = factors[i];
        if (factor > spacing) return factor;
    }
    return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
    var result = [];
    var i, ilen;
    for(i = 0, ilen = ticks.length; i < ilen; i++)if (ticks[i].major) result.push(i);
    return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
    var count = 0;
    var next = majorIndices[0];
    var i;
    spacing = Math.ceil(spacing);
    for(i = 0; i < ticks.length; i++)if (i === next) {
        newTicks.push(ticks[i]);
        count++;
        next = majorIndices[count * spacing];
    }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    var start = (0, _helpersSegmentJs.v)(majorStart, 0);
    var end = Math.min((0, _helpersSegmentJs.v)(majorEnd, ticks.length), ticks.length);
    var count = 0;
    var length, i, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
        length = majorEnd - majorStart;
        spacing = length / Math.floor(length / spacing);
    }
    next = start;
    while(next < 0){
        count++;
        next = Math.round(start + count * spacing);
    }
    for(i = Math.max(start, 0); i < end; i++)if (i === next) {
        newTicks.push(ticks[i]);
        count++;
        next = Math.round(start + count * spacing);
    }
}
function getEvenSpacing(arr) {
    var len = arr.length;
    var i, diff;
    if (len < 2) return false;
    for(diff = arr[0], i = 1; i < len; ++i){
        if (arr[i] - arr[i - 1] !== diff) return false;
    }
    return diff;
}
var reverseAlign = function(align) {
    return align === "left" ? "right" : align === "right" ? "left" : align;
};
var offsetFromEdge = function(scale, edge, offset) {
    return edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
};
var getTicksLimit = function(ticksLength, maxTicksLimit) {
    return Math.min(maxTicksLimit || ticksLength, ticksLength);
};
function sample(arr, numItems) {
    var result = [];
    var increment = arr.length / numItems;
    var len = arr.length;
    var i = 0;
    for(; i < len; i += increment)result.push(arr[Math.floor(i)]);
    return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
    var length = scale.ticks.length;
    var validIndex = Math.min(index, length - 1);
    var start = scale._startPixel;
    var end = scale._endPixel;
    var epsilon = 1e-6;
    var lineValue = scale.getPixelForTick(validIndex);
    var offset;
    if (offsetGridLines) {
        if (length === 1) offset = Math.max(lineValue - start, end - lineValue);
        else if (index === 0) offset = (scale.getPixelForTick(1) - lineValue) / 2;
        else offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
        lineValue += validIndex < index ? offset : -offset;
        if (lineValue < start - epsilon || lineValue > end + epsilon) return;
    }
    return lineValue;
}
function garbageCollect(caches, length) {
    (0, _helpersSegmentJs.F)(caches, function(cache) {
        var gc = cache.gc;
        var gcLen = gc.length / 2;
        var i;
        if (gcLen > length) {
            for(i = 0; i < gcLen; ++i)delete cache.data[gc[i]];
            gc.splice(0, gcLen);
        }
    });
}
function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
    if (!options.display) return 0;
    var font = (0, _helpersSegmentJs.a0)(options.font, fallback);
    var padding = (0, _helpersSegmentJs.E)(options.padding);
    var lines = (0, _helpersSegmentJs.b)(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
    return (0, _helpersSegmentJs.j)(parent, {
        scale: scale,
        type: "scale"
    });
}
function createTickContext(parent, index, tick) {
    return (0, _helpersSegmentJs.j)(parent, {
        tick: tick,
        index: index,
        type: "tick"
    });
}
function titleAlign(align, position, reverse) {
    var ret = (0, _helpersSegmentJs.a1)(align);
    if (reverse && position !== "right" || !reverse && position === "right") ret = reverseAlign(ret);
    return ret;
}
function titleArgs(scale, offset, position, align) {
    var top = scale.top, left = scale.left, bottom = scale.bottom, right = scale.right, chart = scale.chart;
    var chartArea = chart.chartArea, scales = chart.scales;
    var rotation = 0;
    var maxWidth, titleX, titleY;
    var height = bottom - top;
    var width = right - left;
    if (scale.isHorizontal()) {
        titleX = (0, _helpersSegmentJs.a2)(align, left, right);
        if ((0, _helpersSegmentJs.i)(position)) {
            var positionAxisID = Object.keys(position)[0];
            var value = position[positionAxisID];
            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
        } else if (position === "center") titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
        else titleY = offsetFromEdge(scale, position, offset);
        maxWidth = right - left;
    } else {
        if ((0, _helpersSegmentJs.i)(position)) {
            var positionAxisID1 = Object.keys(position)[0];
            var value1 = position[positionAxisID1];
            titleX = scales[positionAxisID1].getPixelForValue(value1) - width + offset;
        } else if (position === "center") titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
        else titleX = offsetFromEdge(scale, position, offset);
        titleY = (0, _helpersSegmentJs.a2)(align, bottom, top);
        rotation = position === "left" ? -(0, _helpersSegmentJs.H) : (0, _helpersSegmentJs.H);
    }
    return {
        titleX: titleX,
        titleY: titleY,
        maxWidth: maxWidth,
        rotation: rotation
    };
}
var Scale = /*#__PURE__*/ function(Element) {
    "use strict";
    (0, _inherits._)(Scale, Element);
    var _super = (0, _createSuper._)(Scale);
    function Scale(cfg) {
        (0, _classCallCheck._)(this, Scale);
        var _this;
        _this = _super.call(this);
        _this.id = cfg.id;
        _this.type = cfg.type;
        _this.options = undefined;
        _this.ctx = cfg.ctx;
        _this.chart = cfg.chart;
        _this.top = undefined;
        _this.bottom = undefined;
        _this.left = undefined;
        _this.right = undefined;
        _this.width = undefined;
        _this.height = undefined;
        _this._margins = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        };
        _this.maxWidth = undefined;
        _this.maxHeight = undefined;
        _this.paddingTop = undefined;
        _this.paddingBottom = undefined;
        _this.paddingLeft = undefined;
        _this.paddingRight = undefined;
        _this.axis = undefined;
        _this.labelRotation = undefined;
        _this.min = undefined;
        _this.max = undefined;
        _this._range = undefined;
        _this.ticks = [];
        _this._gridLineItems = null;
        _this._labelItems = null;
        _this._labelSizes = null;
        _this._length = 0;
        _this._maxLength = 0;
        _this._longestTextCache = {};
        _this._startPixel = undefined;
        _this._endPixel = undefined;
        _this._reversePixels = false;
        _this._userMax = undefined;
        _this._userMin = undefined;
        _this._suggestedMax = undefined;
        _this._suggestedMin = undefined;
        _this._ticksLength = 0;
        _this._borderValue = 0;
        _this._cache = {};
        _this._dataLimitsCached = false;
        _this.$context = undefined;
        return _this;
    }
    (0, _createClass._)(Scale, [
        {
            key: "init",
            value: function init(options) {
                this.options = options.setContext(this.getContext());
                this.axis = options.axis;
                this._userMin = this.parse(options.min);
                this._userMax = this.parse(options.max);
                this._suggestedMin = this.parse(options.suggestedMin);
                this._suggestedMax = this.parse(options.suggestedMax);
            }
        },
        {
            key: "parse",
            value: function parse(raw, index) {
                return raw;
            }
        },
        {
            key: "getUserBounds",
            value: function getUserBounds() {
                var _this = this, _userMin = _this._userMin, _userMax = _this._userMax, _suggestedMin = _this._suggestedMin, _suggestedMax = _this._suggestedMax;
                _userMin = (0, _helpersSegmentJs.O)(_userMin, Number.POSITIVE_INFINITY);
                _userMax = (0, _helpersSegmentJs.O)(_userMax, Number.NEGATIVE_INFINITY);
                _suggestedMin = (0, _helpersSegmentJs.O)(_suggestedMin, Number.POSITIVE_INFINITY);
                _suggestedMax = (0, _helpersSegmentJs.O)(_suggestedMax, Number.NEGATIVE_INFINITY);
                return {
                    min: (0, _helpersSegmentJs.O)(_userMin, _suggestedMin),
                    max: (0, _helpersSegmentJs.O)(_userMax, _suggestedMax),
                    minDefined: (0, _helpersSegmentJs.g)(_userMin),
                    maxDefined: (0, _helpersSegmentJs.g)(_userMax)
                };
            }
        },
        {
            key: "getMinMax",
            value: function getMinMax(canStack) {
                var _this_getUserBounds = this.getUserBounds(), min = _this_getUserBounds.min, max = _this_getUserBounds.max, minDefined = _this_getUserBounds.minDefined, maxDefined = _this_getUserBounds.maxDefined;
                var range;
                if (minDefined && maxDefined) return {
                    min: min,
                    max: max
                };
                var metas = this.getMatchingVisibleMetas();
                for(var i = 0, ilen = metas.length; i < ilen; ++i){
                    range = metas[i].controller.getMinMax(this, canStack);
                    if (!minDefined) min = Math.min(min, range.min);
                    if (!maxDefined) max = Math.max(max, range.max);
                }
                min = maxDefined && min > max ? max : min;
                max = minDefined && min > max ? min : max;
                return {
                    min: (0, _helpersSegmentJs.O)(min, (0, _helpersSegmentJs.O)(max, min)),
                    max: (0, _helpersSegmentJs.O)(max, (0, _helpersSegmentJs.O)(min, max))
                };
            }
        },
        {
            key: "getPadding",
            value: function getPadding() {
                return {
                    left: this.paddingLeft || 0,
                    top: this.paddingTop || 0,
                    right: this.paddingRight || 0,
                    bottom: this.paddingBottom || 0
                };
            }
        },
        {
            key: "getTicks",
            value: function getTicks() {
                return this.ticks;
            }
        },
        {
            key: "getLabels",
            value: function getLabels() {
                var data = this.chart.data;
                return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
            }
        },
        {
            key: "getLabelItems",
            value: function getLabelItems() {
                var chartArea = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.chart.chartArea;
                var items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
                return items;
            }
        },
        {
            key: "beforeLayout",
            value: function beforeLayout() {
                this._cache = {};
                this._dataLimitsCached = false;
            }
        },
        {
            key: "beforeUpdate",
            value: function beforeUpdate() {
                (0, _helpersSegmentJs.Q)(this.options.beforeUpdate, [
                    this
                ]);
            }
        },
        {
            key: "update",
            value: function update(maxWidth, maxHeight, margins) {
                var _this_options = this.options, beginAtZero = _this_options.beginAtZero, grace = _this_options.grace, tickOpts = _this_options.ticks;
                var sampleSize = tickOpts.sampleSize;
                this.beforeUpdate();
                this.maxWidth = maxWidth;
                this.maxHeight = maxHeight;
                this._margins = margins = Object.assign({
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                }, margins);
                this.ticks = null;
                this._labelSizes = null;
                this._gridLineItems = null;
                this._labelItems = null;
                this.beforeSetDimensions();
                this.setDimensions();
                this.afterSetDimensions();
                this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
                if (!this._dataLimitsCached) {
                    this.beforeDataLimits();
                    this.determineDataLimits();
                    this.afterDataLimits();
                    this._range = (0, _helpersSegmentJs.R)(this, grace, beginAtZero);
                    this._dataLimitsCached = true;
                }
                this.beforeBuildTicks();
                this.ticks = this.buildTicks() || [];
                this.afterBuildTicks();
                var samplingEnabled = sampleSize < this.ticks.length;
                this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
                this.configure();
                this.beforeCalculateLabelRotation();
                this.calculateLabelRotation();
                this.afterCalculateLabelRotation();
                if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
                    this.ticks = autoSkip(this, this.ticks);
                    this._labelSizes = null;
                    this.afterAutoSkip();
                }
                if (samplingEnabled) this._convertTicksToLabels(this.ticks);
                this.beforeFit();
                this.fit();
                this.afterFit();
                this.afterUpdate();
            }
        },
        {
            key: "configure",
            value: function configure() {
                var reversePixels = this.options.reverse;
                var startPixel, endPixel;
                if (this.isHorizontal()) {
                    startPixel = this.left;
                    endPixel = this.right;
                } else {
                    startPixel = this.top;
                    endPixel = this.bottom;
                    reversePixels = !reversePixels;
                }
                this._startPixel = startPixel;
                this._endPixel = endPixel;
                this._reversePixels = reversePixels;
                this._length = endPixel - startPixel;
                this._alignToPixels = this.options.alignToPixels;
            }
        },
        {
            key: "afterUpdate",
            value: function afterUpdate() {
                (0, _helpersSegmentJs.Q)(this.options.afterUpdate, [
                    this
                ]);
            }
        },
        {
            key: "beforeSetDimensions",
            value: function beforeSetDimensions() {
                (0, _helpersSegmentJs.Q)(this.options.beforeSetDimensions, [
                    this
                ]);
            }
        },
        {
            key: "setDimensions",
            value: function setDimensions() {
                if (this.isHorizontal()) {
                    this.width = this.maxWidth;
                    this.left = 0;
                    this.right = this.width;
                } else {
                    this.height = this.maxHeight;
                    this.top = 0;
                    this.bottom = this.height;
                }
                this.paddingLeft = 0;
                this.paddingTop = 0;
                this.paddingRight = 0;
                this.paddingBottom = 0;
            }
        },
        {
            key: "afterSetDimensions",
            value: function afterSetDimensions() {
                (0, _helpersSegmentJs.Q)(this.options.afterSetDimensions, [
                    this
                ]);
            }
        },
        {
            key: "_callHooks",
            value: function _callHooks(name) {
                this.chart.notifyPlugins(name, this.getContext());
                (0, _helpersSegmentJs.Q)(this.options[name], [
                    this
                ]);
            }
        },
        {
            key: "beforeDataLimits",
            value: function beforeDataLimits() {
                this._callHooks("beforeDataLimits");
            }
        },
        {
            key: "determineDataLimits",
            value: function determineDataLimits() {}
        },
        {
            key: "afterDataLimits",
            value: function afterDataLimits() {
                this._callHooks("afterDataLimits");
            }
        },
        {
            key: "beforeBuildTicks",
            value: function beforeBuildTicks() {
                this._callHooks("beforeBuildTicks");
            }
        },
        {
            key: "buildTicks",
            value: function buildTicks() {
                return [];
            }
        },
        {
            key: "afterBuildTicks",
            value: function afterBuildTicks() {
                this._callHooks("afterBuildTicks");
            }
        },
        {
            key: "beforeTickToLabelConversion",
            value: function beforeTickToLabelConversion() {
                (0, _helpersSegmentJs.Q)(this.options.beforeTickToLabelConversion, [
                    this
                ]);
            }
        },
        {
            key: "generateTickLabels",
            value: function generateTickLabels(ticks) {
                var tickOpts = this.options.ticks;
                var i, ilen, tick;
                for(i = 0, ilen = ticks.length; i < ilen; i++){
                    tick = ticks[i];
                    tick.label = (0, _helpersSegmentJs.Q)(tickOpts.callback, [
                        tick.value,
                        i,
                        ticks
                    ], this);
                }
            }
        },
        {
            key: "afterTickToLabelConversion",
            value: function afterTickToLabelConversion() {
                (0, _helpersSegmentJs.Q)(this.options.afterTickToLabelConversion, [
                    this
                ]);
            }
        },
        {
            key: "beforeCalculateLabelRotation",
            value: function beforeCalculateLabelRotation() {
                (0, _helpersSegmentJs.Q)(this.options.beforeCalculateLabelRotation, [
                    this
                ]);
            }
        },
        {
            key: "calculateLabelRotation",
            value: function calculateLabelRotation() {
                var options = this.options;
                var tickOpts = options.ticks;
                var numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
                var minRotation = tickOpts.minRotation || 0;
                var maxRotation = tickOpts.maxRotation;
                var labelRotation = minRotation;
                var tickWidth, maxHeight, maxLabelDiagonal;
                if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
                    this.labelRotation = minRotation;
                    return;
                }
                var labelSizes = this._getLabelSizes();
                var maxLabelWidth = labelSizes.widest.width;
                var maxLabelHeight = labelSizes.highest.height;
                var maxWidth = (0, _helpersSegmentJs.S)(this.chart.width - maxLabelWidth, 0, this.maxWidth);
                tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
                if (maxLabelWidth + 6 > tickWidth) {
                    tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
                    maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
                    maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
                    labelRotation = (0, _helpersSegmentJs.U)(Math.min(Math.asin((0, _helpersSegmentJs.S)((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin((0, _helpersSegmentJs.S)(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin((0, _helpersSegmentJs.S)(maxLabelHeight / maxLabelDiagonal, -1, 1))));
                    labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
                }
                this.labelRotation = labelRotation;
            }
        },
        {
            key: "afterCalculateLabelRotation",
            value: function afterCalculateLabelRotation() {
                (0, _helpersSegmentJs.Q)(this.options.afterCalculateLabelRotation, [
                    this
                ]);
            }
        },
        {
            key: "afterAutoSkip",
            value: function afterAutoSkip() {}
        },
        {
            key: "beforeFit",
            value: function beforeFit() {
                (0, _helpersSegmentJs.Q)(this.options.beforeFit, [
                    this
                ]);
            }
        },
        {
            key: "fit",
            value: function fit() {
                var minSize = {
                    width: 0,
                    height: 0
                };
                var _this = this, chart = _this.chart, _this_options = _this.options, tickOpts = _this_options.ticks, titleOpts = _this_options.title, gridOpts = _this_options.grid;
                var display = this._isVisible();
                var isHorizontal = this.isHorizontal();
                if (display) {
                    var titleHeight = getTitleHeight(titleOpts, chart.options.font);
                    if (isHorizontal) {
                        minSize.width = this.maxWidth;
                        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
                    } else {
                        minSize.height = this.maxHeight;
                        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
                    }
                    if (tickOpts.display && this.ticks.length) {
                        var _this__getLabelSizes = this._getLabelSizes(), first = _this__getLabelSizes.first, last = _this__getLabelSizes.last, widest = _this__getLabelSizes.widest, highest = _this__getLabelSizes.highest;
                        var tickPadding = tickOpts.padding * 2;
                        var angleRadians = (0, _helpersSegmentJs.t)(this.labelRotation);
                        var cos = Math.cos(angleRadians);
                        var sin = Math.sin(angleRadians);
                        if (isHorizontal) {
                            var labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                            minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
                        } else {
                            var labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                            minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
                        }
                        this._calculatePadding(first, last, sin, cos);
                    }
                }
                this._handleMargins();
                if (isHorizontal) {
                    this.width = this._length = chart.width - this._margins.left - this._margins.right;
                    this.height = minSize.height;
                } else {
                    this.width = minSize.width;
                    this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
                }
            }
        },
        {
            key: "_calculatePadding",
            value: function _calculatePadding(first, last, sin, cos) {
                var _this_options = this.options, _this_options_ticks = _this_options.ticks, align = _this_options_ticks.align, padding = _this_options_ticks.padding, position = _this_options.position;
                var isRotated = this.labelRotation !== 0;
                var labelsBelowTicks = position !== "top" && this.axis === "x";
                if (this.isHorizontal()) {
                    var offsetLeft = this.getPixelForTick(0) - this.left;
                    var offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
                    var paddingLeft = 0;
                    var paddingRight = 0;
                    if (isRotated) {
                        if (labelsBelowTicks) {
                            paddingLeft = cos * first.width;
                            paddingRight = sin * last.height;
                        } else {
                            paddingLeft = sin * first.height;
                            paddingRight = cos * last.width;
                        }
                    } else if (align === "start") paddingRight = last.width;
                    else if (align === "end") paddingLeft = first.width;
                    else if (align !== "inner") {
                        paddingLeft = first.width / 2;
                        paddingRight = last.width / 2;
                    }
                    this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
                    this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
                } else {
                    var paddingTop = last.height / 2;
                    var paddingBottom = first.height / 2;
                    if (align === "start") {
                        paddingTop = 0;
                        paddingBottom = first.height;
                    } else if (align === "end") {
                        paddingTop = last.height;
                        paddingBottom = 0;
                    }
                    this.paddingTop = paddingTop + padding;
                    this.paddingBottom = paddingBottom + padding;
                }
            }
        },
        {
            key: "_handleMargins",
            value: function _handleMargins() {
                if (this._margins) {
                    this._margins.left = Math.max(this.paddingLeft, this._margins.left);
                    this._margins.top = Math.max(this.paddingTop, this._margins.top);
                    this._margins.right = Math.max(this.paddingRight, this._margins.right);
                    this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
                }
            }
        },
        {
            key: "afterFit",
            value: function afterFit() {
                (0, _helpersSegmentJs.Q)(this.options.afterFit, [
                    this
                ]);
            }
        },
        {
            key: "isHorizontal",
            value: function isHorizontal() {
                var _this_options = this.options, axis = _this_options.axis, position = _this_options.position;
                return position === "top" || position === "bottom" || axis === "x";
            }
        },
        {
            key: "isFullSize",
            value: function isFullSize() {
                return this.options.fullSize;
            }
        },
        {
            key: "_convertTicksToLabels",
            value: function _convertTicksToLabels(ticks) {
                this.beforeTickToLabelConversion();
                this.generateTickLabels(ticks);
                var i, ilen;
                for(i = 0, ilen = ticks.length; i < ilen; i++)if ((0, _helpersSegmentJs.k)(ticks[i].label)) {
                    ticks.splice(i, 1);
                    ilen--;
                    i--;
                }
                this.afterTickToLabelConversion();
            }
        },
        {
            key: "_getLabelSizes",
            value: function _getLabelSizes() {
                var labelSizes = this._labelSizes;
                if (!labelSizes) {
                    var sampleSize = this.options.ticks.sampleSize;
                    var ticks = this.ticks;
                    if (sampleSize < ticks.length) ticks = sample(ticks, sampleSize);
                    this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
                }
                return labelSizes;
            }
        },
        {
            key: "_computeLabelSizes",
            value: function _computeLabelSizes(ticks, length, maxTicksLimit) {
                var _this = this, ctx = _this.ctx, caches = _this._longestTextCache;
                var widths = [];
                var heights = [];
                var increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
                var widestLabelSize = 0;
                var highestLabelSize = 0;
                var i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
                for(i = 0; i < length; i += increment){
                    label = ticks[i].label;
                    tickFont = this._resolveTickFontOptions(i);
                    ctx.font = fontString = tickFont.string;
                    cache = caches[fontString] = caches[fontString] || {
                        data: {},
                        gc: []
                    };
                    lineHeight = tickFont.lineHeight;
                    width = height = 0;
                    if (!(0, _helpersSegmentJs.k)(label) && !(0, _helpersSegmentJs.b)(label)) {
                        width = (0, _helpersSegmentJs.V)(ctx, cache.data, cache.gc, width, label);
                        height = lineHeight;
                    } else if ((0, _helpersSegmentJs.b)(label)) for(j = 0, jlen = label.length; j < jlen; ++j){
                        nestedLabel = label[j];
                        if (!(0, _helpersSegmentJs.k)(nestedLabel) && !(0, _helpersSegmentJs.b)(nestedLabel)) {
                            width = (0, _helpersSegmentJs.V)(ctx, cache.data, cache.gc, width, nestedLabel);
                            height += lineHeight;
                        }
                    }
                    widths.push(width);
                    heights.push(height);
                    widestLabelSize = Math.max(width, widestLabelSize);
                    highestLabelSize = Math.max(height, highestLabelSize);
                }
                garbageCollect(caches, length);
                var widest = widths.indexOf(widestLabelSize);
                var highest = heights.indexOf(highestLabelSize);
                var valueAt = function(idx) {
                    return {
                        width: widths[idx] || 0,
                        height: heights[idx] || 0
                    };
                };
                return {
                    first: valueAt(0),
                    last: valueAt(length - 1),
                    widest: valueAt(widest),
                    highest: valueAt(highest),
                    widths: widths,
                    heights: heights
                };
            }
        },
        {
            key: "getLabelForValue",
            value: function getLabelForValue(value) {
                return value;
            }
        },
        {
            key: "getPixelForValue",
            value: function getPixelForValue(value, index) {
                return NaN;
            }
        },
        {
            key: "getValueForPixel",
            value: function getValueForPixel(pixel) {}
        },
        {
            key: "getPixelForTick",
            value: function getPixelForTick(index) {
                var ticks = this.ticks;
                if (index < 0 || index > ticks.length - 1) return null;
                return this.getPixelForValue(ticks[index].value);
            }
        },
        {
            key: "getPixelForDecimal",
            value: function getPixelForDecimal(decimal) {
                if (this._reversePixels) decimal = 1 - decimal;
                var pixel = this._startPixel + decimal * this._length;
                return (0, _helpersSegmentJs.W)(this._alignToPixels ? (0, _helpersSegmentJs.X)(this.chart, pixel, 0) : pixel);
            }
        },
        {
            key: "getDecimalForPixel",
            value: function getDecimalForPixel(pixel) {
                var decimal = (pixel - this._startPixel) / this._length;
                return this._reversePixels ? 1 - decimal : decimal;
            }
        },
        {
            key: "getBasePixel",
            value: function getBasePixel() {
                return this.getPixelForValue(this.getBaseValue());
            }
        },
        {
            key: "getBaseValue",
            value: function getBaseValue() {
                var _this = this, min = _this.min, max = _this.max;
                return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
            }
        },
        {
            key: "getContext",
            value: function getContext(index) {
                var ticks = this.ticks || [];
                if (index >= 0 && index < ticks.length) {
                    var tick = ticks[index];
                    return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
                }
                return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
            }
        },
        {
            key: "_tickSize",
            value: function _tickSize() {
                var optionTicks = this.options.ticks;
                var rot = (0, _helpersSegmentJs.t)(this.labelRotation);
                var cos = Math.abs(Math.cos(rot));
                var sin = Math.abs(Math.sin(rot));
                var labelSizes = this._getLabelSizes();
                var padding = optionTicks.autoSkipPadding || 0;
                var w = labelSizes ? labelSizes.widest.width + padding : 0;
                var h = labelSizes ? labelSizes.highest.height + padding : 0;
                return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
            }
        },
        {
            key: "_isVisible",
            value: function _isVisible() {
                var display = this.options.display;
                if (display !== "auto") return !!display;
                return this.getMatchingVisibleMetas().length > 0;
            }
        },
        {
            key: "_computeGridLineItems",
            value: function _computeGridLineItems(chartArea) {
                var axis = this.axis;
                var chart = this.chart;
                var options = this.options;
                var grid = options.grid, position = options.position, border = options.border;
                var offset = grid.offset;
                var isHorizontal = this.isHorizontal();
                var ticks = this.ticks;
                var ticksLength = ticks.length + (offset ? 1 : 0);
                var tl = getTickMarkLength(grid);
                var items = [];
                var borderOpts = border.setContext(this.getContext());
                var axisWidth = borderOpts.display ? borderOpts.width : 0;
                var axisHalfWidth = axisWidth / 2;
                var alignBorderValue = function alignBorderValue(pixel) {
                    return (0, _helpersSegmentJs.X)(chart, pixel, axisWidth);
                };
                var borderValue, i, lineValue, alignedLineValue;
                var tx1, ty1, tx2, ty2, x1, y1, x2, y2;
                if (position === "top") {
                    borderValue = alignBorderValue(this.bottom);
                    ty1 = this.bottom - tl;
                    ty2 = borderValue - axisHalfWidth;
                    y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
                    y2 = chartArea.bottom;
                } else if (position === "bottom") {
                    borderValue = alignBorderValue(this.top);
                    y1 = chartArea.top;
                    y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
                    ty1 = borderValue + axisHalfWidth;
                    ty2 = this.top + tl;
                } else if (position === "left") {
                    borderValue = alignBorderValue(this.right);
                    tx1 = this.right - tl;
                    tx2 = borderValue - axisHalfWidth;
                    x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
                    x2 = chartArea.right;
                } else if (position === "right") {
                    borderValue = alignBorderValue(this.left);
                    x1 = chartArea.left;
                    x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
                    tx1 = borderValue + axisHalfWidth;
                    tx2 = this.left + tl;
                } else if (axis === "x") {
                    if (position === "center") borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
                    else if ((0, _helpersSegmentJs.i)(position)) {
                        var positionAxisID = Object.keys(position)[0];
                        var value = position[positionAxisID];
                        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
                    }
                    y1 = chartArea.top;
                    y2 = chartArea.bottom;
                    ty1 = borderValue + axisHalfWidth;
                    ty2 = ty1 + tl;
                } else if (axis === "y") {
                    if (position === "center") borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
                    else if ((0, _helpersSegmentJs.i)(position)) {
                        var positionAxisID1 = Object.keys(position)[0];
                        var value1 = position[positionAxisID1];
                        borderValue = alignBorderValue(this.chart.scales[positionAxisID1].getPixelForValue(value1));
                    }
                    tx1 = borderValue - axisHalfWidth;
                    tx2 = tx1 - tl;
                    x1 = chartArea.left;
                    x2 = chartArea.right;
                }
                var limit = (0, _helpersSegmentJs.v)(options.ticks.maxTicksLimit, ticksLength);
                var step = Math.max(1, Math.ceil(ticksLength / limit));
                for(i = 0; i < ticksLength; i += step){
                    var context = this.getContext(i);
                    var optsAtIndex = grid.setContext(context);
                    var optsAtIndexBorder = border.setContext(context);
                    var lineWidth = optsAtIndex.lineWidth;
                    var lineColor = optsAtIndex.color;
                    var borderDash = optsAtIndexBorder.dash || [];
                    var borderDashOffset = optsAtIndexBorder.dashOffset;
                    var tickWidth = optsAtIndex.tickWidth;
                    var tickColor = optsAtIndex.tickColor;
                    var tickBorderDash = optsAtIndex.tickBorderDash || [];
                    var tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
                    lineValue = getPixelForGridLine(this, i, offset);
                    if (lineValue === undefined) continue;
                    alignedLineValue = (0, _helpersSegmentJs.X)(chart, lineValue, lineWidth);
                    if (isHorizontal) tx1 = tx2 = x1 = x2 = alignedLineValue;
                    else ty1 = ty2 = y1 = y2 = alignedLineValue;
                    items.push({
                        tx1: tx1,
                        ty1: ty1,
                        tx2: tx2,
                        ty2: ty2,
                        x1: x1,
                        y1: y1,
                        x2: x2,
                        y2: y2,
                        width: lineWidth,
                        color: lineColor,
                        borderDash: borderDash,
                        borderDashOffset: borderDashOffset,
                        tickWidth: tickWidth,
                        tickColor: tickColor,
                        tickBorderDash: tickBorderDash,
                        tickBorderDashOffset: tickBorderDashOffset
                    });
                }
                this._ticksLength = ticksLength;
                this._borderValue = borderValue;
                return items;
            }
        },
        {
            key: "_computeLabelItems",
            value: function _computeLabelItems(chartArea) {
                var axis = this.axis;
                var options = this.options;
                var position = options.position, optionTicks = options.ticks;
                var isHorizontal = this.isHorizontal();
                var ticks = this.ticks;
                var align = optionTicks.align, crossAlign = optionTicks.crossAlign, padding = optionTicks.padding, mirror = optionTicks.mirror;
                var tl = getTickMarkLength(options.grid);
                var tickAndPadding = tl + padding;
                var hTickAndPadding = mirror ? -padding : tickAndPadding;
                var rotation = -(0, _helpersSegmentJs.t)(this.labelRotation);
                var items = [];
                var i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
                var textBaseline = "middle";
                if (position === "top") {
                    y = this.bottom - hTickAndPadding;
                    textAlign = this._getXAxisLabelAlignment();
                } else if (position === "bottom") {
                    y = this.top + hTickAndPadding;
                    textAlign = this._getXAxisLabelAlignment();
                } else if (position === "left") {
                    var ret = this._getYAxisLabelAlignment(tl);
                    textAlign = ret.textAlign;
                    x = ret.x;
                } else if (position === "right") {
                    var ret1 = this._getYAxisLabelAlignment(tl);
                    textAlign = ret1.textAlign;
                    x = ret1.x;
                } else if (axis === "x") {
                    if (position === "center") y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
                    else if ((0, _helpersSegmentJs.i)(position)) {
                        var positionAxisID = Object.keys(position)[0];
                        var value = position[positionAxisID];
                        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
                    }
                    textAlign = this._getXAxisLabelAlignment();
                } else if (axis === "y") {
                    if (position === "center") x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
                    else if ((0, _helpersSegmentJs.i)(position)) {
                        var positionAxisID1 = Object.keys(position)[0];
                        var value1 = position[positionAxisID1];
                        x = this.chart.scales[positionAxisID1].getPixelForValue(value1);
                    }
                    textAlign = this._getYAxisLabelAlignment(tl).textAlign;
                }
                if (axis === "y") {
                    if (align === "start") textBaseline = "top";
                    else if (align === "end") textBaseline = "bottom";
                }
                var labelSizes = this._getLabelSizes();
                for(i = 0, ilen = ticks.length; i < ilen; ++i){
                    tick = ticks[i];
                    label = tick.label;
                    var optsAtIndex = optionTicks.setContext(this.getContext(i));
                    pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
                    font = this._resolveTickFontOptions(i);
                    lineHeight = font.lineHeight;
                    lineCount = (0, _helpersSegmentJs.b)(label) ? label.length : 1;
                    var halfCount = lineCount / 2;
                    var color = optsAtIndex.color;
                    var strokeColor = optsAtIndex.textStrokeColor;
                    var strokeWidth = optsAtIndex.textStrokeWidth;
                    var tickTextAlign = textAlign;
                    if (isHorizontal) {
                        x = pixel;
                        if (textAlign === "inner") {
                            if (i === ilen - 1) tickTextAlign = !this.options.reverse ? "right" : "left";
                            else if (i === 0) tickTextAlign = !this.options.reverse ? "left" : "right";
                            else tickTextAlign = "center";
                        }
                        if (position === "top") {
                            if (crossAlign === "near" || rotation !== 0) textOffset = -lineCount * lineHeight + lineHeight / 2;
                            else if (crossAlign === "center") textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                            else textOffset = -labelSizes.highest.height + lineHeight / 2;
                        } else {
                            if (crossAlign === "near" || rotation !== 0) textOffset = lineHeight / 2;
                            else if (crossAlign === "center") textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                            else textOffset = labelSizes.highest.height - lineCount * lineHeight;
                        }
                        if (mirror) textOffset *= -1;
                        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) x += lineHeight / 2 * Math.sin(rotation);
                    } else {
                        y = pixel;
                        textOffset = (1 - lineCount) * lineHeight / 2;
                    }
                    var backdrop = void 0;
                    if (optsAtIndex.showLabelBackdrop) {
                        var labelPadding = (0, _helpersSegmentJs.E)(optsAtIndex.backdropPadding);
                        var height = labelSizes.heights[i];
                        var width = labelSizes.widths[i];
                        var top = textOffset - labelPadding.top;
                        var left = 0 - labelPadding.left;
                        switch(textBaseline){
                            case "middle":
                                top -= height / 2;
                                break;
                            case "bottom":
                                top -= height;
                                break;
                        }
                        switch(textAlign){
                            case "center":
                                left -= width / 2;
                                break;
                            case "right":
                                left -= width;
                                break;
                            case "inner":
                                if (i === ilen - 1) left -= width;
                                else if (i > 0) left -= width / 2;
                                break;
                        }
                        backdrop = {
                            left: left,
                            top: top,
                            width: width + labelPadding.width,
                            height: height + labelPadding.height,
                            color: optsAtIndex.backdropColor
                        };
                    }
                    items.push({
                        label: label,
                        font: font,
                        textOffset: textOffset,
                        options: {
                            rotation: rotation,
                            color: color,
                            strokeColor: strokeColor,
                            strokeWidth: strokeWidth,
                            textAlign: tickTextAlign,
                            textBaseline: textBaseline,
                            translation: [
                                x,
                                y
                            ],
                            backdrop: backdrop
                        }
                    });
                }
                return items;
            }
        },
        {
            key: "_getXAxisLabelAlignment",
            value: function _getXAxisLabelAlignment() {
                var _this_options = this.options, position = _this_options.position, ticks = _this_options.ticks;
                var rotation = -(0, _helpersSegmentJs.t)(this.labelRotation);
                if (rotation) return position === "top" ? "left" : "right";
                var align = "center";
                if (ticks.align === "start") align = "left";
                else if (ticks.align === "end") align = "right";
                else if (ticks.align === "inner") align = "inner";
                return align;
            }
        },
        {
            key: "_getYAxisLabelAlignment",
            value: function _getYAxisLabelAlignment(tl) {
                var _this_options = this.options, position = _this_options.position, _this_options_ticks = _this_options.ticks, crossAlign = _this_options_ticks.crossAlign, mirror = _this_options_ticks.mirror, padding = _this_options_ticks.padding;
                var labelSizes = this._getLabelSizes();
                var tickAndPadding = tl + padding;
                var widest = labelSizes.widest.width;
                var textAlign;
                var x;
                if (position === "left") {
                    if (mirror) {
                        x = this.right + padding;
                        if (crossAlign === "near") textAlign = "left";
                        else if (crossAlign === "center") {
                            textAlign = "center";
                            x += widest / 2;
                        } else {
                            textAlign = "right";
                            x += widest;
                        }
                    } else {
                        x = this.right - tickAndPadding;
                        if (crossAlign === "near") textAlign = "right";
                        else if (crossAlign === "center") {
                            textAlign = "center";
                            x -= widest / 2;
                        } else {
                            textAlign = "left";
                            x = this.left;
                        }
                    }
                } else if (position === "right") {
                    if (mirror) {
                        x = this.left + padding;
                        if (crossAlign === "near") textAlign = "right";
                        else if (crossAlign === "center") {
                            textAlign = "center";
                            x -= widest / 2;
                        } else {
                            textAlign = "left";
                            x -= widest;
                        }
                    } else {
                        x = this.left + tickAndPadding;
                        if (crossAlign === "near") textAlign = "left";
                        else if (crossAlign === "center") {
                            textAlign = "center";
                            x += widest / 2;
                        } else {
                            textAlign = "right";
                            x = this.right;
                        }
                    }
                } else textAlign = "right";
                return {
                    textAlign: textAlign,
                    x: x
                };
            }
        },
        {
            key: "_computeLabelArea",
            value: function _computeLabelArea() {
                if (this.options.ticks.mirror) return;
                var chart = this.chart;
                var position = this.options.position;
                if (position === "left" || position === "right") return {
                    top: 0,
                    left: this.left,
                    bottom: chart.height,
                    right: this.right
                };
                if (position === "top" || position === "bottom") return {
                    top: this.top,
                    left: 0,
                    bottom: this.bottom,
                    right: chart.width
                };
            }
        },
        {
            key: "drawBackground",
            value: function drawBackground() {
                var _this = this, ctx = _this.ctx, backgroundColor = _this.options.backgroundColor, left = _this.left, top = _this.top, width = _this.width, height = _this.height;
                if (backgroundColor) {
                    ctx.save();
                    ctx.fillStyle = backgroundColor;
                    ctx.fillRect(left, top, width, height);
                    ctx.restore();
                }
            }
        },
        {
            key: "getLineWidthForValue",
            value: function getLineWidthForValue(value) {
                var grid = this.options.grid;
                if (!this._isVisible() || !grid.display) return 0;
                var ticks = this.ticks;
                var index = ticks.findIndex(function(t) {
                    return t.value === value;
                });
                if (index >= 0) {
                    var opts = grid.setContext(this.getContext(index));
                    return opts.lineWidth;
                }
                return 0;
            }
        },
        {
            key: "drawGrid",
            value: function drawGrid(chartArea) {
                var grid = this.options.grid;
                var ctx = this.ctx;
                var items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
                var i, ilen;
                var drawLine = function(p1, p2, style) {
                    if (!style.width || !style.color) return;
                    ctx.save();
                    ctx.lineWidth = style.width;
                    ctx.strokeStyle = style.color;
                    ctx.setLineDash(style.borderDash || []);
                    ctx.lineDashOffset = style.borderDashOffset;
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                    ctx.restore();
                };
                if (grid.display) for(i = 0, ilen = items.length; i < ilen; ++i){
                    var item = items[i];
                    if (grid.drawOnChartArea) drawLine({
                        x: item.x1,
                        y: item.y1
                    }, {
                        x: item.x2,
                        y: item.y2
                    }, item);
                    if (grid.drawTicks) drawLine({
                        x: item.tx1,
                        y: item.ty1
                    }, {
                        x: item.tx2,
                        y: item.ty2
                    }, {
                        color: item.tickColor,
                        width: item.tickWidth,
                        borderDash: item.tickBorderDash,
                        borderDashOffset: item.tickBorderDashOffset
                    });
                }
            }
        },
        {
            key: "drawBorder",
            value: function drawBorder() {
                var _this = this, chart = _this.chart, ctx = _this.ctx, _this_options = _this.options, border = _this_options.border, grid = _this_options.grid;
                var borderOpts = border.setContext(this.getContext());
                var axisWidth = border.display ? borderOpts.width : 0;
                if (!axisWidth) return;
                var lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
                var borderValue = this._borderValue;
                var x1, x2, y1, y2;
                if (this.isHorizontal()) {
                    x1 = (0, _helpersSegmentJs.X)(chart, this.left, axisWidth) - axisWidth / 2;
                    x2 = (0, _helpersSegmentJs.X)(chart, this.right, lastLineWidth) + lastLineWidth / 2;
                    y1 = y2 = borderValue;
                } else {
                    y1 = (0, _helpersSegmentJs.X)(chart, this.top, axisWidth) - axisWidth / 2;
                    y2 = (0, _helpersSegmentJs.X)(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
                    x1 = x2 = borderValue;
                }
                ctx.save();
                ctx.lineWidth = borderOpts.width;
                ctx.strokeStyle = borderOpts.color;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                ctx.restore();
            }
        },
        {
            key: "drawLabels",
            value: function drawLabels(chartArea) {
                var optionTicks = this.options.ticks;
                if (!optionTicks.display) return;
                var ctx = this.ctx;
                var area = this._computeLabelArea();
                if (area) (0, _helpersSegmentJs.Y)(ctx, area);
                var items = this.getLabelItems(chartArea);
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var item = _step.value;
                        var renderTextOptions = item.options;
                        var tickFont = item.font;
                        var label = item.label;
                        var y = item.textOffset;
                        (0, _helpersSegmentJs.Z)(ctx, label, 0, y, tickFont, renderTextOptions);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                if (area) (0, _helpersSegmentJs.$)(ctx);
            }
        },
        {
            key: "drawTitle",
            value: function drawTitle() {
                var _this = this, ctx = _this.ctx, _this_options = _this.options, position = _this_options.position, title = _this_options.title, reverse = _this_options.reverse;
                if (!title.display) return;
                var font = (0, _helpersSegmentJs.a0)(title.font);
                var padding = (0, _helpersSegmentJs.E)(title.padding);
                var align = title.align;
                var offset = font.lineHeight / 2;
                if (position === "bottom" || position === "center" || (0, _helpersSegmentJs.i)(position)) {
                    offset += padding.bottom;
                    if ((0, _helpersSegmentJs.b)(title.text)) offset += font.lineHeight * (title.text.length - 1);
                } else offset += padding.top;
                var _titleArgs = titleArgs(this, offset, position, align), titleX = _titleArgs.titleX, titleY = _titleArgs.titleY, maxWidth = _titleArgs.maxWidth, rotation = _titleArgs.rotation;
                (0, _helpersSegmentJs.Z)(ctx, title.text, 0, 0, font, {
                    color: title.color,
                    maxWidth: maxWidth,
                    rotation: rotation,
                    textAlign: titleAlign(align, position, reverse),
                    textBaseline: "middle",
                    translation: [
                        titleX,
                        titleY
                    ]
                });
            }
        },
        {
            key: "draw",
            value: function draw(chartArea) {
                if (!this._isVisible()) return;
                this.drawBackground();
                this.drawGrid(chartArea);
                this.drawBorder();
                this.drawTitle();
                this.drawLabels(chartArea);
            }
        },
        {
            key: "_layers",
            value: function _layers() {
                var _this = this;
                var opts = this.options;
                var tz = opts.ticks && opts.ticks.z || 0;
                var gz = (0, _helpersSegmentJs.v)(opts.grid && opts.grid.z, -1);
                var bz = (0, _helpersSegmentJs.v)(opts.border && opts.border.z, 0);
                if (!this._isVisible() || this.draw !== Scale.prototype.draw) return [
                    {
                        z: tz,
                        draw: function(chartArea) {
                            _this.draw(chartArea);
                        }
                    }
                ];
                return [
                    {
                        z: gz,
                        draw: function(chartArea) {
                            _this.drawBackground();
                            _this.drawGrid(chartArea);
                            _this.drawTitle();
                        }
                    },
                    {
                        z: bz,
                        draw: function() {
                            _this.drawBorder();
                        }
                    },
                    {
                        z: tz,
                        draw: function(chartArea) {
                            _this.drawLabels(chartArea);
                        }
                    }
                ];
            }
        },
        {
            key: "getMatchingVisibleMetas",
            value: function getMatchingVisibleMetas(type) {
                var metas = this.chart.getSortedVisibleDatasetMetas();
                var axisID = this.axis + "AxisID";
                var result = [];
                var i, ilen;
                for(i = 0, ilen = metas.length; i < ilen; ++i){
                    var meta = metas[i];
                    if (meta[axisID] === this.id && (!type || meta.type === type)) result.push(meta);
                }
                return result;
            }
        },
        {
            key: "_resolveTickFontOptions",
            value: function _resolveTickFontOptions(index) {
                var opts = this.options.ticks.setContext(this.getContext(index));
                return (0, _helpersSegmentJs.a0)(opts.font);
            }
        },
        {
            key: "_maxDigits",
            value: function _maxDigits() {
                var fontSize = this._resolveTickFontOptions(0).lineHeight;
                return (this.isHorizontal() ? this.width : this.height) / fontSize;
            }
        }
    ]);
    return Scale;
}((0, _wrapNativeSuper._)(Element));
var TypedRegistry = /*#__PURE__*/ function() {
    "use strict";
    function TypedRegistry(type, scope, override) {
        (0, _classCallCheck._)(this, TypedRegistry);
        this.type = type;
        this.scope = scope;
        this.override = override;
        this.items = Object.create(null);
    }
    (0, _createClass._)(TypedRegistry, [
        {
            key: "isForType",
            value: function isForType(type) {
                return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
            }
        },
        {
            key: "register",
            value: function register(item) {
                var proto = Object.getPrototypeOf(item);
                var parentScope;
                if (isIChartComponent(proto)) parentScope = this.register(proto);
                var items = this.items;
                var id = item.id;
                var scope = this.scope + "." + id;
                if (!id) throw new Error("class does not have id: " + item);
                if (id in items) return scope;
                items[id] = item;
                registerDefaults(item, scope, parentScope);
                if (this.override) (0, _helpersSegmentJs.d).override(item.id, item.overrides);
                return scope;
            }
        },
        {
            key: "get",
            value: function get(id) {
                return this.items[id];
            }
        },
        {
            key: "unregister",
            value: function unregister(item) {
                var items = this.items;
                var id = item.id;
                var scope = this.scope;
                if (id in items) delete items[id];
                if (scope && id in (0, _helpersSegmentJs.d)[scope]) {
                    delete (0, _helpersSegmentJs.d)[scope][id];
                    if (this.override) delete (0, _helpersSegmentJs.a3)[id];
                }
            }
        }
    ]);
    return TypedRegistry;
}();
function registerDefaults(item, scope, parentScope) {
    var itemDefaults = (0, _helpersSegmentJs.a4)(Object.create(null), [
        parentScope ? (0, _helpersSegmentJs.d).get(parentScope) : {},
        (0, _helpersSegmentJs.d).get(scope),
        item.defaults
    ]);
    (0, _helpersSegmentJs.d).set(scope, itemDefaults);
    if (item.defaultRoutes) routeDefaults(scope, item.defaultRoutes);
    if (item.descriptors) (0, _helpersSegmentJs.d).describe(scope, item.descriptors);
}
function routeDefaults(scope, routes) {
    Object.keys(routes).forEach(function(property) {
        var propertyParts = property.split(".");
        var sourceName = propertyParts.pop();
        var sourceScope = [
            scope
        ].concat(propertyParts).join(".");
        var parts = routes[property].split(".");
        var targetName = parts.pop();
        var targetScope = parts.join(".");
        (0, _helpersSegmentJs.d).route(sourceScope, sourceName, targetScope, targetName);
    });
}
function isIChartComponent(proto) {
    return "id" in proto && "defaults" in proto;
}
var Registry = /*#__PURE__*/ function() {
    "use strict";
    function Registry() {
        (0, _classCallCheck._)(this, Registry);
        this.controllers = new TypedRegistry(DatasetController, "datasets", true);
        this.elements = new TypedRegistry(Element, "elements");
        this.plugins = new TypedRegistry(Object, "plugins");
        this.scales = new TypedRegistry(Scale, "scales");
        this._typedRegistries = [
            this.controllers,
            this.scales,
            this.elements
        ];
    }
    (0, _createClass._)(Registry, [
        {
            key: "add",
            value: function add() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this._each("register", args);
            }
        },
        {
            key: "remove",
            value: function remove() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this._each("unregister", args);
            }
        },
        {
            key: "addControllers",
            value: function addControllers() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this._each("register", args, this.controllers);
            }
        },
        {
            key: "addElements",
            value: function addElements() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this._each("register", args, this.elements);
            }
        },
        {
            key: "addPlugins",
            value: function addPlugins() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this._each("register", args, this.plugins);
            }
        },
        {
            key: "addScales",
            value: function addScales() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this._each("register", args, this.scales);
            }
        },
        {
            key: "getController",
            value: function getController(id) {
                return this._get(id, this.controllers, "controller");
            }
        },
        {
            key: "getElement",
            value: function getElement(id) {
                return this._get(id, this.elements, "element");
            }
        },
        {
            key: "getPlugin",
            value: function getPlugin(id) {
                return this._get(id, this.plugins, "plugin");
            }
        },
        {
            key: "getScale",
            value: function getScale(id) {
                return this._get(id, this.scales, "scale");
            }
        },
        {
            key: "removeControllers",
            value: function removeControllers() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this._each("unregister", args, this.controllers);
            }
        },
        {
            key: "removeElements",
            value: function removeElements() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this._each("unregister", args, this.elements);
            }
        },
        {
            key: "removePlugins",
            value: function removePlugins() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this._each("unregister", args, this.plugins);
            }
        },
        {
            key: "removeScales",
            value: function removeScales() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this._each("unregister", args, this.scales);
            }
        },
        {
            key: "_each",
            value: function _each(method, args, typedRegistry) {
                var _this = this;
                (0, _toConsumableArray._)(args).forEach(function(arg) {
                    var reg = typedRegistry || _this._getRegistryForType(arg);
                    if (typedRegistry || reg.isForType(arg) || reg === _this.plugins && arg.id) _this._exec(method, reg, arg);
                    else (0, _helpersSegmentJs.F)(arg, function(item) {
                        var itemReg = typedRegistry || _this._getRegistryForType(item);
                        _this._exec(method, itemReg, item);
                    });
                });
            }
        },
        {
            key: "_exec",
            value: function _exec(method, registry, component) {
                var camelMethod = (0, _helpersSegmentJs.a5)(method);
                (0, _helpersSegmentJs.Q)(component["before" + camelMethod], [], component);
                registry[method](component);
                (0, _helpersSegmentJs.Q)(component["after" + camelMethod], [], component);
            }
        },
        {
            key: "_getRegistryForType",
            value: function _getRegistryForType(type) {
                for(var i = 0; i < this._typedRegistries.length; i++){
                    var reg = this._typedRegistries[i];
                    if (reg.isForType(type)) return reg;
                }
                return this.plugins;
            }
        },
        {
            key: "_get",
            value: function _get(id, typedRegistry, type) {
                var item = typedRegistry.get(id);
                if (item === undefined) throw new Error('"' + id + '" is not a registered ' + type + ".");
                return item;
            }
        }
    ]);
    return Registry;
}();
var registry = /* #__PURE__ */ new Registry();
var PluginService = /*#__PURE__*/ function() {
    "use strict";
    function PluginService() {
        (0, _classCallCheck._)(this, PluginService);
        this._init = [];
    }
    (0, _createClass._)(PluginService, [
        {
            key: "notify",
            value: function notify(chart, hook, args, filter) {
                if (hook === "beforeInit") {
                    this._init = this._createDescriptors(chart, true);
                    this._notify(this._init, chart, "install");
                }
                var descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
                var result = this._notify(descriptors, chart, hook, args);
                if (hook === "afterDestroy") {
                    this._notify(descriptors, chart, "stop");
                    this._notify(this._init, chart, "uninstall");
                }
                return result;
            }
        },
        {
            key: "_notify",
            value: function _notify(descriptors, chart, hook, args) {
                args = args || {};
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = descriptors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var descriptor = _step.value;
                        var plugin = descriptor.plugin;
                        var method = plugin[hook];
                        var params = [
                            chart,
                            args,
                            descriptor.options
                        ];
                        if ((0, _helpersSegmentJs.Q)(method, params, plugin) === false && args.cancelable) return false;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return true;
            }
        },
        {
            key: "invalidate",
            value: function invalidate() {
                if (!(0, _helpersSegmentJs.k)(this._cache)) {
                    this._oldCache = this._cache;
                    this._cache = undefined;
                }
            }
        },
        {
            key: "_descriptors",
            value: function _descriptors(chart) {
                if (this._cache) return this._cache;
                var descriptors = this._cache = this._createDescriptors(chart);
                this._notifyStateChanges(chart);
                return descriptors;
            }
        },
        {
            key: "_createDescriptors",
            value: function _createDescriptors(chart, all) {
                var config = chart && chart.config;
                var options = (0, _helpersSegmentJs.v)(config.options && config.options.plugins, {});
                var plugins = allPlugins(config);
                return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
            }
        },
        {
            key: "_notifyStateChanges",
            value: function _notifyStateChanges(chart) {
                var previousDescriptors = this._oldCache || [];
                var descriptors = this._cache;
                var diff = function(a, b) {
                    return a.filter(function(x) {
                        return !b.some(function(y) {
                            return x.plugin.id === y.plugin.id;
                        });
                    });
                };
                this._notify(diff(previousDescriptors, descriptors), chart, "stop");
                this._notify(diff(descriptors, previousDescriptors), chart, "start");
            }
        }
    ]);
    return PluginService;
}();
function allPlugins(config) {
    var localIds = {};
    var plugins = [];
    var keys = Object.keys(registry.plugins.items);
    for(var i = 0; i < keys.length; i++)plugins.push(registry.getPlugin(keys[i]));
    var local = config.plugins || [];
    for(var i1 = 0; i1 < local.length; i1++){
        var plugin = local[i1];
        if (plugins.indexOf(plugin) === -1) {
            plugins.push(plugin);
            localIds[plugin.id] = true;
        }
    }
    return {
        plugins: plugins,
        localIds: localIds
    };
}
function getOpts(options, all) {
    if (!all && options === false) return null;
    if (options === true) return {};
    return options;
}
function createDescriptors(chart, param, options, all) {
    var plugins = param.plugins, localIds = param.localIds;
    var result = [];
    var context = chart.getContext();
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var plugin = _step.value;
            var id = plugin.id;
            var opts = getOpts(options[id], all);
            if (opts === null) continue;
            result.push({
                plugin: plugin,
                options: pluginOpts(chart.config, {
                    plugin: plugin,
                    local: localIds[id]
                }, opts, context)
            });
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return result;
}
function pluginOpts(config, param, opts, context) {
    var plugin = param.plugin, local = param.local;
    var keys = config.pluginScopeKeys(plugin);
    var scopes = config.getOptionScopes(opts, keys);
    if (local && plugin.defaults) scopes.push(plugin.defaults);
    return config.createResolver(scopes, context, [
        ""
    ], {
        scriptable: false,
        indexable: false,
        allKeys: true
    });
}
function getIndexAxis(type, options) {
    var datasetDefaults = (0, _helpersSegmentJs.d).datasets[type] || {};
    var datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
    var axis = id;
    if (id === "_index_") axis = indexAxis;
    else if (id === "_value_") axis = indexAxis === "x" ? "y" : "x";
    return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id) {
    if (id === "x" || id === "y" || id === "r") return id;
}
function axisFromPosition(position) {
    if (position === "top" || position === "bottom") return "x";
    if (position === "left" || position === "right") return "y";
}
function determineAxis(id) {
    for(var _len = arguments.length, scaleOptions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        scaleOptions[_key - 1] = arguments[_key];
    }
    if (idMatchesAxis(id)) return id;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = scaleOptions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var opts = _step.value;
            var axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
            if (axis) return axis;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    throw new Error("Cannot determine type of '".concat(id, "' axis. Please provide 'axis' or 'position' option."));
}
function getAxisFromDataset(id, axis, dataset) {
    if (dataset[axis + "AxisID"] === id) return {
        axis: axis
    };
}
function retrieveAxisFromDatasets(id, config) {
    if (config.data && config.data.datasets) {
        var boundDs = config.data.datasets.filter(function(d) {
            return d.xAxisID === id || d.yAxisID === id;
        });
        if (boundDs.length) return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
    }
    return {};
}
function mergeScaleConfig(config, options) {
    var chartDefaults = (0, _helpersSegmentJs.a3)[config.type] || {
        scales: {}
    };
    var configScales = options.scales || {};
    var chartIndexAxis = getIndexAxis(config.type, options);
    var scales = Object.create(null);
    Object.keys(configScales).forEach(function(id) {
        var scaleConf = configScales[id];
        if (!(0, _helpersSegmentJs.i)(scaleConf)) return console.error("Invalid scale configuration for scale: ".concat(id));
        if (scaleConf._proxy) return console.warn("Ignoring resolver passed as options for scale: ".concat(id));
        var axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), (0, _helpersSegmentJs.d).scales[scaleConf.type]);
        var defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
        var defaultScaleOptions = chartDefaults.scales || {};
        scales[id] = (0, _helpersSegmentJs.ab)(Object.create(null), [
            {
                axis: axis
            },
            scaleConf,
            defaultScaleOptions[axis],
            defaultScaleOptions[defaultId]
        ]);
    });
    config.data.datasets.forEach(function(dataset) {
        var type = dataset.type || config.type;
        var indexAxis = dataset.indexAxis || getIndexAxis(type, options);
        var datasetDefaults = (0, _helpersSegmentJs.a3)[type] || {};
        var defaultScaleOptions = datasetDefaults.scales || {};
        Object.keys(defaultScaleOptions).forEach(function(defaultID) {
            var axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
            var id = dataset[axis + "AxisID"] || axis;
            scales[id] = scales[id] || Object.create(null);
            (0, _helpersSegmentJs.ab)(scales[id], [
                {
                    axis: axis
                },
                configScales[id],
                defaultScaleOptions[defaultID]
            ]);
        });
    });
    Object.keys(scales).forEach(function(key) {
        var scale = scales[key];
        (0, _helpersSegmentJs.ab)(scale, [
            (0, _helpersSegmentJs.d).scales[scale.type],
            (0, _helpersSegmentJs.d).scale
        ]);
    });
    return scales;
}
function initOptions(config) {
    var options = config.options || (config.options = {});
    options.plugins = (0, _helpersSegmentJs.v)(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
}
function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
}
var keyCache = new Map();
var keysCached = new Set();
function cachedKeys(cacheKey, generate) {
    var keys = keyCache.get(cacheKey);
    if (!keys) {
        keys = generate();
        keyCache.set(cacheKey, keys);
        keysCached.add(keys);
    }
    return keys;
}
var addIfFound = function(set, obj, key) {
    var opts = (0, _helpersSegmentJs.f)(obj, key);
    if (opts !== undefined) set.add(opts);
};
var Config = /*#__PURE__*/ function() {
    "use strict";
    function Config(config) {
        (0, _classCallCheck._)(this, Config);
        this._config = initConfig(config);
        this._scopeCache = new Map();
        this._resolverCache = new Map();
    }
    (0, _createClass._)(Config, [
        {
            key: "platform",
            get: function get() {
                return this._config.platform;
            }
        },
        {
            key: "type",
            get: function get() {
                return this._config.type;
            },
            set: function set(type) {
                this._config.type = type;
            }
        },
        {
            key: "data",
            get: function get() {
                return this._config.data;
            },
            set: function set(data) {
                this._config.data = initData(data);
            }
        },
        {
            key: "options",
            get: function get() {
                return this._config.options;
            },
            set: function set(options) {
                this._config.options = options;
            }
        },
        {
            key: "plugins",
            get: function get() {
                return this._config.plugins;
            }
        },
        {
            key: "update",
            value: function update() {
                var config = this._config;
                this.clearCache();
                initOptions(config);
            }
        },
        {
            key: "clearCache",
            value: function clearCache() {
                this._scopeCache.clear();
                this._resolverCache.clear();
            }
        },
        {
            key: "datasetScopeKeys",
            value: function datasetScopeKeys(datasetType) {
                return cachedKeys(datasetType, function() {
                    return [
                        [
                            "datasets.".concat(datasetType),
                            ""
                        ]
                    ];
                });
            }
        },
        {
            key: "datasetAnimationScopeKeys",
            value: function datasetAnimationScopeKeys(datasetType, transition) {
                return cachedKeys("".concat(datasetType, ".transition.").concat(transition), function() {
                    return [
                        [
                            "datasets.".concat(datasetType, ".transitions.").concat(transition),
                            "transitions.".concat(transition)
                        ],
                        [
                            "datasets.".concat(datasetType),
                            ""
                        ]
                    ];
                });
            }
        },
        {
            key: "datasetElementScopeKeys",
            value: function datasetElementScopeKeys(datasetType, elementType) {
                return cachedKeys("".concat(datasetType, "-").concat(elementType), function() {
                    return [
                        [
                            "datasets.".concat(datasetType, ".elements.").concat(elementType),
                            "datasets.".concat(datasetType),
                            "elements.".concat(elementType),
                            ""
                        ]
                    ];
                });
            }
        },
        {
            key: "pluginScopeKeys",
            value: function pluginScopeKeys(plugin) {
                var id = plugin.id;
                var type = this.type;
                return cachedKeys("".concat(type, "-plugin-").concat(id), function() {
                    return [
                        [
                            "plugins.".concat(id)
                        ].concat((0, _toConsumableArray._)(plugin.additionalOptionScopes || []))
                    ];
                });
            }
        },
        {
            key: "_cachedScopes",
            value: function _cachedScopes(mainScope, resetCache) {
                var _scopeCache = this._scopeCache;
                var cache = _scopeCache.get(mainScope);
                if (!cache || resetCache) {
                    cache = new Map();
                    _scopeCache.set(mainScope, cache);
                }
                return cache;
            }
        },
        {
            key: "getOptionScopes",
            value: function getOptionScopes(mainScope, keyLists, resetCache) {
                var _this = this, options = _this.options, type = _this.type;
                var cache = this._cachedScopes(mainScope, resetCache);
                var cached = cache.get(keyLists);
                if (cached) return cached;
                var scopes = new Set();
                keyLists.forEach(function(keys) {
                    if (mainScope) {
                        scopes.add(mainScope);
                        keys.forEach(function(key) {
                            return addIfFound(scopes, mainScope, key);
                        });
                    }
                    keys.forEach(function(key) {
                        return addIfFound(scopes, options, key);
                    });
                    keys.forEach(function(key) {
                        return addIfFound(scopes, (0, _helpersSegmentJs.a3)[type] || {}, key);
                    });
                    keys.forEach(function(key) {
                        return addIfFound(scopes, (0, _helpersSegmentJs.d), key);
                    });
                    keys.forEach(function(key) {
                        return addIfFound(scopes, (0, _helpersSegmentJs.a6), key);
                    });
                });
                var array = Array.from(scopes);
                if (array.length === 0) array.push(Object.create(null));
                if (keysCached.has(keyLists)) cache.set(keyLists, array);
                return array;
            }
        },
        {
            key: "chartOptionScopes",
            value: function chartOptionScopes() {
                var _this = this, options = _this.options, type = _this.type;
                return [
                    options,
                    (0, _helpersSegmentJs.a3)[type] || {},
                    (0, _helpersSegmentJs.d).datasets[type] || {},
                    {
                        type: type
                    },
                    (0, _helpersSegmentJs.d),
                    (0, _helpersSegmentJs.a6)
                ];
            }
        },
        {
            key: "resolveNamedOptions",
            value: function resolveNamedOptions(scopes, names, context) {
                var prefixes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [
                    ""
                ];
                var result = {
                    $shared: true
                };
                var _getResolver = getResolver(this._resolverCache, scopes, prefixes), resolver = _getResolver.resolver, subPrefixes = _getResolver.subPrefixes;
                var options = resolver;
                if (needContext(resolver, names)) {
                    result.$shared = false;
                    context = (0, _helpersSegmentJs.a7)(context) ? context() : context;
                    var subResolver = this.createResolver(scopes, context, subPrefixes);
                    options = (0, _helpersSegmentJs.a8)(resolver, context, subResolver);
                }
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = names[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var prop = _step.value;
                        result[prop] = options[prop];
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return result;
            }
        },
        {
            key: "createResolver",
            value: function createResolver(scopes, context) {
                var prefixes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [
                    ""
                ], descriptorDefaults = arguments.length > 3 ? arguments[3] : void 0;
                var resolver = getResolver(this._resolverCache, scopes, prefixes).resolver;
                return (0, _helpersSegmentJs.i)(context) ? (0, _helpersSegmentJs.a8)(resolver, context, undefined, descriptorDefaults) : resolver;
            }
        }
    ]);
    return Config;
}();
function getResolver(resolverCache, scopes, prefixes) {
    var cache = resolverCache.get(scopes);
    if (!cache) {
        cache = new Map();
        resolverCache.set(scopes, cache);
    }
    var cacheKey = prefixes.join();
    var cached = cache.get(cacheKey);
    if (!cached) {
        var resolver = (0, _helpersSegmentJs.a9)(scopes, prefixes);
        cached = {
            resolver: resolver,
            subPrefixes: prefixes.filter(function(p) {
                return !p.toLowerCase().includes("hover");
            })
        };
        cache.set(cacheKey, cached);
    }
    return cached;
}
var hasFunction = function(value) {
    return (0, _helpersSegmentJs.i)(value) && Object.getOwnPropertyNames(value).some(function(key) {
        return (0, _helpersSegmentJs.a7)(value[key]);
    });
};
function needContext(proxy, names) {
    var _$_descriptors = (0, _helpersSegmentJs.aa)(proxy), isScriptable = _$_descriptors.isScriptable, isIndexable = _$_descriptors.isIndexable;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = names[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var prop = _step.value;
            var scriptable = isScriptable(prop);
            var indexable = isIndexable(prop);
            var value = (indexable || scriptable) && proxy[prop];
            if (scriptable && ((0, _helpersSegmentJs.a7)(value) || hasFunction(value)) || indexable && (0, _helpersSegmentJs.b)(value)) return true;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return false;
}
var version = "4.4.1";
var KNOWN_POSITIONS = [
    "top",
    "bottom",
    "left",
    "right",
    "chartArea"
];
function positionIsHorizontal(position, axis) {
    return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
    return function(a, b) {
        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
    };
}
function onAnimationsComplete(context) {
    var chart = context.chart;
    var animationOptions = chart.options.animation;
    chart.notifyPlugins("afterRender");
    (0, _helpersSegmentJs.Q)(animationOptions && animationOptions.onComplete, [
        context
    ], chart);
}
function onAnimationProgress(context) {
    var chart = context.chart;
    var animationOptions = chart.options.animation;
    (0, _helpersSegmentJs.Q)(animationOptions && animationOptions.onProgress, [
        context
    ], chart);
}
function getCanvas(item) {
    if ((0, _helpersSegmentJs.M)() && typeof item === "string") item = document.getElementById(item);
    else if (item && item.length) item = item[0];
    if (item && item.canvas) item = item.canvas;
    return item;
}
var instances = {};
var getChart = function(key) {
    var canvas = getCanvas(key);
    return Object.values(instances).filter(function(c) {
        return c.canvas === canvas;
    }).pop();
};
function moveNumericKeys(obj, start, move) {
    var keys = Object.keys(obj);
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var key = _step.value;
            var intKey = +key;
            if (intKey >= start) {
                var value = obj[key];
                delete obj[key];
                if (move > 0 || intKey > start) obj[intKey + move] = value;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e.type === "mouseout") return null;
    if (isClick) return lastEvent;
    return e;
}
function getSizeForArea(scale, chartArea, field) {
    return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
    var xScale = meta.xScale, yScale = meta.yScale;
    if (xScale && yScale) return {
        left: getSizeForArea(xScale, chartArea, "left"),
        right: getSizeForArea(xScale, chartArea, "right"),
        top: getSizeForArea(yScale, chartArea, "top"),
        bottom: getSizeForArea(yScale, chartArea, "bottom")
    };
    return chartArea;
}
var Chart = /*#__PURE__*/ function() {
    "use strict";
    function Chart(item, userConfig) {
        var _this = this;
        (0, _classCallCheck._)(this, Chart);
        var config = this.config = new Config(userConfig);
        var initialCanvas = getCanvas(item);
        var existingChart = getChart(initialCanvas);
        if (existingChart) throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "'" + " must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
        var options = config.createResolver(config.chartOptionScopes(), this.getContext());
        this.platform = new (config.platform || _detectPlatform(initialCanvas))();
        this.platform.updateConfig(config);
        var context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
        var canvas = context && context.canvas;
        var height = canvas && canvas.height;
        var width = canvas && canvas.width;
        this.id = (0, _helpersSegmentJs.ac)();
        this.ctx = context;
        this.canvas = canvas;
        this.width = width;
        this.height = height;
        this._options = options;
        this._aspectRatio = this.aspectRatio;
        this._layers = [];
        this._metasets = [];
        this._stacks = undefined;
        this.boxes = [];
        this.currentDevicePixelRatio = undefined;
        this.chartArea = undefined;
        this._active = [];
        this._lastEvent = undefined;
        this._listeners = {};
        this._responsiveListeners = undefined;
        this._sortedMetasets = [];
        this.scales = {};
        this._plugins = new PluginService();
        this.$proxies = {};
        this._hiddenIndices = {};
        this.attached = false;
        this._animationsDisabled = undefined;
        this.$context = undefined;
        this._doResize = (0, _helpersSegmentJs.ad)(function(mode) {
            return _this.update(mode);
        }, options.resizeDelay || 0);
        this._dataChanges = [];
        instances[this.id] = this;
        if (!context || !canvas) {
            console.error("Failed to create chart: can't acquire context from the given item");
            return;
        }
        animator.listen(this, "complete", onAnimationsComplete);
        animator.listen(this, "progress", onAnimationProgress);
        this._initialize();
        if (this.attached) this.update();
    }
    (0, _createClass._)(Chart, [
        {
            key: "aspectRatio",
            get: function get() {
                var _this = this, _this_options = _this.options, aspectRatio = _this_options.aspectRatio, maintainAspectRatio = _this_options.maintainAspectRatio, width = _this.width, height = _this.height, _aspectRatio = _this._aspectRatio;
                if (!(0, _helpersSegmentJs.k)(aspectRatio)) return aspectRatio;
                if (maintainAspectRatio && _aspectRatio) return _aspectRatio;
                return height ? width / height : null;
            }
        },
        {
            key: "data",
            get: function get() {
                return this.config.data;
            },
            set: function set(data) {
                this.config.data = data;
            }
        },
        {
            key: "options",
            get: function get() {
                return this._options;
            },
            set: function set(options) {
                this.config.options = options;
            }
        },
        {
            key: "registry",
            get: function get() {
                return registry;
            }
        },
        {
            key: "_initialize",
            value: function _initialize() {
                this.notifyPlugins("beforeInit");
                if (this.options.responsive) this.resize();
                else (0, _helpersSegmentJs.ae)(this, this.options.devicePixelRatio);
                this.bindEvents();
                this.notifyPlugins("afterInit");
                return this;
            }
        },
        {
            key: "clear",
            value: function clear() {
                (0, _helpersSegmentJs.af)(this.canvas, this.ctx);
                return this;
            }
        },
        {
            key: "stop",
            value: function stop() {
                animator.stop(this);
                return this;
            }
        },
        {
            key: "resize",
            value: function resize(width, height) {
                if (!animator.running(this)) this._resize(width, height);
                else this._resizeBeforeDraw = {
                    width: width,
                    height: height
                };
            }
        },
        {
            key: "_resize",
            value: function _resize(width, height) {
                var options = this.options;
                var canvas = this.canvas;
                var aspectRatio = options.maintainAspectRatio && this.aspectRatio;
                var newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
                var newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
                var mode = this.width ? "resize" : "attach";
                this.width = newSize.width;
                this.height = newSize.height;
                this._aspectRatio = this.aspectRatio;
                if (!(0, _helpersSegmentJs.ae)(this, newRatio, true)) return;
                this.notifyPlugins("resize", {
                    size: newSize
                });
                (0, _helpersSegmentJs.Q)(options.onResize, [
                    this,
                    newSize
                ], this);
                if (this.attached) {
                    if (this._doResize(mode)) this.render();
                }
            }
        },
        {
            key: "ensureScalesHaveIDs",
            value: function ensureScalesHaveIDs() {
                var options = this.options;
                var scalesOptions = options.scales || {};
                (0, _helpersSegmentJs.F)(scalesOptions, function(axisOptions, axisID) {
                    axisOptions.id = axisID;
                });
            }
        },
        {
            key: "buildOrUpdateScales",
            value: function buildOrUpdateScales() {
                var _this = this;
                var options = this.options;
                var scaleOpts = options.scales;
                var scales = this.scales;
                var updated = Object.keys(scales).reduce(function(obj, id) {
                    obj[id] = false;
                    return obj;
                }, {});
                var items = [];
                if (scaleOpts) items = items.concat(Object.keys(scaleOpts).map(function(id) {
                    var scaleOptions = scaleOpts[id];
                    var axis = determineAxis(id, scaleOptions);
                    var isRadial = axis === "r";
                    var isHorizontal = axis === "x";
                    return {
                        options: scaleOptions,
                        dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
                        dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
                    };
                }));
                (0, _helpersSegmentJs.F)(items, function(item) {
                    var scaleOptions = item.options;
                    var id = scaleOptions.id;
                    var axis = determineAxis(id, scaleOptions);
                    var scaleType = (0, _helpersSegmentJs.v)(scaleOptions.type, item.dtype);
                    if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) scaleOptions.position = item.dposition;
                    updated[id] = true;
                    var scale = null;
                    if (id in scales && scales[id].type === scaleType) scale = scales[id];
                    else {
                        var scaleClass = registry.getScale(scaleType);
                        scale = new scaleClass({
                            id: id,
                            type: scaleType,
                            ctx: _this.ctx,
                            chart: _this
                        });
                        scales[scale.id] = scale;
                    }
                    scale.init(scaleOptions, options);
                });
                (0, _helpersSegmentJs.F)(updated, function(hasUpdated, id) {
                    if (!hasUpdated) delete scales[id];
                });
                (0, _helpersSegmentJs.F)(scales, function(scale) {
                    layouts.configure(_this, scale, scale.options);
                    layouts.addBox(_this, scale);
                });
            }
        },
        {
            key: "_updateMetasets",
            value: function _updateMetasets() {
                var metasets = this._metasets;
                var numData = this.data.datasets.length;
                var numMeta = metasets.length;
                metasets.sort(function(a, b) {
                    return a.index - b.index;
                });
                if (numMeta > numData) {
                    for(var i = numData; i < numMeta; ++i)this._destroyDatasetMeta(i);
                    metasets.splice(numData, numMeta - numData);
                }
                this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
            }
        },
        {
            key: "_removeUnreferencedMetasets",
            value: function _removeUnreferencedMetasets() {
                var _this = this;
                var _this1 = this, metasets = _this1._metasets, datasets = _this1.data.datasets;
                if (metasets.length > datasets.length) delete this._stacks;
                metasets.forEach(function(meta, index) {
                    if (datasets.filter(function(x) {
                        return x === meta._dataset;
                    }).length === 0) _this._destroyDatasetMeta(index);
                });
            }
        },
        {
            key: "buildOrUpdateControllers",
            value: function buildOrUpdateControllers() {
                var newControllers = [];
                var datasets = this.data.datasets;
                var i, ilen;
                this._removeUnreferencedMetasets();
                for(i = 0, ilen = datasets.length; i < ilen; i++){
                    var dataset = datasets[i];
                    var meta = this.getDatasetMeta(i);
                    var type = dataset.type || this.config.type;
                    if (meta.type && meta.type !== type) {
                        this._destroyDatasetMeta(i);
                        meta = this.getDatasetMeta(i);
                    }
                    meta.type = type;
                    meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
                    meta.order = dataset.order || 0;
                    meta.index = i;
                    meta.label = "" + dataset.label;
                    meta.visible = this.isDatasetVisible(i);
                    if (meta.controller) {
                        meta.controller.updateIndex(i);
                        meta.controller.linkScales();
                    } else {
                        var ControllerClass = registry.getController(type);
                        var _defaults_datasets_type = (0, _helpersSegmentJs.d).datasets[type], datasetElementType = _defaults_datasets_type.datasetElementType, dataElementType = _defaults_datasets_type.dataElementType;
                        Object.assign(ControllerClass, {
                            dataElementType: registry.getElement(dataElementType),
                            datasetElementType: datasetElementType && registry.getElement(datasetElementType)
                        });
                        meta.controller = new ControllerClass(this, i);
                        newControllers.push(meta.controller);
                    }
                }
                this._updateMetasets();
                return newControllers;
            }
        },
        {
            key: "_resetElements",
            value: function _resetElements() {
                var _this = this;
                (0, _helpersSegmentJs.F)(this.data.datasets, function(dataset, datasetIndex) {
                    _this.getDatasetMeta(datasetIndex).controller.reset();
                }, this);
            }
        },
        {
            key: "reset",
            value: function reset() {
                this._resetElements();
                this.notifyPlugins("reset");
            }
        },
        {
            key: "update",
            value: function update(mode) {
                var config = this.config;
                config.update();
                var options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
                var animsDisabled = this._animationsDisabled = !options.animation;
                this._updateScales();
                this._checkEventBindings();
                this._updateHiddenIndices();
                this._plugins.invalidate();
                if (this.notifyPlugins("beforeUpdate", {
                    mode: mode,
                    cancelable: true
                }) === false) return;
                var newControllers = this.buildOrUpdateControllers();
                this.notifyPlugins("beforeElementsUpdate");
                var minPadding = 0;
                for(var i = 0, ilen = this.data.datasets.length; i < ilen; i++){
                    var controller = this.getDatasetMeta(i).controller;
                    var reset = !animsDisabled && newControllers.indexOf(controller) === -1;
                    controller.buildOrUpdateElements(reset);
                    minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
                }
                minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
                this._updateLayout(minPadding);
                if (!animsDisabled) (0, _helpersSegmentJs.F)(newControllers, function(controller) {
                    controller.reset();
                });
                this._updateDatasets(mode);
                this.notifyPlugins("afterUpdate", {
                    mode: mode
                });
                this._layers.sort(compare2Level("z", "_idx"));
                var _this = this, _active = _this._active, _lastEvent = _this._lastEvent;
                if (_lastEvent) this._eventHandler(_lastEvent, true);
                else if (_active.length) this._updateHoverStyles(_active, _active, true);
                this.render();
            }
        },
        {
            key: "_updateScales",
            value: function _updateScales() {
                var _this = this;
                (0, _helpersSegmentJs.F)(this.scales, function(scale) {
                    layouts.removeBox(_this, scale);
                });
                this.ensureScalesHaveIDs();
                this.buildOrUpdateScales();
            }
        },
        {
            key: "_checkEventBindings",
            value: function _checkEventBindings() {
                var options = this.options;
                var existingEvents = new Set(Object.keys(this._listeners));
                var newEvents = new Set(options.events);
                if (!(0, _helpersSegmentJs.ag)(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
                    this.unbindEvents();
                    this.bindEvents();
                }
            }
        },
        {
            key: "_updateHiddenIndices",
            value: function _updateHiddenIndices() {
                var _hiddenIndices = this._hiddenIndices;
                var changes = this._getUniformDataChanges() || [];
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = changes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _step_value = _step.value, method = _step_value.method, start = _step_value.start, count = _step_value.count;
                        var move = method === "_removeElements" ? -count : count;
                        moveNumericKeys(_hiddenIndices, start, move);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "_getUniformDataChanges",
            value: function _getUniformDataChanges() {
                var _dataChanges = this._dataChanges;
                if (!_dataChanges || !_dataChanges.length) return;
                this._dataChanges = [];
                var datasetCount = this.data.datasets.length;
                var makeSet = function(idx) {
                    return new Set(_dataChanges.filter(function(c) {
                        return c[0] === idx;
                    }).map(function(c, i) {
                        return i + "," + c.splice(1).join(",");
                    }));
                };
                var changeSet = makeSet(0);
                for(var i = 1; i < datasetCount; i++){
                    if (!(0, _helpersSegmentJs.ag)(changeSet, makeSet(i))) return;
                }
                return Array.from(changeSet).map(function(c) {
                    return c.split(",");
                }).map(function(a) {
                    return {
                        method: a[1],
                        start: +a[2],
                        count: +a[3]
                    };
                });
            }
        },
        {
            key: "_updateLayout",
            value: function _updateLayout(minPadding) {
                var _this = this;
                if (this.notifyPlugins("beforeLayout", {
                    cancelable: true
                }) === false) return;
                layouts.update(this, this.width, this.height, minPadding);
                var area = this.chartArea;
                var noArea = area.width <= 0 || area.height <= 0;
                this._layers = [];
                (0, _helpersSegmentJs.F)(this.boxes, function(box) {
                    var _this__layers;
                    if (noArea && box.position === "chartArea") return;
                    if (box.configure) box.configure();
                    (_this__layers = _this._layers).push.apply(_this__layers, (0, _toConsumableArray._)(box._layers()));
                }, this);
                this._layers.forEach(function(item, index) {
                    item._idx = index;
                });
                this.notifyPlugins("afterLayout");
            }
        },
        {
            key: "_updateDatasets",
            value: function _updateDatasets(mode) {
                if (this.notifyPlugins("beforeDatasetsUpdate", {
                    mode: mode,
                    cancelable: true
                }) === false) return;
                for(var i = 0, ilen = this.data.datasets.length; i < ilen; ++i)this.getDatasetMeta(i).controller.configure();
                for(var i1 = 0, ilen1 = this.data.datasets.length; i1 < ilen1; ++i1)this._updateDataset(i1, (0, _helpersSegmentJs.a7)(mode) ? mode({
                    datasetIndex: i1
                }) : mode);
                this.notifyPlugins("afterDatasetsUpdate", {
                    mode: mode
                });
            }
        },
        {
            key: "_updateDataset",
            value: function _updateDataset(index, mode) {
                var meta = this.getDatasetMeta(index);
                var args = {
                    meta: meta,
                    index: index,
                    mode: mode,
                    cancelable: true
                };
                if (this.notifyPlugins("beforeDatasetUpdate", args) === false) return;
                meta.controller._update(mode);
                args.cancelable = false;
                this.notifyPlugins("afterDatasetUpdate", args);
            }
        },
        {
            key: "render",
            value: function render() {
                if (this.notifyPlugins("beforeRender", {
                    cancelable: true
                }) === false) return;
                if (animator.has(this)) {
                    if (this.attached && !animator.running(this)) animator.start(this);
                } else {
                    this.draw();
                    onAnimationsComplete({
                        chart: this
                    });
                }
            }
        },
        {
            key: "draw",
            value: function draw() {
                var i;
                if (this._resizeBeforeDraw) {
                    var _this__resizeBeforeDraw = this._resizeBeforeDraw, width = _this__resizeBeforeDraw.width, height = _this__resizeBeforeDraw.height;
                    this._resize(width, height);
                    this._resizeBeforeDraw = null;
                }
                this.clear();
                if (this.width <= 0 || this.height <= 0) return;
                if (this.notifyPlugins("beforeDraw", {
                    cancelable: true
                }) === false) return;
                var layers = this._layers;
                for(i = 0; i < layers.length && layers[i].z <= 0; ++i)layers[i].draw(this.chartArea);
                this._drawDatasets();
                for(; i < layers.length; ++i)layers[i].draw(this.chartArea);
                this.notifyPlugins("afterDraw");
            }
        },
        {
            key: "_getSortedDatasetMetas",
            value: function _getSortedDatasetMetas(filterVisible) {
                var metasets = this._sortedMetasets;
                var result = [];
                var i, ilen;
                for(i = 0, ilen = metasets.length; i < ilen; ++i){
                    var meta = metasets[i];
                    if (!filterVisible || meta.visible) result.push(meta);
                }
                return result;
            }
        },
        {
            key: "getSortedVisibleDatasetMetas",
            value: function getSortedVisibleDatasetMetas() {
                return this._getSortedDatasetMetas(true);
            }
        },
        {
            key: "_drawDatasets",
            value: function _drawDatasets() {
                if (this.notifyPlugins("beforeDatasetsDraw", {
                    cancelable: true
                }) === false) return;
                var metasets = this.getSortedVisibleDatasetMetas();
                for(var i = metasets.length - 1; i >= 0; --i)this._drawDataset(metasets[i]);
                this.notifyPlugins("afterDatasetsDraw");
            }
        },
        {
            key: "_drawDataset",
            value: function _drawDataset(meta) {
                var ctx = this.ctx;
                var clip = meta._clip;
                var useClip = !clip.disabled;
                var area = getDatasetArea(meta, this.chartArea);
                var args = {
                    meta: meta,
                    index: meta.index,
                    cancelable: true
                };
                if (this.notifyPlugins("beforeDatasetDraw", args) === false) return;
                if (useClip) (0, _helpersSegmentJs.Y)(ctx, {
                    left: clip.left === false ? 0 : area.left - clip.left,
                    right: clip.right === false ? this.width : area.right + clip.right,
                    top: clip.top === false ? 0 : area.top - clip.top,
                    bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
                });
                meta.controller.draw();
                if (useClip) (0, _helpersSegmentJs.$)(ctx);
                args.cancelable = false;
                this.notifyPlugins("afterDatasetDraw", args);
            }
        },
        {
            key: "isPointInArea",
            value: function isPointInArea(point) {
                return (0, _helpersSegmentJs.C)(point, this.chartArea, this._minPadding);
            }
        },
        {
            key: "getElementsAtEventForMode",
            value: function getElementsAtEventForMode(e, mode, options, useFinalPosition) {
                var method = Interaction.modes[mode];
                if (typeof method === "function") return method(this, e, options, useFinalPosition);
                return [];
            }
        },
        {
            key: "getDatasetMeta",
            value: function getDatasetMeta(datasetIndex) {
                var dataset = this.data.datasets[datasetIndex];
                var metasets = this._metasets;
                var meta = metasets.filter(function(x) {
                    return x && x._dataset === dataset;
                }).pop();
                if (!meta) {
                    meta = {
                        type: null,
                        data: [],
                        dataset: null,
                        controller: null,
                        hidden: null,
                        xAxisID: null,
                        yAxisID: null,
                        order: dataset && dataset.order || 0,
                        index: datasetIndex,
                        _dataset: dataset,
                        _parsed: [],
                        _sorted: false
                    };
                    metasets.push(meta);
                }
                return meta;
            }
        },
        {
            key: "getContext",
            value: function getContext() {
                return this.$context || (this.$context = (0, _helpersSegmentJs.j)(null, {
                    chart: this,
                    type: "chart"
                }));
            }
        },
        {
            key: "getVisibleDatasetCount",
            value: function getVisibleDatasetCount() {
                return this.getSortedVisibleDatasetMetas().length;
            }
        },
        {
            key: "isDatasetVisible",
            value: function isDatasetVisible(datasetIndex) {
                var dataset = this.data.datasets[datasetIndex];
                if (!dataset) return false;
                var meta = this.getDatasetMeta(datasetIndex);
                return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
            }
        },
        {
            key: "setDatasetVisibility",
            value: function setDatasetVisibility(datasetIndex, visible) {
                var meta = this.getDatasetMeta(datasetIndex);
                meta.hidden = !visible;
            }
        },
        {
            key: "toggleDataVisibility",
            value: function toggleDataVisibility(index) {
                this._hiddenIndices[index] = !this._hiddenIndices[index];
            }
        },
        {
            key: "getDataVisibility",
            value: function getDataVisibility(index) {
                return !this._hiddenIndices[index];
            }
        },
        {
            key: "_updateVisibility",
            value: function _updateVisibility(datasetIndex, dataIndex, visible) {
                var mode = visible ? "show" : "hide";
                var meta = this.getDatasetMeta(datasetIndex);
                var anims = meta.controller._resolveAnimations(undefined, mode);
                if ((0, _helpersSegmentJs.h)(dataIndex)) {
                    meta.data[dataIndex].hidden = !visible;
                    this.update();
                } else {
                    this.setDatasetVisibility(datasetIndex, visible);
                    anims.update(meta, {
                        visible: visible
                    });
                    this.update(function(ctx) {
                        return ctx.datasetIndex === datasetIndex ? mode : undefined;
                    });
                }
            }
        },
        {
            key: "hide",
            value: function hide(datasetIndex, dataIndex) {
                this._updateVisibility(datasetIndex, dataIndex, false);
            }
        },
        {
            key: "show",
            value: function show(datasetIndex, dataIndex) {
                this._updateVisibility(datasetIndex, dataIndex, true);
            }
        },
        {
            key: "_destroyDatasetMeta",
            value: function _destroyDatasetMeta(datasetIndex) {
                var meta = this._metasets[datasetIndex];
                if (meta && meta.controller) meta.controller._destroy();
                delete this._metasets[datasetIndex];
            }
        },
        {
            key: "_stop",
            value: function _stop() {
                var i, ilen;
                this.stop();
                animator.remove(this);
                for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i)this._destroyDatasetMeta(i);
            }
        },
        {
            key: "destroy",
            value: function destroy() {
                this.notifyPlugins("beforeDestroy");
                var _this = this, canvas = _this.canvas, ctx = _this.ctx;
                this._stop();
                this.config.clearCache();
                if (canvas) {
                    this.unbindEvents();
                    (0, _helpersSegmentJs.af)(canvas, ctx);
                    this.platform.releaseContext(ctx);
                    this.canvas = null;
                    this.ctx = null;
                }
                delete instances[this.id];
                this.notifyPlugins("afterDestroy");
            }
        },
        {
            key: "toBase64Image",
            value: function toBase64Image() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _this_canvas;
                return (_this_canvas = this.canvas).toDataURL.apply(_this_canvas, (0, _toConsumableArray._)(args));
            }
        },
        {
            key: "bindEvents",
            value: function bindEvents() {
                this.bindUserEvents();
                if (this.options.responsive) this.bindResponsiveEvents();
                else this.attached = true;
            }
        },
        {
            key: "bindUserEvents",
            value: function bindUserEvents() {
                var _this = this;
                var listeners = this._listeners;
                var platform = this.platform;
                var _add = function(type, listener) {
                    platform.addEventListener(_this, type, listener);
                    listeners[type] = listener;
                };
                var listener = function(e, x, y) {
                    e.offsetX = x;
                    e.offsetY = y;
                    _this._eventHandler(e);
                };
                (0, _helpersSegmentJs.F)(this.options.events, function(type) {
                    return _add(type, listener);
                });
            }
        },
        {
            key: "bindResponsiveEvents",
            value: function bindResponsiveEvents() {
                var _this = this;
                if (!this._responsiveListeners) this._responsiveListeners = {};
                var listeners = this._responsiveListeners;
                var platform = this.platform;
                var _add = function(type, listener) {
                    platform.addEventListener(_this, type, listener);
                    listeners[type] = listener;
                };
                var _remove = function(type, listener) {
                    if (listeners[type]) {
                        platform.removeEventListener(_this, type, listener);
                        delete listeners[type];
                    }
                };
                var listener = function(width, height) {
                    if (_this.canvas) _this.resize(width, height);
                };
                var detached;
                var attached = function() {
                    _remove("attach", attached);
                    _this.attached = true;
                    _this.resize();
                    _add("resize", listener);
                    _add("detach", detached);
                };
                detached = function() {
                    _this.attached = false;
                    _remove("resize", listener);
                    _this._stop();
                    _this._resize(0, 0);
                    _add("attach", attached);
                };
                if (platform.isAttached(this.canvas)) attached();
                else detached();
            }
        },
        {
            key: "unbindEvents",
            value: function unbindEvents() {
                var _this = this;
                (0, _helpersSegmentJs.F)(this._listeners, function(listener, type) {
                    _this.platform.removeEventListener(_this, type, listener);
                });
                this._listeners = {};
                (0, _helpersSegmentJs.F)(this._responsiveListeners, function(listener, type) {
                    _this.platform.removeEventListener(_this, type, listener);
                });
                this._responsiveListeners = undefined;
            }
        },
        {
            key: "updateHoverStyle",
            value: function updateHoverStyle(items, mode, enabled) {
                var prefix = enabled ? "set" : "remove";
                var meta, item, i, ilen;
                if (mode === "dataset") {
                    meta = this.getDatasetMeta(items[0].datasetIndex);
                    meta.controller["_" + prefix + "DatasetHoverStyle"]();
                }
                for(i = 0, ilen = items.length; i < ilen; ++i){
                    item = items[i];
                    var controller = item && this.getDatasetMeta(item.datasetIndex).controller;
                    if (controller) controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
                }
            }
        },
        {
            key: "getActiveElements",
            value: function getActiveElements() {
                return this._active || [];
            }
        },
        {
            key: "setActiveElements",
            value: function setActiveElements(activeElements) {
                var _this = this;
                var lastActive = this._active || [];
                var active = activeElements.map(function(param) {
                    var datasetIndex = param.datasetIndex, index = param.index;
                    var meta = _this.getDatasetMeta(datasetIndex);
                    if (!meta) throw new Error("No dataset found at index " + datasetIndex);
                    return {
                        datasetIndex: datasetIndex,
                        element: meta.data[index],
                        index: index
                    };
                });
                var changed = !(0, _helpersSegmentJs.ah)(active, lastActive);
                if (changed) {
                    this._active = active;
                    this._lastEvent = null;
                    this._updateHoverStyles(active, lastActive);
                }
            }
        },
        {
            key: "notifyPlugins",
            value: function notifyPlugins(hook, args, filter) {
                return this._plugins.notify(this, hook, args, filter);
            }
        },
        {
            key: "isPluginEnabled",
            value: function isPluginEnabled(pluginId) {
                return this._plugins._cache.filter(function(p) {
                    return p.plugin.id === pluginId;
                }).length === 1;
            }
        },
        {
            key: "_updateHoverStyles",
            value: function _updateHoverStyles(active, lastActive, replay) {
                var hoverOptions = this.options.hover;
                var diff = function(a, b) {
                    return a.filter(function(x) {
                        return !b.some(function(y) {
                            return x.datasetIndex === y.datasetIndex && x.index === y.index;
                        });
                    });
                };
                var deactivated = diff(lastActive, active);
                var activated = replay ? active : diff(active, lastActive);
                if (deactivated.length) this.updateHoverStyle(deactivated, hoverOptions.mode, false);
                if (activated.length && hoverOptions.mode) this.updateHoverStyle(activated, hoverOptions.mode, true);
            }
        },
        {
            key: "_eventHandler",
            value: function _eventHandler(e, replay) {
                var _this = this;
                var args = {
                    event: e,
                    replay: replay,
                    cancelable: true,
                    inChartArea: this.isPointInArea(e)
                };
                var eventFilter = function(plugin) {
                    return (plugin.options.events || _this.options.events).includes(e.native.type);
                };
                if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) return;
                var changed = this._handleEvent(e, replay, args.inChartArea);
                args.cancelable = false;
                this.notifyPlugins("afterEvent", args, eventFilter);
                if (changed || args.changed) this.render();
                return this;
            }
        },
        {
            key: "_handleEvent",
            value: function _handleEvent(e, replay, inChartArea) {
                var _this = this, tmp = _this._active, lastActive = tmp === void 0 ? [] : tmp, options = _this.options;
                var useFinalPosition = replay;
                var active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
                var isClick = (0, _helpersSegmentJs.ai)(e);
                var lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
                if (inChartArea) {
                    this._lastEvent = null;
                    (0, _helpersSegmentJs.Q)(options.onHover, [
                        e,
                        active,
                        this
                    ], this);
                    if (isClick) (0, _helpersSegmentJs.Q)(options.onClick, [
                        e,
                        active,
                        this
                    ], this);
                }
                var changed = !(0, _helpersSegmentJs.ah)(active, lastActive);
                if (changed || replay) {
                    this._active = active;
                    this._updateHoverStyles(active, lastActive, replay);
                }
                this._lastEvent = lastEvent;
                return changed;
            }
        },
        {
            key: "_getActiveElements",
            value: function _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
                if (e.type === "mouseout") return [];
                if (!inChartArea) return lastActive;
                var hoverOptions = this.options.hover;
                return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
            }
        }
    ], [
        {
            key: "register",
            value: function register() {
                for(var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++){
                    items[_key] = arguments[_key];
                }
                var _registry;
                (_registry = registry).add.apply(_registry, (0, _toConsumableArray._)(items));
                invalidatePlugins();
            }
        },
        {
            key: "unregister",
            value: function unregister() {
                for(var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++){
                    items[_key] = arguments[_key];
                }
                var _registry;
                (_registry = registry).remove.apply(_registry, (0, _toConsumableArray._)(items));
                invalidatePlugins();
            }
        }
    ]);
    return Chart;
}();
(0, _defineProperty._)(Chart, "defaults", (0, _helpersSegmentJs.d));
(0, _defineProperty._)(Chart, "instances", instances);
(0, _defineProperty._)(Chart, "overrides", (0, _helpersSegmentJs.a3));
(0, _defineProperty._)(Chart, "registry", registry);
(0, _defineProperty._)(Chart, "version", version);
(0, _defineProperty._)(Chart, "getChart", getChart);
function invalidatePlugins() {
    return (0, _helpersSegmentJs.F)(Chart.instances, function(chart) {
        return chart._plugins.invalidate();
    });
}
function clipArc(ctx, element, endAngle) {
    var startAngle = element.startAngle, pixelMargin = element.pixelMargin, x = element.x, y = element.y, outerRadius = element.outerRadius, innerRadius = element.innerRadius;
    var angleMargin = pixelMargin / outerRadius;
    // Draw an inner border by clipping the arc and drawing a double-width border
    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
    ctx.beginPath();
    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
        angleMargin = pixelMargin / innerRadius;
        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else ctx.arc(x, y, pixelMargin, endAngle + (0, _helpersSegmentJs.H), startAngle - (0, _helpersSegmentJs.H));
    ctx.closePath();
    ctx.clip();
}
function toRadiusCorners(value) {
    return (0, _helpersSegmentJs.ak)(value, [
        "outerStart",
        "outerEnd",
        "innerStart",
        "innerEnd"
    ]);
}
/**
 * Parse border radius from the provided options
 */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    var o = toRadiusCorners(arc.options.borderRadius);
    var halfThickness = (outerRadius - innerRadius) / 2;
    var innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    // Outer limits are complicated. We want to compute the available angular distance at
    // a radius of outerRadius - borderRadius because for small angular distances, this term limits.
    // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.
    //
    // If the borderRadius is large, that value can become negative.
    // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius
    // we know that the thickness term will dominate and compute the limits at that point
    var computeOuterLimit = function(val) {
        var outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
        return (0, _helpersSegmentJs.S)(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
        outerStart: computeOuterLimit(o.outerStart),
        outerEnd: computeOuterLimit(o.outerEnd),
        innerStart: (0, _helpersSegmentJs.S)(o.innerStart, 0, innerLimit),
        innerEnd: (0, _helpersSegmentJs.S)(o.innerEnd, 0, innerLimit)
    };
}
/**
 * Convert (r, ) to (x, y)
 */ function rThetaToXY(r, theta, x, y) {
    return {
        x: x + r * Math.cos(theta),
        y: y + r * Math.sin(theta)
    };
}
/**
 * Path the arc, respecting border radius by separating into left and right halves.
 *
 *   Start      End
 *
 *    1--->a--->2    Outer
 *   /           \
 *   8           3
 *   |           |
 *   |           |
 *   7           4
 *   \           /
 *    6<---b<---5    Inner
 */ function pathArc(ctx, element, offset, spacing, end, circular) {
    var x = element.x, y = element.y, start = element.startAngle, pixelMargin = element.pixelMargin, innerR = element.innerRadius;
    var outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
    var innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
    var spacingOffset = 0;
    var alpha = end - start;
    if (spacing) {
        // When spacing is present, it is the same for all items
        // So we adjust the start and end angle of the arc such that
        // the distance is the same as it would be without the spacing
        var noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
        var noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
        var avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
        var adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
        spacingOffset = (alpha - adjustedAngle) / 2;
    }
    var beta = Math.max(0.001, alpha * outerRadius - offset / (0, _helpersSegmentJs.P)) / outerRadius;
    var angleOffset = (alpha - beta) / 2;
    var startAngle = start + angleOffset + spacingOffset;
    var endAngle = end - angleOffset - spacingOffset;
    var _parseBorderRadius$1 = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle), outerStart = _parseBorderRadius$1.outerStart, outerEnd = _parseBorderRadius$1.outerEnd, innerStart = _parseBorderRadius$1.innerStart, innerEnd = _parseBorderRadius$1.innerEnd;
    var outerStartAdjustedRadius = outerRadius - outerStart;
    var outerEndAdjustedRadius = outerRadius - outerEnd;
    var outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    var outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    var innerStartAdjustedRadius = innerRadius + innerStart;
    var innerEndAdjustedRadius = innerRadius + innerEnd;
    var innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    var innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
        // The first arc segments from point 1 to point a to point 2
        var outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
        ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
        // The corner segment from point 2 to point 3
        if (outerEnd > 0) {
            var pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + (0, _helpersSegmentJs.H));
        }
        // The line from point 3 to point 4
        var p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
        ctx.lineTo(p4.x, p4.y);
        // The corner segment from point 4 to point 5
        if (innerEnd > 0) {
            var pCenter1 = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
            ctx.arc(pCenter1.x, pCenter1.y, innerEnd, endAngle + (0, _helpersSegmentJs.H), innerEndAdjustedAngle + Math.PI);
        }
        // The inner arc from point 5 to point b to point 6
        var innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
        ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
        // The corner segment from point 6 to point 7
        if (innerStart > 0) {
            var pCenter2 = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
            ctx.arc(pCenter2.x, pCenter2.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - (0, _helpersSegmentJs.H));
        }
        // The line from point 7 to point 8
        var p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
        ctx.lineTo(p8.x, p8.y);
        // The corner segment from point 8 to point 1
        if (outerStart > 0) {
            var pCenter3 = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
            ctx.arc(pCenter3.x, pCenter3.y, outerStart, startAngle - (0, _helpersSegmentJs.H), outerStartAdjustedAngle);
        }
    } else {
        ctx.moveTo(x, y);
        var outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
        var outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
        ctx.lineTo(outerStartX, outerStartY);
        var outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
        var outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
        ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
    var fullCircles = element.fullCircles, startAngle = element.startAngle, circumference = element.circumference;
    var endAngle = element.endAngle;
    if (fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        for(var i = 0; i < fullCircles; ++i)ctx.fill();
        if (!isNaN(circumference)) endAngle = startAngle + (circumference % (0, _helpersSegmentJs.T) || (0, _helpersSegmentJs.T));
    }
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
    var fullCircles = element.fullCircles, startAngle = element.startAngle, circumference = element.circumference, options = element.options;
    var borderWidth = options.borderWidth, borderJoinStyle = options.borderJoinStyle, borderDash = options.borderDash, borderDashOffset = options.borderDashOffset;
    var inner = options.borderAlign === "inner";
    if (!borderWidth) return;
    ctx.setLineDash(borderDash || []);
    ctx.lineDashOffset = borderDashOffset;
    if (inner) {
        ctx.lineWidth = borderWidth * 2;
        ctx.lineJoin = borderJoinStyle || "round";
    } else {
        ctx.lineWidth = borderWidth;
        ctx.lineJoin = borderJoinStyle || "bevel";
    }
    var endAngle = element.endAngle;
    if (fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        for(var i = 0; i < fullCircles; ++i)ctx.stroke();
        if (!isNaN(circumference)) endAngle = startAngle + (circumference % (0, _helpersSegmentJs.T) || (0, _helpersSegmentJs.T));
    }
    if (inner) clipArc(ctx, element, endAngle);
    if (!fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        ctx.stroke();
    }
}
var ArcElement = /*#__PURE__*/ function(Element) {
    "use strict";
    (0, _inherits._)(ArcElement, Element);
    var _super = (0, _createSuper._)(ArcElement);
    function ArcElement(cfg) {
        (0, _classCallCheck._)(this, ArcElement);
        var _this;
        _this = _super.call(this);
        (0, _defineProperty._)((0, _assertThisInitialized._)(_this), "circumference", void 0);
        (0, _defineProperty._)((0, _assertThisInitialized._)(_this), "endAngle", void 0);
        (0, _defineProperty._)((0, _assertThisInitialized._)(_this), "fullCircles", void 0);
        (0, _defineProperty._)((0, _assertThisInitialized._)(_this), "innerRadius", void 0);
        (0, _defineProperty._)((0, _assertThisInitialized._)(_this), "outerRadius", void 0);
        (0, _defineProperty._)((0, _assertThisInitialized._)(_this), "pixelMargin", void 0);
        (0, _defineProperty._)((0, _assertThisInitialized._)(_this), "startAngle", void 0);
        _this.options = undefined;
        _this.circumference = undefined;
        _this.startAngle = undefined;
        _this.endAngle = undefined;
        _this.innerRadius = undefined;
        _this.outerRadius = undefined;
        _this.pixelMargin = 0;
        _this.fullCircles = 0;
        if (cfg) Object.assign((0, _assertThisInitialized._)(_this), cfg);
        return _this;
    }
    (0, _createClass._)(ArcElement, [
        {
            key: "inRange",
            value: function inRange(chartX, chartY, useFinalPosition) {
                var point = this.getProps([
                    "x",
                    "y"
                ], useFinalPosition);
                var _getAngleFromPoint = (0, _helpersSegmentJs.D)(point, {
                    x: chartX,
                    y: chartY
                }), angle = _getAngleFromPoint.angle, distance = _getAngleFromPoint.distance;
                var _this_getProps = this.getProps([
                    "startAngle",
                    "endAngle",
                    "innerRadius",
                    "outerRadius",
                    "circumference"
                ], useFinalPosition), startAngle = _this_getProps.startAngle, endAngle = _this_getProps.endAngle, innerRadius = _this_getProps.innerRadius, outerRadius = _this_getProps.outerRadius, circumference = _this_getProps.circumference;
                var rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
                var _circumference = (0, _helpersSegmentJs.v)(circumference, endAngle - startAngle);
                var betweenAngles = _circumference >= (0, _helpersSegmentJs.T) || (0, _helpersSegmentJs.p)(angle, startAngle, endAngle);
                var withinRadius = (0, _helpersSegmentJs.aj)(distance, innerRadius + rAdjust, outerRadius + rAdjust);
                return betweenAngles && withinRadius;
            }
        },
        {
            key: "getCenterPoint",
            value: function getCenterPoint(useFinalPosition) {
                var _this_getProps = this.getProps([
                    "x",
                    "y",
                    "startAngle",
                    "endAngle",
                    "innerRadius",
                    "outerRadius"
                ], useFinalPosition), x = _this_getProps.x, y = _this_getProps.y, startAngle = _this_getProps.startAngle, endAngle = _this_getProps.endAngle, innerRadius = _this_getProps.innerRadius, outerRadius = _this_getProps.outerRadius;
                var _this_options = this.options, offset = _this_options.offset, spacing = _this_options.spacing;
                var halfAngle = (startAngle + endAngle) / 2;
                var halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
                return {
                    x: x + Math.cos(halfAngle) * halfRadius,
                    y: y + Math.sin(halfAngle) * halfRadius
                };
            }
        },
        {
            key: "tooltipPosition",
            value: function tooltipPosition(useFinalPosition) {
                return this.getCenterPoint(useFinalPosition);
            }
        },
        {
            key: "draw",
            value: function draw(ctx) {
                var _this = this, options = _this.options, circumference = _this.circumference;
                var offset = (options.offset || 0) / 4;
                var spacing = (options.spacing || 0) / 2;
                var circular = options.circular;
                this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
                this.fullCircles = circumference > (0, _helpersSegmentJs.T) ? Math.floor(circumference / (0, _helpersSegmentJs.T)) : 0;
                if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) return;
                ctx.save();
                var halfAngle = (this.startAngle + this.endAngle) / 2;
                ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
                var fix = 1 - Math.sin(Math.min((0, _helpersSegmentJs.P), circumference || 0));
                var radiusOffset = offset * fix;
                ctx.fillStyle = options.backgroundColor;
                ctx.strokeStyle = options.borderColor;
                drawArc(ctx, this, radiusOffset, spacing, circular);
                drawBorder(ctx, this, radiusOffset, spacing, circular);
                ctx.restore();
            }
        }
    ]);
    return ArcElement;
}((0, _wrapNativeSuper._)(Element));
(0, _defineProperty._)(ArcElement, "id", "arc");
(0, _defineProperty._)(ArcElement, "defaults", {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: undefined,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: undefined,
    circular: true
});
(0, _defineProperty._)(ArcElement, "defaultRoutes", {
    backgroundColor: "backgroundColor"
});
(0, _defineProperty._)(ArcElement, "descriptors", {
    _scriptable: true,
    _indexable: function(name) {
        return name !== "borderDash";
    }
});
function setStyle(ctx, options) {
    var style = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : options;
    ctx.lineCap = (0, _helpersSegmentJs.v)(style.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash((0, _helpersSegmentJs.v)(style.borderDash, options.borderDash));
    ctx.lineDashOffset = (0, _helpersSegmentJs.v)(style.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = (0, _helpersSegmentJs.v)(style.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = (0, _helpersSegmentJs.v)(style.borderWidth, options.borderWidth);
    ctx.strokeStyle = (0, _helpersSegmentJs.v)(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
    if (options.stepped) return 0, _helpersSegmentJs.ar;
    if (options.tension || options.cubicInterpolationMode === "monotone") return 0, _helpersSegmentJs.as;
    return lineTo;
}
function pathVars(points, segment) {
    var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var count = points.length;
    var tmp = params.start, paramsStart = tmp === void 0 ? 0 : tmp, tmp1 = params.end, paramsEnd = tmp1 === void 0 ? count - 1 : tmp1;
    var segmentStart = segment.start, segmentEnd = segment.end;
    var start = Math.max(paramsStart, segmentStart);
    var end = Math.min(paramsEnd, segmentEnd);
    var outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
        count: count,
        start: start,
        loop: segment.loop,
        ilen: end < start && !outside ? count + end - start : end - start
    };
}
function pathSegment(ctx, line, segment, params) {
    var points = line.points, options = line.options;
    var _pathVars = pathVars(points, segment, params), count = _pathVars.count, start = _pathVars.start, loop = _pathVars.loop, ilen = _pathVars.ilen;
    var lineMethod = getLineMethod(options);
    var _ref = params || {}, _ref_move = _ref.move, move = _ref_move === void 0 ? true : _ref_move, reverse = _ref.reverse;
    var i, point, prev;
    for(i = 0; i <= ilen; ++i){
        point = points[(start + (reverse ? ilen - i : i)) % count];
        if (point.skip) continue;
        else if (move) {
            ctx.moveTo(point.x, point.y);
            move = false;
        } else lineMethod(ctx, prev, point, reverse, options.stepped);
        prev = point;
    }
    if (loop) {
        point = points[(start + (reverse ? ilen : 0)) % count];
        lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
    var points = line.points;
    var _pathVars = pathVars(points, segment, params), count = _pathVars.count, start = _pathVars.start, ilen = _pathVars.ilen;
    var _ref = params || {}, _ref_move = _ref.move, move = _ref_move === void 0 ? true : _ref_move, reverse = _ref.reverse;
    var avgX = 0;
    var countX = 0;
    var i, point, prevX, minY, maxY, lastY;
    var pointIndex = function(index) {
        return (start + (reverse ? ilen - index : index)) % count;
    };
    var drawX = function() {
        if (minY !== maxY) {
            ctx.lineTo(avgX, maxY);
            ctx.lineTo(avgX, minY);
            ctx.lineTo(avgX, lastY);
        }
    };
    if (move) {
        point = points[pointIndex(0)];
        ctx.moveTo(point.x, point.y);
    }
    for(i = 0; i <= ilen; ++i){
        point = points[pointIndex(i)];
        if (point.skip) continue;
        var x = point.x;
        var y = point.y;
        var truncX = x | 0;
        if (truncX === prevX) {
            if (y < minY) minY = y;
            else if (y > maxY) maxY = y;
            avgX = (countX * avgX + x) / ++countX;
        } else {
            drawX();
            ctx.lineTo(x, y);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
        }
        lastY = y;
    }
    drawX();
}
function _getSegmentMethod(line) {
    var opts = line.options;
    var borderDash = opts.borderDash && opts.borderDash.length;
    var useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
    if (options.stepped) return 0, _helpersSegmentJs.ao;
    if (options.tension || options.cubicInterpolationMode === "monotone") return 0, _helpersSegmentJs.ap;
    return 0, _helpersSegmentJs.aq;
}
function strokePathWithCache(ctx, line, start, count) {
    var path = line._path;
    if (!path) {
        path = line._path = new Path2D();
        if (line.path(path, start, count)) path.closePath();
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
    var segments = line.segments, options = line.options;
    var segmentMethod = _getSegmentMethod(line);
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = segments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var segment = _step.value;
            setStyle(ctx, options, segment.style);
            ctx.beginPath();
            if (segmentMethod(ctx, line, segment, {
                start: start,
                end: start + count - 1
            })) ctx.closePath();
            ctx.stroke();
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}
var usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
    if (usePath2D && !line.options.segment) strokePathWithCache(ctx, line, start, count);
    else strokePathDirect(ctx, line, start, count);
}
var LineElement = /*#__PURE__*/ function(Element) {
    "use strict";
    (0, _inherits._)(LineElement, Element);
    var _super = (0, _createSuper._)(LineElement);
    function LineElement(cfg) {
        (0, _classCallCheck._)(this, LineElement);
        var _this;
        _this = _super.call(this);
        _this.animated = true;
        _this.options = undefined;
        _this._chart = undefined;
        _this._loop = undefined;
        _this._fullLoop = undefined;
        _this._path = undefined;
        _this._points = undefined;
        _this._segments = undefined;
        _this._decimated = false;
        _this._pointsUpdated = false;
        _this._datasetIndex = undefined;
        if (cfg) Object.assign((0, _assertThisInitialized._)(_this), cfg);
        return _this;
    }
    (0, _createClass._)(LineElement, [
        {
            key: "updateControlPoints",
            value: function updateControlPoints(chartArea, indexAxis) {
                var options = this.options;
                if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
                    var loop = options.spanGaps ? this._loop : this._fullLoop;
                    (0, _helpersSegmentJs.al)(this._points, options, chartArea, loop, indexAxis);
                    this._pointsUpdated = true;
                }
            }
        },
        {
            key: "points",
            get: function get() {
                return this._points;
            },
            set: function set(points) {
                this._points = points;
                delete this._segments;
                delete this._path;
                this._pointsUpdated = false;
            }
        },
        {
            key: "segments",
            get: function get() {
                return this._segments || (this._segments = (0, _helpersSegmentJs.am)(this, this.options.segment));
            }
        },
        {
            key: "first",
            value: function first() {
                var segments = this.segments;
                var points = this.points;
                return segments.length && points[segments[0].start];
            }
        },
        {
            key: "last",
            value: function last() {
                var segments = this.segments;
                var points = this.points;
                var count = segments.length;
                return count && points[segments[count - 1].end];
            }
        },
        {
            key: "interpolate",
            value: function interpolate(point, property) {
                var options = this.options;
                var value = point[property];
                var points = this.points;
                var segments = (0, _helpersSegmentJs.an)(this, {
                    property: property,
                    start: value,
                    end: value
                });
                if (!segments.length) return;
                var result = [];
                var _interpolate = _getInterpolationMethod(options);
                var i, ilen;
                for(i = 0, ilen = segments.length; i < ilen; ++i){
                    var _segments_i = segments[i], start = _segments_i.start, end = _segments_i.end;
                    var p1 = points[start];
                    var p2 = points[end];
                    if (p1 === p2) {
                        result.push(p1);
                        continue;
                    }
                    var t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
                    var interpolated = _interpolate(p1, p2, t, options.stepped);
                    interpolated[property] = point[property];
                    result.push(interpolated);
                }
                return result.length === 1 ? result[0] : result;
            }
        },
        {
            key: "pathSegment",
            value: function pathSegment(ctx, segment, params) {
                var segmentMethod = _getSegmentMethod(this);
                return segmentMethod(ctx, this, segment, params);
            }
        },
        {
            key: "path",
            value: function path(ctx, start, count) {
                var segments = this.segments;
                var segmentMethod = _getSegmentMethod(this);
                var loop = this._loop;
                start = start || 0;
                count = count || this.points.length - start;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = segments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var segment = _step.value;
                        loop &= segmentMethod(ctx, this, segment, {
                            start: start,
                            end: start + count - 1
                        });
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return !!loop;
            }
        },
        {
            key: "draw",
            value: function draw1(ctx, chartArea, start, count) {
                var options = this.options || {};
                var points = this.points || [];
                if (points.length && options.borderWidth) {
                    ctx.save();
                    draw(ctx, this, start, count);
                    ctx.restore();
                }
                if (this.animated) {
                    this._pointsUpdated = false;
                    this._path = undefined;
                }
            }
        }
    ]);
    return LineElement;
}((0, _wrapNativeSuper._)(Element));
(0, _defineProperty._)(LineElement, "id", "line");
(0, _defineProperty._)(LineElement, "defaults", {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: "default",
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
});
(0, _defineProperty._)(LineElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
});
(0, _defineProperty._)(LineElement, "descriptors", {
    _scriptable: true,
    _indexable: function(name) {
        return name !== "borderDash" && name !== "fill";
    }
});
function inRange$1(el, pos, axis, useFinalPosition) {
    var options = el.options;
    var _el_getProps = el.getProps([
        axis
    ], useFinalPosition), value = _el_getProps[axis];
    return Math.abs(pos - value) < options.radius + options.hitRadius;
}
var PointElement = /*#__PURE__*/ function(Element) {
    "use strict";
    (0, _inherits._)(PointElement, Element);
    var _super = (0, _createSuper._)(PointElement);
    function PointElement(cfg) {
        (0, _classCallCheck._)(this, PointElement);
        var _this;
        _this = _super.call(this);
        (0, _defineProperty._)((0, _assertThisInitialized._)(_this), "parsed", void 0);
        (0, _defineProperty._)((0, _assertThisInitialized._)(_this), "skip", void 0);
        (0, _defineProperty._)((0, _assertThisInitialized._)(_this), "stop", void 0);
        _this.options = undefined;
        _this.parsed = undefined;
        _this.skip = undefined;
        _this.stop = undefined;
        if (cfg) Object.assign((0, _assertThisInitialized._)(_this), cfg);
        return _this;
    }
    (0, _createClass._)(PointElement, [
        {
            key: "inRange",
            value: function inRange(mouseX, mouseY, useFinalPosition) {
                var options = this.options;
                var _this_getProps = this.getProps([
                    "x",
                    "y"
                ], useFinalPosition), x = _this_getProps.x, y = _this_getProps.y;
                return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
            }
        },
        {
            key: "inXRange",
            value: function inXRange(mouseX, useFinalPosition) {
                return inRange$1(this, mouseX, "x", useFinalPosition);
            }
        },
        {
            key: "inYRange",
            value: function inYRange(mouseY, useFinalPosition) {
                return inRange$1(this, mouseY, "y", useFinalPosition);
            }
        },
        {
            key: "getCenterPoint",
            value: function getCenterPoint(useFinalPosition) {
                var _this_getProps = this.getProps([
                    "x",
                    "y"
                ], useFinalPosition), x = _this_getProps.x, y = _this_getProps.y;
                return {
                    x: x,
                    y: y
                };
            }
        },
        {
            key: "size",
            value: function size(options) {
                options = options || this.options || {};
                var radius = options.radius || 0;
                radius = Math.max(radius, radius && options.hoverRadius || 0);
                var borderWidth = radius && options.borderWidth || 0;
                return (radius + borderWidth) * 2;
            }
        },
        {
            key: "draw",
            value: function draw(ctx, area) {
                var options = this.options;
                if (this.skip || options.radius < 0.1 || !(0, _helpersSegmentJs.C)(this, area, this.size(options) / 2)) return;
                ctx.strokeStyle = options.borderColor;
                ctx.lineWidth = options.borderWidth;
                ctx.fillStyle = options.backgroundColor;
                (0, _helpersSegmentJs.at)(ctx, options, this.x, this.y);
            }
        },
        {
            key: "getRange",
            value: function getRange() {
                var options = this.options || {};
                // @ts-expect-error Fallbacks should never be hit in practice
                return options.radius + options.hitRadius;
            }
        }
    ]);
    return PointElement;
}((0, _wrapNativeSuper._)(Element));
(0, _defineProperty._)(PointElement, "id", "point");
/**
   * @type {any}
   */ (0, _defineProperty._)(PointElement, "defaults", {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
});
/**
   * @type {any}
   */ (0, _defineProperty._)(PointElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
});
function getBarBounds(bar, useFinalPosition) {
    var _bar_getProps = bar.getProps([
        "x",
        "y",
        "base",
        "width",
        "height"
    ], useFinalPosition), x = _bar_getProps.x, y = _bar_getProps.y, base = _bar_getProps.base, width = _bar_getProps.width, height = _bar_getProps.height;
    var left, right, top, bottom, half;
    if (bar.horizontal) {
        half = height / 2;
        left = Math.min(x, base);
        right = Math.max(x, base);
        top = y - half;
        bottom = y + half;
    } else {
        half = width / 2;
        left = x - half;
        right = x + half;
        top = Math.min(y, base);
        bottom = Math.max(y, base);
    }
    return {
        left: left,
        top: top,
        right: right,
        bottom: bottom
    };
}
function skipOrLimit(skip, value, min, max) {
    return skip ? 0 : (0, _helpersSegmentJs.S)(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
    var value = bar.options.borderWidth;
    var skip = bar.borderSkipped;
    var o = (0, _helpersSegmentJs.av)(value);
    return {
        t: skipOrLimit(skip.top, o.top, 0, maxH),
        r: skipOrLimit(skip.right, o.right, 0, maxW),
        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
        l: skipOrLimit(skip.left, o.left, 0, maxW)
    };
}
function parseBorderRadius(bar, maxW, maxH) {
    var enableBorderRadius = bar.getProps([
        "enableBorderRadius"
    ]).enableBorderRadius;
    var value = bar.options.borderRadius;
    var o = (0, _helpersSegmentJs.aw)(value);
    var maxR = Math.min(maxW, maxH);
    var skip = bar.borderSkipped;
    var enableBorder = enableBorderRadius || (0, _helpersSegmentJs.i)(value);
    return {
        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
    };
}
function boundingRects(bar) {
    var bounds = getBarBounds(bar);
    var width = bounds.right - bounds.left;
    var height = bounds.bottom - bounds.top;
    var border = parseBorderWidth(bar, width / 2, height / 2);
    var radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
        outer: {
            x: bounds.left,
            y: bounds.top,
            w: width,
            h: height,
            radius: radius
        },
        inner: {
            x: bounds.left + border.l,
            y: bounds.top + border.t,
            w: width - border.l - border.r,
            h: height - border.t - border.b,
            radius: {
                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
            }
        }
    };
}
function inRange(bar, x, y, useFinalPosition) {
    var skipX = x === null;
    var skipY = y === null;
    var skipBoth = skipX && skipY;
    var bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || (0, _helpersSegmentJs.aj)(x, bounds.left, bounds.right)) && (skipY || (0, _helpersSegmentJs.aj)(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount) {
    var refRect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var x = rect.x !== refRect.x ? -amount : 0;
    var y = rect.y !== refRect.y ? -amount : 0;
    var w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
    var h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
    return {
        x: rect.x + x,
        y: rect.y + y,
        w: rect.w + w,
        h: rect.h + h,
        radius: rect.radius
    };
}
var BarElement = /*#__PURE__*/ function(Element) {
    "use strict";
    (0, _inherits._)(BarElement, Element);
    var _super = (0, _createSuper._)(BarElement);
    function BarElement(cfg) {
        (0, _classCallCheck._)(this, BarElement);
        var _this;
        _this = _super.call(this);
        _this.options = undefined;
        _this.horizontal = undefined;
        _this.base = undefined;
        _this.width = undefined;
        _this.height = undefined;
        _this.inflateAmount = undefined;
        if (cfg) Object.assign((0, _assertThisInitialized._)(_this), cfg);
        return _this;
    }
    (0, _createClass._)(BarElement, [
        {
            key: "draw",
            value: function draw(ctx) {
                var _this = this, inflateAmount = _this.inflateAmount, _this_options = _this.options, borderColor = _this_options.borderColor, backgroundColor = _this_options.backgroundColor;
                var _boundingRects = boundingRects(this), inner = _boundingRects.inner, outer = _boundingRects.outer;
                var addRectPath = hasRadius(outer.radius) ? (0, _helpersSegmentJs.au) : addNormalRectPath;
                ctx.save();
                if (outer.w !== inner.w || outer.h !== inner.h) {
                    ctx.beginPath();
                    addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
                    ctx.clip();
                    addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
                    ctx.fillStyle = borderColor;
                    ctx.fill("evenodd");
                }
                ctx.beginPath();
                addRectPath(ctx, inflateRect(inner, inflateAmount));
                ctx.fillStyle = backgroundColor;
                ctx.fill();
                ctx.restore();
            }
        },
        {
            key: "inRange",
            value: function inRange1(mouseX, mouseY, useFinalPosition) {
                return inRange(this, mouseX, mouseY, useFinalPosition);
            }
        },
        {
            key: "inXRange",
            value: function inXRange(mouseX, useFinalPosition) {
                return inRange(this, mouseX, null, useFinalPosition);
            }
        },
        {
            key: "inYRange",
            value: function inYRange(mouseY, useFinalPosition) {
                return inRange(this, null, mouseY, useFinalPosition);
            }
        },
        {
            key: "getCenterPoint",
            value: function getCenterPoint(useFinalPosition) {
                var _this_getProps = this.getProps([
                    "x",
                    "y",
                    "base",
                    "horizontal"
                ], useFinalPosition), x = _this_getProps.x, y = _this_getProps.y, base = _this_getProps.base, horizontal = _this_getProps.horizontal;
                return {
                    x: horizontal ? (x + base) / 2 : x,
                    y: horizontal ? y : (y + base) / 2
                };
            }
        },
        {
            key: "getRange",
            value: function getRange(axis) {
                return axis === "x" ? this.width / 2 : this.height / 2;
            }
        }
    ]);
    return BarElement;
}((0, _wrapNativeSuper._)(Element));
(0, _defineProperty._)(BarElement, "id", "bar");
(0, _defineProperty._)(BarElement, "defaults", {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: undefined
});
(0, _defineProperty._)(BarElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
});
var elements = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ArcElement: ArcElement,
    BarElement: BarElement,
    LineElement: LineElement,
    PointElement: PointElement
});
var BORDER_COLORS = [
    "rgb(54, 162, 235)",
    "rgb(255, 99, 132)",
    "rgb(255, 159, 64)",
    "rgb(255, 205, 86)",
    "rgb(75, 192, 192)",
    "rgb(153, 102, 255)",
    "rgb(201, 203, 207)" // grey
];
// Border colors with 50% transparency
var BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map(function(color) {
    return color.replace("rgb(", "rgba(").replace(")", ", 0.5)");
});
function getBorderColor(i) {
    return BORDER_COLORS[i % BORDER_COLORS.length];
}
function getBackgroundColor(i) {
    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i) {
    dataset.borderColor = getBorderColor(i);
    dataset.backgroundColor = getBackgroundColor(i);
    return ++i;
}
function colorizeDoughnutDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(function() {
        return getBorderColor(i++);
    });
    return i;
}
function colorizePolarAreaDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(function() {
        return getBackgroundColor(i++);
    });
    return i;
}
function getColorizer(chart) {
    var i = 0;
    return function(dataset, datasetIndex) {
        var controller = chart.getDatasetMeta(datasetIndex).controller;
        if (controller instanceof DoughnutController) i = colorizeDoughnutDataset(dataset, i);
        else if (controller instanceof PolarAreaController) i = colorizePolarAreaDataset(dataset, i);
        else if (controller) i = colorizeDefaultDataset(dataset, i);
    };
}
function containsColorsDefinitions(descriptors) {
    var k;
    for(k in descriptors){
        if (descriptors[k].borderColor || descriptors[k].backgroundColor) return true;
    }
    return false;
}
function containsColorsDefinition(descriptor) {
    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
var plugin_colors = {
    id: "colors",
    defaults: {
        enabled: true,
        forceOverride: false
    },
    beforeLayout: function(chart, _args, options) {
        if (!options.enabled) return;
        var _chart_config = chart.config, datasets = _chart_config.data.datasets, chartOptions = _chart_config.options;
        var elements = chartOptions.elements;
        if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements))) return;
        var colorizer = getColorizer(chart);
        datasets.forEach(colorizer);
    }
};
function lttbDecimation(data, start, count, availableWidth, options) {
    var samples = options.samples || availableWidth;
    if (samples >= count) return data.slice(start, start + count);
    var decimated = [];
    var bucketWidth = (count - 2) / (samples - 2);
    var sampledIndex = 0;
    var endIndex = start + count - 1;
    var a = start;
    var i, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data[a];
    for(i = 0; i < samples - 2; i++){
        var avgX = 0;
        var avgY = 0;
        var j = void 0;
        var avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
        var avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
        var avgRangeLength = avgRangeEnd - avgRangeStart;
        for(j = avgRangeStart; j < avgRangeEnd; j++){
            avgX += data[j].x;
            avgY += data[j].y;
        }
        avgX /= avgRangeLength;
        avgY /= avgRangeLength;
        var rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
        var rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
        var _data_a = data[a], pointAx = _data_a.x, pointAy = _data_a.y;
        maxArea = area = -1;
        for(j = rangeOffs; j < rangeTo; j++){
            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
            if (area > maxArea) {
                maxArea = area;
                maxAreaPoint = data[j];
                nextA = j;
            }
        }
        decimated[sampledIndex++] = maxAreaPoint;
        a = nextA;
    }
    decimated[sampledIndex++] = data[endIndex];
    return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
    var avgX = 0;
    var countX = 0;
    var i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    var decimated = [];
    var endIndex = start + count - 1;
    var xMin = data[start].x;
    var xMax = data[endIndex].x;
    var dx = xMax - xMin;
    for(i = start; i < start + count; ++i){
        point = data[i];
        x = (point.x - xMin) / dx * availableWidth;
        y = point.y;
        var truncX = x | 0;
        if (truncX === prevX) {
            if (y < minY) {
                minY = y;
                minIndex = i;
            } else if (y > maxY) {
                maxY = y;
                maxIndex = i;
            }
            avgX = (countX * avgX + point.x) / ++countX;
        } else {
            var lastIndex = i - 1;
            if (!(0, _helpersSegmentJs.k)(minIndex) && !(0, _helpersSegmentJs.k)(maxIndex)) {
                var intermediateIndex1 = Math.min(minIndex, maxIndex);
                var intermediateIndex2 = Math.max(minIndex, maxIndex);
                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) decimated.push((0, _objectSpreadProps._)((0, _objectSpread._)({}, data[intermediateIndex1]), {
                    x: avgX
                }));
                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) decimated.push((0, _objectSpreadProps._)((0, _objectSpread._)({}, data[intermediateIndex2]), {
                    x: avgX
                }));
            }
            if (i > 0 && lastIndex !== startIndex) decimated.push(data[lastIndex]);
            decimated.push(point);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
            minIndex = maxIndex = startIndex = i;
        }
    }
    return decimated;
}
function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
        var data = dataset._data;
        delete dataset._decimated;
        delete dataset._data;
        Object.defineProperty(dataset, "data", {
            configurable: true,
            enumerable: true,
            writable: true,
            value: data
        });
    }
}
function cleanDecimatedData(chart) {
    chart.data.datasets.forEach(function(dataset) {
        cleanDecimatedDataset(dataset);
    });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
    var pointCount = points.length;
    var start = 0;
    var count;
    var iScale = meta.iScale;
    var _iScale_getUserBounds = iScale.getUserBounds(), min = _iScale_getUserBounds.min, max = _iScale_getUserBounds.max, minDefined = _iScale_getUserBounds.minDefined, maxDefined = _iScale_getUserBounds.maxDefined;
    if (minDefined) start = (0, _helpersSegmentJs.S)((0, _helpersSegmentJs.B)(points, iScale.axis, min).lo, 0, pointCount - 1);
    if (maxDefined) count = (0, _helpersSegmentJs.S)((0, _helpersSegmentJs.B)(points, iScale.axis, max).hi + 1, start, pointCount) - start;
    else count = pointCount - start;
    return {
        start: start,
        count: count
    };
}
var plugin_decimation = {
    id: "decimation",
    defaults: {
        algorithm: "min-max",
        enabled: false
    },
    beforeElementsUpdate: function(chart, args, options) {
        if (!options.enabled) {
            cleanDecimatedData(chart);
            return;
        }
        var availableWidth = chart.width;
        chart.data.datasets.forEach(function(dataset, datasetIndex) {
            var _data = dataset._data, indexAxis = dataset.indexAxis;
            var meta = chart.getDatasetMeta(datasetIndex);
            var data = _data || dataset.data;
            if ((0, _helpersSegmentJs.a)([
                indexAxis,
                chart.options.indexAxis
            ]) === "y") return;
            if (!meta.controller.supportsDecimation) return;
            var xAxis = chart.scales[meta.xAxisID];
            if (xAxis.type !== "linear" && xAxis.type !== "time") return;
            if (chart.options.parsing) return;
            var _getStartAndCountOfVisiblePointsSimplified = getStartAndCountOfVisiblePointsSimplified(meta, data), start = _getStartAndCountOfVisiblePointsSimplified.start, count = _getStartAndCountOfVisiblePointsSimplified.count;
            var threshold = options.threshold || 4 * availableWidth;
            if (count <= threshold) {
                cleanDecimatedDataset(dataset);
                return;
            }
            if ((0, _helpersSegmentJs.k)(_data)) {
                dataset._data = data;
                delete dataset.data;
                Object.defineProperty(dataset, "data", {
                    configurable: true,
                    enumerable: true,
                    get: function get() {
                        return this._decimated;
                    },
                    set: function set(d) {
                        this._data = d;
                    }
                });
            }
            var decimated;
            switch(options.algorithm){
                case "lttb":
                    decimated = lttbDecimation(data, start, count, availableWidth, options);
                    break;
                case "min-max":
                    decimated = minMaxDecimation(data, start, count, availableWidth);
                    break;
                default:
                    throw new Error("Unsupported decimation algorithm '".concat(options.algorithm, "'"));
            }
            dataset._decimated = decimated;
        });
    },
    destroy: function(chart) {
        cleanDecimatedData(chart);
    }
};
function _segments(line, target, property) {
    var segments = line.segments;
    var points = line.points;
    var tpoints = target.points;
    var parts = [];
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = segments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var segment = _step.value;
            var start = segment.start, end = segment.end;
            end = _findSegmentEnd(start, end, points);
            var bounds = _getBounds(property, points[start], points[end], segment.loop);
            if (!target.segments) {
                parts.push({
                    source: segment,
                    target: bounds,
                    start: points[start],
                    end: points[end]
                });
                continue;
            }
            var targetSegments = (0, _helpersSegmentJs.an)(target, bounds);
            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
            try {
                for(var _iterator1 = targetSegments[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                    var tgt = _step1.value;
                    var subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
                    var fillSources = (0, _helpersSegmentJs.ax)(segment, points, subBounds);
                    var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                    try {
                        for(var _iterator2 = fillSources[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                            var fillSource = _step2.value;
                            parts.push({
                                source: fillSource,
                                target: tgt,
                                start: (0, _defineProperty._)({}, property, _getEdge(bounds, subBounds, "start", Math.max)),
                                end: (0, _defineProperty._)({}, property, _getEdge(bounds, subBounds, "end", Math.min))
                            });
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                                _iterator2.return();
                            }
                        } finally{
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }
                }
            } catch (err) {
                _didIteratorError1 = true;
                _iteratorError1 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                        _iterator1.return();
                    }
                } finally{
                    if (_didIteratorError1) {
                        throw _iteratorError1;
                    }
                }
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return parts;
}
function _getBounds(property, first, last, loop) {
    if (loop) return;
    var start = first[property];
    var end = last[property];
    if (property === "angle") {
        start = (0, _helpersSegmentJs.ay)(start);
        end = (0, _helpersSegmentJs.ay)(end);
    }
    return {
        property: property,
        start: start,
        end: end
    };
}
function _pointsFromSegments(boundary, line) {
    var _ref = boundary || {}, _ref_x = _ref.x, x = _ref_x === void 0 ? null : _ref_x, _ref_y = _ref.y, y = _ref_y === void 0 ? null : _ref_y;
    var linePoints = line.points;
    var points = [];
    line.segments.forEach(function(param) {
        var start = param.start, end = param.end;
        end = _findSegmentEnd(start, end, linePoints);
        var first = linePoints[start];
        var last = linePoints[end];
        if (y !== null) {
            points.push({
                x: first.x,
                y: y
            });
            points.push({
                x: last.x,
                y: y
            });
        } else if (x !== null) {
            points.push({
                x: x,
                y: first.y
            });
            points.push({
                x: x,
                y: last.y
            });
        }
    });
    return points;
}
function _findSegmentEnd(start, end, points) {
    for(; end > start; end--){
        var point = points[end];
        if (!isNaN(point.x) && !isNaN(point.y)) break;
    }
    return end;
}
function _getEdge(a, b, prop, fn) {
    if (a && b) return fn(a[prop], b[prop]);
    return a ? a[prop] : b ? b[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
    var points = [];
    var _loop = false;
    if ((0, _helpersSegmentJs.b)(boundary)) {
        _loop = true;
        points = boundary;
    } else points = _pointsFromSegments(boundary, line);
    return points.length ? new LineElement({
        points: points,
        options: {
            tension: 0
        },
        _loop: _loop,
        _fullLoop: _loop
    }) : null;
}
function _shouldApplyFill(source) {
    return source && source.fill !== false;
}
function _resolveTarget(sources, index, propagate) {
    var source = sources[index];
    var fill = source.fill;
    var visited = [
        index
    ];
    var target;
    if (!propagate) return fill;
    while(fill !== false && visited.indexOf(fill) === -1){
        if (!(0, _helpersSegmentJs.g)(fill)) return fill;
        target = sources[fill];
        if (!target) return false;
        if (target.visible) return fill;
        visited.push(fill);
        fill = target.fill;
    }
    return false;
}
function _decodeFill(line, index, count) {
    var fill = parseFillOption(line);
    if ((0, _helpersSegmentJs.i)(fill)) return isNaN(fill.value) ? false : fill;
    var target = parseFloat(fill);
    if ((0, _helpersSegmentJs.g)(target) && Math.floor(target) === target) return decodeTargetIndex(fill[0], index, target, count);
    return [
        "origin",
        "start",
        "end",
        "stack",
        "shape"
    ].indexOf(fill) >= 0 && fill;
}
function decodeTargetIndex(firstCh, index, target, count) {
    if (firstCh === "-" || firstCh === "+") target = index + target;
    if (target === index || target < 0 || target >= count) return false;
    return target;
}
function _getTargetPixel(fill, scale) {
    var pixel = null;
    if (fill === "start") pixel = scale.bottom;
    else if (fill === "end") pixel = scale.top;
    else if ((0, _helpersSegmentJs.i)(fill)) pixel = scale.getPixelForValue(fill.value);
    else if (scale.getBasePixel) pixel = scale.getBasePixel();
    return pixel;
}
function _getTargetValue(fill, scale, startValue) {
    var value;
    if (fill === "start") value = startValue;
    else if (fill === "end") value = scale.options.reverse ? scale.min : scale.max;
    else if ((0, _helpersSegmentJs.i)(fill)) value = fill.value;
    else value = scale.getBaseValue();
    return value;
}
function parseFillOption(line) {
    var options = line.options;
    var fillOption = options.fill;
    var fill = (0, _helpersSegmentJs.v)(fillOption && fillOption.target, fillOption);
    if (fill === undefined) fill = !!options.backgroundColor;
    if (fill === false || fill === null) return false;
    if (fill === true) return "origin";
    return fill;
}
function _buildStackLine(source) {
    var scale = source.scale, index = source.index, line = source.line;
    var points = [];
    var segments = line.segments;
    var sourcePoints = line.points;
    var linesBelow = getLinesBelow(scale, index);
    linesBelow.push(_createBoundaryLine({
        x: null,
        y: scale.bottom
    }, line));
    for(var i = 0; i < segments.length; i++){
        var segment = segments[i];
        for(var j = segment.start; j <= segment.end; j++)addPointsBelow(points, sourcePoints[j], linesBelow);
    }
    return new LineElement({
        points: points,
        options: {}
    });
}
function getLinesBelow(scale, index) {
    var below = [];
    var metas = scale.getMatchingVisibleMetas("line");
    for(var i = 0; i < metas.length; i++){
        var meta = metas[i];
        if (meta.index === index) break;
        if (!meta.hidden) below.unshift(meta.dataset);
    }
    return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
    var _points;
    var postponed = [];
    for(var j = 0; j < linesBelow.length; j++){
        var line = linesBelow[j];
        var _findPoint = findPoint(line, sourcePoint, "x"), first = _findPoint.first, last = _findPoint.last, point = _findPoint.point;
        if (!point || first && last) continue;
        if (first) postponed.unshift(point);
        else {
            points.push(point);
            if (!last) break;
        }
    }
    (_points = points).push.apply(_points, (0, _toConsumableArray._)(postponed));
}
function findPoint(line, sourcePoint, property) {
    var point = line.interpolate(sourcePoint, property);
    if (!point) return {};
    var pointValue = point[property];
    var segments = line.segments;
    var linePoints = line.points;
    var first = false;
    var last = false;
    for(var i = 0; i < segments.length; i++){
        var segment = segments[i];
        var firstValue = linePoints[segment.start][property];
        var lastValue = linePoints[segment.end][property];
        if ((0, _helpersSegmentJs.aj)(pointValue, firstValue, lastValue)) {
            first = pointValue === firstValue;
            last = pointValue === lastValue;
            break;
        }
    }
    return {
        first: first,
        last: last,
        point: point
    };
}
var simpleArc = /*#__PURE__*/ function() {
    "use strict";
    function simpleArc(opts) {
        (0, _classCallCheck._)(this, simpleArc);
        this.x = opts.x;
        this.y = opts.y;
        this.radius = opts.radius;
    }
    (0, _createClass._)(simpleArc, [
        {
            key: "pathSegment",
            value: function pathSegment(ctx, bounds, opts) {
                var _this = this, x = _this.x, y = _this.y, radius = _this.radius;
                bounds = bounds || {
                    start: 0,
                    end: (0, _helpersSegmentJs.T)
                };
                ctx.arc(x, y, radius, bounds.end, bounds.start, true);
                return !opts.bounds;
            }
        },
        {
            key: "interpolate",
            value: function interpolate(point) {
                var _this = this, x = _this.x, y = _this.y, radius = _this.radius;
                var angle = point.angle;
                return {
                    x: x + Math.cos(angle) * radius,
                    y: y + Math.sin(angle) * radius,
                    angle: angle
                };
            }
        }
    ]);
    return simpleArc;
}();
function _getTarget(source) {
    var chart = source.chart, fill = source.fill, line = source.line;
    if ((0, _helpersSegmentJs.g)(fill)) return getLineByIndex(chart, fill);
    if (fill === "stack") return _buildStackLine(source);
    if (fill === "shape") return true;
    var boundary = computeBoundary(source);
    if (boundary instanceof simpleArc) return boundary;
    return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index) {
    var meta = chart.getDatasetMeta(index);
    var visible = meta && chart.isDatasetVisible(index);
    return visible ? meta.dataset : null;
}
function computeBoundary(source) {
    var scale = source.scale || {};
    if (scale.getPointPositionForValue) return computeCircularBoundary(source);
    return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
    var _source_scale = source.scale, scale = _source_scale === void 0 ? {} : _source_scale, fill = source.fill;
    var pixel = _getTargetPixel(fill, scale);
    if ((0, _helpersSegmentJs.g)(pixel)) {
        var horizontal = scale.isHorizontal();
        return {
            x: horizontal ? pixel : null,
            y: horizontal ? null : pixel
        };
    }
    return null;
}
function computeCircularBoundary(source) {
    var scale = source.scale, fill = source.fill;
    var options = scale.options;
    var length = scale.getLabels().length;
    var start = options.reverse ? scale.max : scale.min;
    var value = _getTargetValue(fill, scale, start);
    var target = [];
    if (options.grid.circular) {
        var center = scale.getPointPositionForValue(0, start);
        return new simpleArc({
            x: center.x,
            y: center.y,
            radius: scale.getDistanceFromCenterForValue(value)
        });
    }
    for(var i = 0; i < length; ++i)target.push(scale.getPointPositionForValue(i, value));
    return target;
}
function _drawfill(ctx, source, area) {
    var target = _getTarget(source);
    var line = source.line, scale = source.scale, axis = source.axis;
    var lineOpts = line.options;
    var fillOption = lineOpts.fill;
    var color = lineOpts.backgroundColor;
    var _ref = fillOption || {}, _ref_above = _ref.above, above = _ref_above === void 0 ? color : _ref_above, _ref_below = _ref.below, below = _ref_below === void 0 ? color : _ref_below;
    if (target && line.points.length) {
        (0, _helpersSegmentJs.Y)(ctx, area);
        doFill(ctx, {
            line: line,
            target: target,
            above: above,
            below: below,
            area: area,
            scale: scale,
            axis: axis
        });
        (0, _helpersSegmentJs.$)(ctx);
    }
}
function doFill(ctx, cfg) {
    var line = cfg.line, target = cfg.target, above = cfg.above, below = cfg.below, area = cfg.area, scale = cfg.scale;
    var property = line._loop ? "angle" : cfg.axis;
    ctx.save();
    if (property === "x" && below !== above) {
        clipVertical(ctx, target, area.top);
        fill(ctx, {
            line: line,
            target: target,
            color: above,
            scale: scale,
            property: property
        });
        ctx.restore();
        ctx.save();
        clipVertical(ctx, target, area.bottom);
    }
    fill(ctx, {
        line: line,
        target: target,
        color: below,
        scale: scale,
        property: property
    });
    ctx.restore();
}
function clipVertical(ctx, target, clipY) {
    var segments = target.segments, points = target.points;
    var first = true;
    var lineLoop = false;
    ctx.beginPath();
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = segments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var segment = _step.value;
            var start = segment.start, end = segment.end;
            var firstPoint = points[start];
            var lastPoint = points[_findSegmentEnd(start, end, points)];
            if (first) {
                ctx.moveTo(firstPoint.x, firstPoint.y);
                first = false;
            } else {
                ctx.lineTo(firstPoint.x, clipY);
                ctx.lineTo(firstPoint.x, firstPoint.y);
            }
            lineLoop = !!target.pathSegment(ctx, segment, {
                move: lineLoop
            });
            if (lineLoop) ctx.closePath();
            else ctx.lineTo(lastPoint.x, clipY);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
}
function fill(ctx, cfg) {
    var line = cfg.line, target = cfg.target, property = cfg.property, color = cfg.color, scale = cfg.scale;
    var segments = _segments(line, target, property);
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = segments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _step_value = _step.value, src = _step_value.source, tgt = _step_value.target, start = _step_value.start, end = _step_value.end;
            var tmp = src.style, _ref = tmp === void 0 ? {} : tmp, _ref_backgroundColor = _ref.backgroundColor, backgroundColor = _ref_backgroundColor === void 0 ? color : _ref_backgroundColor;
            var notShape = target !== true;
            ctx.save();
            ctx.fillStyle = backgroundColor;
            clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
            ctx.beginPath();
            var lineLoop = !!line.pathSegment(ctx, src);
            var loop = void 0;
            if (notShape) {
                if (lineLoop) ctx.closePath();
                else interpolatedLineTo(ctx, target, end, property);
                var targetLoop = !!target.pathSegment(ctx, tgt, {
                    move: lineLoop,
                    reverse: true
                });
                loop = lineLoop && targetLoop;
                if (!loop) interpolatedLineTo(ctx, target, start, property);
            }
            ctx.closePath();
            ctx.fill(loop ? "evenodd" : "nonzero");
            ctx.restore();
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}
function clipBounds(ctx, scale, bounds) {
    var _scale_chart_chartArea = scale.chart.chartArea, top = _scale_chart_chartArea.top, bottom = _scale_chart_chartArea.bottom;
    var _ref = bounds || {}, property = _ref.property, start = _ref.start, end = _ref.end;
    if (property === "x") {
        ctx.beginPath();
        ctx.rect(start, top, end - start, bottom - top);
        ctx.clip();
    }
}
function interpolatedLineTo(ctx, target, point, property) {
    var interpolatedPoint = target.interpolate(point, property);
    if (interpolatedPoint) ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
}
var index = {
    id: "filler",
    afterDatasetsUpdate: function(chart, _args, options) {
        var count = (chart.data.datasets || []).length;
        var sources = [];
        var meta, i, line, source;
        for(i = 0; i < count; ++i){
            meta = chart.getDatasetMeta(i);
            line = meta.dataset;
            source = null;
            if (line && line.options && line instanceof LineElement) source = {
                visible: chart.isDatasetVisible(i),
                index: i,
                fill: _decodeFill(line, i, count),
                chart: chart,
                axis: meta.controller.options.indexAxis,
                scale: meta.vScale,
                line: line
            };
            meta.$filler = source;
            sources.push(source);
        }
        for(i = 0; i < count; ++i){
            source = sources[i];
            if (!source || source.fill === false) continue;
            source.fill = _resolveTarget(sources, i, options.propagate);
        }
    },
    beforeDraw: function(chart, _args, options) {
        var draw = options.drawTime === "beforeDraw";
        var metasets = chart.getSortedVisibleDatasetMetas();
        var area = chart.chartArea;
        for(var i = metasets.length - 1; i >= 0; --i){
            var source = metasets[i].$filler;
            if (!source) continue;
            source.line.updateControlPoints(area, source.axis);
            if (draw && source.fill) _drawfill(chart.ctx, source, area);
        }
    },
    beforeDatasetsDraw: function(chart, _args, options) {
        if (options.drawTime !== "beforeDatasetsDraw") return;
        var metasets = chart.getSortedVisibleDatasetMetas();
        for(var i = metasets.length - 1; i >= 0; --i){
            var source = metasets[i].$filler;
            if (_shouldApplyFill(source)) _drawfill(chart.ctx, source, chart.chartArea);
        }
    },
    beforeDatasetDraw: function(chart, args, options) {
        var source = args.meta.$filler;
        if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") return;
        _drawfill(chart.ctx, source, chart.chartArea);
    },
    defaults: {
        propagate: true,
        drawTime: "beforeDatasetDraw"
    }
};
var getBoxSize = function(labelOpts, fontSize) {
    var _labelOpts_boxHeight = labelOpts.boxHeight, boxHeight = _labelOpts_boxHeight === void 0 ? fontSize : _labelOpts_boxHeight, _labelOpts_boxWidth = labelOpts.boxWidth, boxWidth = _labelOpts_boxWidth === void 0 ? fontSize : _labelOpts_boxWidth;
    if (labelOpts.usePointStyle) {
        boxHeight = Math.min(boxHeight, fontSize);
        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
        boxWidth: boxWidth,
        boxHeight: boxHeight,
        itemHeight: Math.max(fontSize, boxHeight)
    };
};
var itemsEqual = function(a, b) {
    return a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
};
var Legend = /*#__PURE__*/ function(Element) {
    "use strict";
    (0, _inherits._)(Legend, Element);
    var _super = (0, _createSuper._)(Legend);
    function Legend(config) {
        (0, _classCallCheck._)(this, Legend);
        var _this;
        _this = _super.call(this);
        _this._added = false;
        _this.legendHitBoxes = [];
        _this._hoveredItem = null;
        _this.doughnutMode = false;
        _this.chart = config.chart;
        _this.options = config.options;
        _this.ctx = config.ctx;
        _this.legendItems = undefined;
        _this.columnSizes = undefined;
        _this.lineWidths = undefined;
        _this.maxHeight = undefined;
        _this.maxWidth = undefined;
        _this.top = undefined;
        _this.bottom = undefined;
        _this.left = undefined;
        _this.right = undefined;
        _this.height = undefined;
        _this.width = undefined;
        _this._margins = undefined;
        _this.position = undefined;
        _this.weight = undefined;
        _this.fullSize = undefined;
        return _this;
    }
    (0, _createClass._)(Legend, [
        {
            key: "update",
            value: function update(maxWidth, maxHeight, margins) {
                this.maxWidth = maxWidth;
                this.maxHeight = maxHeight;
                this._margins = margins;
                this.setDimensions();
                this.buildLabels();
                this.fit();
            }
        },
        {
            key: "setDimensions",
            value: function setDimensions() {
                if (this.isHorizontal()) {
                    this.width = this.maxWidth;
                    this.left = this._margins.left;
                    this.right = this.width;
                } else {
                    this.height = this.maxHeight;
                    this.top = this._margins.top;
                    this.bottom = this.height;
                }
            }
        },
        {
            key: "buildLabels",
            value: function buildLabels() {
                var _this = this;
                var labelOpts = this.options.labels || {};
                var legendItems = (0, _helpersSegmentJs.Q)(labelOpts.generateLabels, [
                    this.chart
                ], this) || [];
                if (labelOpts.filter) legendItems = legendItems.filter(function(item) {
                    return labelOpts.filter(item, _this.chart.data);
                });
                if (labelOpts.sort) legendItems = legendItems.sort(function(a, b) {
                    return labelOpts.sort(a, b, _this.chart.data);
                });
                if (this.options.reverse) legendItems.reverse();
                this.legendItems = legendItems;
            }
        },
        {
            key: "fit",
            value: function fit() {
                var _this = this, options = _this.options, ctx = _this.ctx;
                if (!options.display) {
                    this.width = this.height = 0;
                    return;
                }
                var labelOpts = options.labels;
                var labelFont = (0, _helpersSegmentJs.a0)(labelOpts.font);
                var fontSize = labelFont.size;
                var titleHeight = this._computeTitleHeight();
                var _getBoxSize = getBoxSize(labelOpts, fontSize), boxWidth = _getBoxSize.boxWidth, itemHeight = _getBoxSize.itemHeight;
                var width, height;
                ctx.font = labelFont.string;
                if (this.isHorizontal()) {
                    width = this.maxWidth;
                    height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
                } else {
                    height = this.maxHeight;
                    width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
                }
                this.width = Math.min(width, options.maxWidth || this.maxWidth);
                this.height = Math.min(height, options.maxHeight || this.maxHeight);
            }
        },
        {
            key: "_fitRows",
            value: function _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
                var _this = this, ctx = _this.ctx, maxWidth = _this.maxWidth, _this_options = _this.options, padding = _this_options.labels.padding;
                var hitboxes = this.legendHitBoxes = [];
                var lineWidths = this.lineWidths = [
                    0
                ];
                var lineHeight = itemHeight + padding;
                var totalHeight = titleHeight;
                ctx.textAlign = "left";
                ctx.textBaseline = "middle";
                var row = -1;
                var top = -lineHeight;
                this.legendItems.forEach(function(legendItem, i) {
                    var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                    if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
                        totalHeight += lineHeight;
                        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                        top += lineHeight;
                        row++;
                    }
                    hitboxes[i] = {
                        left: 0,
                        top: top,
                        row: row,
                        width: itemWidth,
                        height: itemHeight
                    };
                    lineWidths[lineWidths.length - 1] += itemWidth + padding;
                });
                return totalHeight;
            }
        },
        {
            key: "_fitCols",
            value: function _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
                var _this = this, ctx = _this.ctx, maxHeight = _this.maxHeight, _this_options = _this.options, padding = _this_options.labels.padding;
                var hitboxes = this.legendHitBoxes = [];
                var columnSizes = this.columnSizes = [];
                var heightLimit = maxHeight - titleHeight;
                var totalWidth = padding;
                var currentColWidth = 0;
                var currentColHeight = 0;
                var left = 0;
                var col = 0;
                this.legendItems.forEach(function(legendItem, i) {
                    var _calculateItemSize = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight), itemWidth = _calculateItemSize.itemWidth, itemHeight = _calculateItemSize.itemHeight;
                    if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
                        totalWidth += currentColWidth + padding;
                        columnSizes.push({
                            width: currentColWidth,
                            height: currentColHeight
                        });
                        left += currentColWidth + padding;
                        col++;
                        currentColWidth = currentColHeight = 0;
                    }
                    hitboxes[i] = {
                        left: left,
                        top: currentColHeight,
                        col: col,
                        width: itemWidth,
                        height: itemHeight
                    };
                    currentColWidth = Math.max(currentColWidth, itemWidth);
                    currentColHeight += itemHeight + padding;
                });
                totalWidth += currentColWidth;
                columnSizes.push({
                    width: currentColWidth,
                    height: currentColHeight
                });
                return totalWidth;
            }
        },
        {
            key: "adjustHitBoxes",
            value: function adjustHitBoxes() {
                if (!this.options.display) return;
                var titleHeight = this._computeTitleHeight();
                var _this = this, hitboxes = _this.legendHitBoxes, _this_options = _this.options, align = _this_options.align, padding = _this_options.labels.padding, rtl = _this_options.rtl;
                var rtlHelper = (0, _helpersSegmentJs.az)(rtl, this.left, this.width);
                if (this.isHorizontal()) {
                    var row = 0;
                    var left = (0, _helpersSegmentJs.a2)(align, this.left + padding, this.right - this.lineWidths[row]);
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = hitboxes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var hitbox = _step.value;
                            if (row !== hitbox.row) {
                                row = hitbox.row;
                                left = (0, _helpersSegmentJs.a2)(align, this.left + padding, this.right - this.lineWidths[row]);
                            }
                            hitbox.top += this.top + titleHeight + padding;
                            hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
                            left += hitbox.width + padding;
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                } else {
                    var col = 0;
                    var top = (0, _helpersSegmentJs.a2)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                    var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                    try {
                        for(var _iterator1 = hitboxes[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                            var hitbox1 = _step1.value;
                            if (hitbox1.col !== col) {
                                col = hitbox1.col;
                                top = (0, _helpersSegmentJs.a2)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                            }
                            hitbox1.top = top;
                            hitbox1.left += this.left + padding;
                            hitbox1.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox1.left), hitbox1.width);
                            top += hitbox1.height + padding;
                        }
                    } catch (err) {
                        _didIteratorError1 = true;
                        _iteratorError1 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                _iterator1.return();
                            }
                        } finally{
                            if (_didIteratorError1) {
                                throw _iteratorError1;
                            }
                        }
                    }
                }
            }
        },
        {
            key: "isHorizontal",
            value: function isHorizontal() {
                return this.options.position === "top" || this.options.position === "bottom";
            }
        },
        {
            key: "draw",
            value: function draw() {
                if (this.options.display) {
                    var ctx = this.ctx;
                    (0, _helpersSegmentJs.Y)(ctx, this);
                    this._draw();
                    (0, _helpersSegmentJs.$)(ctx);
                }
            }
        },
        {
            key: "_draw",
            value: function _draw() {
                var _this = this;
                var _this1 = this, opts = _this1.options, columnSizes = _this1.columnSizes, lineWidths = _this1.lineWidths, ctx = _this1.ctx;
                var align = opts.align, labelOpts = opts.labels;
                var defaultColor = (0, _helpersSegmentJs.d).color;
                var rtlHelper = (0, _helpersSegmentJs.az)(opts.rtl, this.left, this.width);
                var labelFont = (0, _helpersSegmentJs.a0)(labelOpts.font);
                var padding = labelOpts.padding;
                var fontSize = labelFont.size;
                var halfFontSize = fontSize / 2;
                var cursor;
                this.drawTitle();
                ctx.textAlign = rtlHelper.textAlign("left");
                ctx.textBaseline = "middle";
                ctx.lineWidth = 0.5;
                ctx.font = labelFont.string;
                var _getBoxSize = getBoxSize(labelOpts, fontSize), boxWidth = _getBoxSize.boxWidth, boxHeight = _getBoxSize.boxHeight, itemHeight = _getBoxSize.itemHeight;
                var drawLegendBox = function drawLegendBox(x, y, legendItem) {
                    if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) return;
                    ctx.save();
                    var lineWidth = (0, _helpersSegmentJs.v)(legendItem.lineWidth, 1);
                    ctx.fillStyle = (0, _helpersSegmentJs.v)(legendItem.fillStyle, defaultColor);
                    ctx.lineCap = (0, _helpersSegmentJs.v)(legendItem.lineCap, "butt");
                    ctx.lineDashOffset = (0, _helpersSegmentJs.v)(legendItem.lineDashOffset, 0);
                    ctx.lineJoin = (0, _helpersSegmentJs.v)(legendItem.lineJoin, "miter");
                    ctx.lineWidth = lineWidth;
                    ctx.strokeStyle = (0, _helpersSegmentJs.v)(legendItem.strokeStyle, defaultColor);
                    ctx.setLineDash((0, _helpersSegmentJs.v)(legendItem.lineDash, []));
                    if (labelOpts.usePointStyle) {
                        var drawOptions = {
                            radius: boxHeight * Math.SQRT2 / 2,
                            pointStyle: legendItem.pointStyle,
                            rotation: legendItem.rotation,
                            borderWidth: lineWidth
                        };
                        var centerX = rtlHelper.xPlus(x, boxWidth / 2);
                        var centerY = y + halfFontSize;
                        (0, _helpersSegmentJs.aD)(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
                    } else {
                        var yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
                        var xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                        var borderRadius = (0, _helpersSegmentJs.aw)(legendItem.borderRadius);
                        ctx.beginPath();
                        if (Object.values(borderRadius).some(function(v) {
                            return v !== 0;
                        })) (0, _helpersSegmentJs.au)(ctx, {
                            x: xBoxLeft,
                            y: yBoxTop,
                            w: boxWidth,
                            h: boxHeight,
                            radius: borderRadius
                        });
                        else ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                        ctx.fill();
                        if (lineWidth !== 0) ctx.stroke();
                    }
                    ctx.restore();
                };
                var fillText = function fillText(x, y, legendItem) {
                    (0, _helpersSegmentJs.Z)(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
                        strikethrough: legendItem.hidden,
                        textAlign: rtlHelper.textAlign(legendItem.textAlign)
                    });
                };
                var isHorizontal = this.isHorizontal();
                var titleHeight = this._computeTitleHeight();
                if (isHorizontal) cursor = {
                    x: (0, _helpersSegmentJs.a2)(align, this.left + padding, this.right - lineWidths[0]),
                    y: this.top + padding + titleHeight,
                    line: 0
                };
                else cursor = {
                    x: this.left + padding,
                    y: (0, _helpersSegmentJs.a2)(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
                    line: 0
                };
                (0, _helpersSegmentJs.aA)(this.ctx, opts.textDirection);
                var lineHeight = itemHeight + padding;
                this.legendItems.forEach(function(legendItem, i) {
                    ctx.strokeStyle = legendItem.fontColor;
                    ctx.fillStyle = legendItem.fontColor;
                    var textWidth = ctx.measureText(legendItem.text).width;
                    var textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
                    var width = boxWidth + halfFontSize + textWidth;
                    var x = cursor.x;
                    var y = cursor.y;
                    rtlHelper.setWidth(_this.width);
                    if (isHorizontal) {
                        if (i > 0 && x + width + padding > _this.right) {
                            y = cursor.y += lineHeight;
                            cursor.line++;
                            x = cursor.x = (0, _helpersSegmentJs.a2)(align, _this.left + padding, _this.right - lineWidths[cursor.line]);
                        }
                    } else if (i > 0 && y + lineHeight > _this.bottom) {
                        x = cursor.x = x + columnSizes[cursor.line].width + padding;
                        cursor.line++;
                        y = cursor.y = (0, _helpersSegmentJs.a2)(align, _this.top + titleHeight + padding, _this.bottom - columnSizes[cursor.line].height);
                    }
                    var realX = rtlHelper.x(x);
                    drawLegendBox(realX, y, legendItem);
                    x = (0, _helpersSegmentJs.aB)(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : _this.right, opts.rtl);
                    fillText(rtlHelper.x(x), y, legendItem);
                    if (isHorizontal) cursor.x += width + padding;
                    else if (typeof legendItem.text !== "string") {
                        var fontLineHeight = labelFont.lineHeight;
                        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
                    } else cursor.y += lineHeight;
                });
                (0, _helpersSegmentJs.aC)(this.ctx, opts.textDirection);
            }
        },
        {
            key: "drawTitle",
            value: function drawTitle() {
                var opts = this.options;
                var titleOpts = opts.title;
                var titleFont = (0, _helpersSegmentJs.a0)(titleOpts.font);
                var titlePadding = (0, _helpersSegmentJs.E)(titleOpts.padding);
                if (!titleOpts.display) return;
                var rtlHelper = (0, _helpersSegmentJs.az)(opts.rtl, this.left, this.width);
                var ctx = this.ctx;
                var position = titleOpts.position;
                var halfFontSize = titleFont.size / 2;
                var topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
                var y;
                var left = this.left;
                var maxWidth = this.width;
                if (this.isHorizontal()) {
                    var _Math;
                    maxWidth = (_Math = Math).max.apply(_Math, (0, _toConsumableArray._)(this.lineWidths));
                    y = this.top + topPaddingPlusHalfFontSize;
                    left = (0, _helpersSegmentJs.a2)(opts.align, left, this.right - maxWidth);
                } else {
                    var maxHeight = this.columnSizes.reduce(function(acc, size) {
                        return Math.max(acc, size.height);
                    }, 0);
                    y = topPaddingPlusHalfFontSize + (0, _helpersSegmentJs.a2)(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
                }
                var x = (0, _helpersSegmentJs.a2)(position, left, left + maxWidth);
                ctx.textAlign = rtlHelper.textAlign((0, _helpersSegmentJs.a1)(position));
                ctx.textBaseline = "middle";
                ctx.strokeStyle = titleOpts.color;
                ctx.fillStyle = titleOpts.color;
                ctx.font = titleFont.string;
                (0, _helpersSegmentJs.Z)(ctx, titleOpts.text, x, y, titleFont);
            }
        },
        {
            key: "_computeTitleHeight",
            value: function _computeTitleHeight() {
                var titleOpts = this.options.title;
                var titleFont = (0, _helpersSegmentJs.a0)(titleOpts.font);
                var titlePadding = (0, _helpersSegmentJs.E)(titleOpts.padding);
                return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
            }
        },
        {
            key: "_getLegendItemAt",
            value: function _getLegendItemAt(x, y) {
                var i, hitBox, lh;
                if ((0, _helpersSegmentJs.aj)(x, this.left, this.right) && (0, _helpersSegmentJs.aj)(y, this.top, this.bottom)) {
                    lh = this.legendHitBoxes;
                    for(i = 0; i < lh.length; ++i){
                        hitBox = lh[i];
                        if ((0, _helpersSegmentJs.aj)(x, hitBox.left, hitBox.left + hitBox.width) && (0, _helpersSegmentJs.aj)(y, hitBox.top, hitBox.top + hitBox.height)) return this.legendItems[i];
                    }
                }
                return null;
            }
        },
        {
            key: "handleEvent",
            value: function handleEvent(e) {
                var opts = this.options;
                if (!isListened(e.type, opts)) return;
                var hoveredItem = this._getLegendItemAt(e.x, e.y);
                if (e.type === "mousemove" || e.type === "mouseout") {
                    var previous = this._hoveredItem;
                    var sameItem = itemsEqual(previous, hoveredItem);
                    if (previous && !sameItem) (0, _helpersSegmentJs.Q)(opts.onLeave, [
                        e,
                        previous,
                        this
                    ], this);
                    this._hoveredItem = hoveredItem;
                    if (hoveredItem && !sameItem) (0, _helpersSegmentJs.Q)(opts.onHover, [
                        e,
                        hoveredItem,
                        this
                    ], this);
                } else if (hoveredItem) (0, _helpersSegmentJs.Q)(opts.onClick, [
                    e,
                    hoveredItem,
                    this
                ], this);
            }
        }
    ]);
    return Legend;
}((0, _wrapNativeSuper._)(Element));
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
    var itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
    var itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
    return {
        itemWidth: itemWidth,
        itemHeight: itemHeight
    };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
    var legendItemText = legendItem.text;
    if (legendItemText && typeof legendItemText !== "string") legendItemText = legendItemText.reduce(function(a, b) {
        return a.length > b.length ? a : b;
    });
    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
    var itemHeight = _itemHeight;
    if (typeof legendItem.text !== "string") itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
    return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
    var labelHeight = legendItem.text ? legendItem.text.length : 0;
    return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
    if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) return true;
    if (opts.onClick && (type === "click" || type === "mouseup")) return true;
    return false;
}
var plugin_legend = {
    id: "legend",
    _element: Legend,
    start: function(chart, _args, options) {
        var legend = chart.legend = new Legend({
            ctx: chart.ctx,
            options: options,
            chart: chart
        });
        layouts.configure(chart, legend, options);
        layouts.addBox(chart, legend);
    },
    stop: function(chart) {
        layouts.removeBox(chart, chart.legend);
        delete chart.legend;
    },
    beforeUpdate: function(chart, _args, options) {
        var legend = chart.legend;
        layouts.configure(chart, legend, options);
        legend.options = options;
    },
    afterUpdate: function(chart) {
        var legend = chart.legend;
        legend.buildLabels();
        legend.adjustHitBoxes();
    },
    afterEvent: function(chart, args) {
        if (!args.replay) chart.legend.handleEvent(args.event);
    },
    defaults: {
        display: true,
        position: "top",
        align: "center",
        fullSize: true,
        reverse: false,
        weight: 1000,
        onClick: function(e, legendItem, legend) {
            var index = legendItem.datasetIndex;
            var ci = legend.chart;
            if (ci.isDatasetVisible(index)) {
                ci.hide(index);
                legendItem.hidden = true;
            } else {
                ci.show(index);
                legendItem.hidden = false;
            }
        },
        onHover: null,
        onLeave: null,
        labels: {
            color: function(ctx) {
                return ctx.chart.options.color;
            },
            boxWidth: 40,
            padding: 10,
            generateLabels: function(chart) {
                var datasets = chart.data.datasets;
                var _chart_legend_options = chart.legend.options, _chart_legend_options_labels = _chart_legend_options.labels, usePointStyle = _chart_legend_options_labels.usePointStyle, pointStyle = _chart_legend_options_labels.pointStyle, textAlign = _chart_legend_options_labels.textAlign, color = _chart_legend_options_labels.color, useBorderRadius = _chart_legend_options_labels.useBorderRadius, borderRadius = _chart_legend_options_labels.borderRadius;
                return chart._getSortedDatasetMetas().map(function(meta) {
                    var style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
                    var borderWidth = (0, _helpersSegmentJs.E)(style.borderWidth);
                    return {
                        text: datasets[meta.index].label,
                        fillStyle: style.backgroundColor,
                        fontColor: color,
                        hidden: !meta.visible,
                        lineCap: style.borderCapStyle,
                        lineDash: style.borderDash,
                        lineDashOffset: style.borderDashOffset,
                        lineJoin: style.borderJoinStyle,
                        lineWidth: (borderWidth.width + borderWidth.height) / 4,
                        strokeStyle: style.borderColor,
                        pointStyle: pointStyle || style.pointStyle,
                        rotation: style.rotation,
                        textAlign: textAlign || style.textAlign,
                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
                        datasetIndex: meta.index
                    };
                }, this);
            }
        },
        title: {
            color: function(ctx) {
                return ctx.chart.options.color;
            },
            display: false,
            position: "center",
            text: ""
        }
    },
    descriptors: {
        _scriptable: function(name) {
            return !name.startsWith("on");
        },
        labels: {
            _scriptable: function(name) {
                return ![
                    "generateLabels",
                    "filter",
                    "sort"
                ].includes(name);
            }
        }
    }
};
var Title = /*#__PURE__*/ function(Element) {
    "use strict";
    (0, _inherits._)(Title, Element);
    var _super = (0, _createSuper._)(Title);
    function Title(config) {
        (0, _classCallCheck._)(this, Title);
        var _this;
        _this = _super.call(this);
        _this.chart = config.chart;
        _this.options = config.options;
        _this.ctx = config.ctx;
        _this._padding = undefined;
        _this.top = undefined;
        _this.bottom = undefined;
        _this.left = undefined;
        _this.right = undefined;
        _this.width = undefined;
        _this.height = undefined;
        _this.position = undefined;
        _this.weight = undefined;
        _this.fullSize = undefined;
        return _this;
    }
    (0, _createClass._)(Title, [
        {
            key: "update",
            value: function update(maxWidth, maxHeight) {
                var opts = this.options;
                this.left = 0;
                this.top = 0;
                if (!opts.display) {
                    this.width = this.height = this.right = this.bottom = 0;
                    return;
                }
                this.width = this.right = maxWidth;
                this.height = this.bottom = maxHeight;
                var lineCount = (0, _helpersSegmentJs.b)(opts.text) ? opts.text.length : 1;
                this._padding = (0, _helpersSegmentJs.E)(opts.padding);
                var textSize = lineCount * (0, _helpersSegmentJs.a0)(opts.font).lineHeight + this._padding.height;
                if (this.isHorizontal()) this.height = textSize;
                else this.width = textSize;
            }
        },
        {
            key: "isHorizontal",
            value: function isHorizontal() {
                var pos = this.options.position;
                return pos === "top" || pos === "bottom";
            }
        },
        {
            key: "_drawArgs",
            value: function _drawArgs(offset) {
                var _this = this, top = _this.top, left = _this.left, bottom = _this.bottom, right = _this.right, options = _this.options;
                var align = options.align;
                var rotation = 0;
                var maxWidth, titleX, titleY;
                if (this.isHorizontal()) {
                    titleX = (0, _helpersSegmentJs.a2)(align, left, right);
                    titleY = top + offset;
                    maxWidth = right - left;
                } else {
                    if (options.position === "left") {
                        titleX = left + offset;
                        titleY = (0, _helpersSegmentJs.a2)(align, bottom, top);
                        rotation = (0, _helpersSegmentJs.P) * -0.5;
                    } else {
                        titleX = right - offset;
                        titleY = (0, _helpersSegmentJs.a2)(align, top, bottom);
                        rotation = (0, _helpersSegmentJs.P) * 0.5;
                    }
                    maxWidth = bottom - top;
                }
                return {
                    titleX: titleX,
                    titleY: titleY,
                    maxWidth: maxWidth,
                    rotation: rotation
                };
            }
        },
        {
            key: "draw",
            value: function draw() {
                var ctx = this.ctx;
                var opts = this.options;
                if (!opts.display) return;
                var fontOpts = (0, _helpersSegmentJs.a0)(opts.font);
                var lineHeight = fontOpts.lineHeight;
                var offset = lineHeight / 2 + this._padding.top;
                var _this__drawArgs = this._drawArgs(offset), titleX = _this__drawArgs.titleX, titleY = _this__drawArgs.titleY, maxWidth = _this__drawArgs.maxWidth, rotation = _this__drawArgs.rotation;
                (0, _helpersSegmentJs.Z)(ctx, opts.text, 0, 0, fontOpts, {
                    color: opts.color,
                    maxWidth: maxWidth,
                    rotation: rotation,
                    textAlign: (0, _helpersSegmentJs.a1)(opts.align),
                    textBaseline: "middle",
                    translation: [
                        titleX,
                        titleY
                    ]
                });
            }
        }
    ]);
    return Title;
}((0, _wrapNativeSuper._)(Element));
function createTitle(chart, titleOpts) {
    var title = new Title({
        ctx: chart.ctx,
        options: titleOpts,
        chart: chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
}
var plugin_title = {
    id: "title",
    _element: Title,
    start: function(chart, _args, options) {
        createTitle(chart, options);
    },
    stop: function(chart) {
        var titleBlock = chart.titleBlock;
        layouts.removeBox(chart, titleBlock);
        delete chart.titleBlock;
    },
    beforeUpdate: function(chart, _args, options) {
        var title = chart.titleBlock;
        layouts.configure(chart, title, options);
        title.options = options;
    },
    defaults: {
        align: "center",
        display: false,
        font: {
            weight: "bold"
        },
        fullSize: true,
        padding: 10,
        position: "top",
        text: "",
        weight: 2000
    },
    defaultRoutes: {
        color: "color"
    },
    descriptors: {
        _scriptable: true,
        _indexable: false
    }
};
var map = new WeakMap();
var plugin_subtitle = {
    id: "subtitle",
    start: function(chart, _args, options) {
        var title = new Title({
            ctx: chart.ctx,
            options: options,
            chart: chart
        });
        layouts.configure(chart, title, options);
        layouts.addBox(chart, title);
        map.set(chart, title);
    },
    stop: function(chart) {
        layouts.removeBox(chart, map.get(chart));
        map.delete(chart);
    },
    beforeUpdate: function(chart, _args, options) {
        var title = map.get(chart);
        layouts.configure(chart, title, options);
        title.options = options;
    },
    defaults: {
        align: "center",
        display: false,
        font: {
            weight: "normal"
        },
        fullSize: true,
        padding: 0,
        position: "top",
        text: "",
        weight: 1500
    },
    defaultRoutes: {
        color: "color"
    },
    descriptors: {
        _scriptable: true,
        _indexable: false
    }
};
var positioners = {
    average: function(items) {
        if (!items.length) return false;
        var i, len;
        var x = 0;
        var y = 0;
        var count = 0;
        for(i = 0, len = items.length; i < len; ++i){
            var el = items[i].element;
            if (el && el.hasValue()) {
                var pos = el.tooltipPosition();
                x += pos.x;
                y += pos.y;
                ++count;
            }
        }
        return {
            x: x / count,
            y: y / count
        };
    },
    nearest: function(items, eventPosition) {
        if (!items.length) return false;
        var x = eventPosition.x;
        var y = eventPosition.y;
        var minDistance = Number.POSITIVE_INFINITY;
        var i, len, nearestElement;
        for(i = 0, len = items.length; i < len; ++i){
            var el = items[i].element;
            if (el && el.hasValue()) {
                var center = el.getCenterPoint();
                var d = (0, _helpersSegmentJs.aE)(eventPosition, center);
                if (d < minDistance) {
                    minDistance = d;
                    nearestElement = el;
                }
            }
        }
        if (nearestElement) {
            var tp = nearestElement.tooltipPosition();
            x = tp.x;
            y = tp.y;
        }
        return {
            x: x,
            y: y
        };
    }
};
function pushOrConcat(base, toPush) {
    if (toPush) {
        if ((0, _helpersSegmentJs.b)(toPush)) Array.prototype.push.apply(base, toPush);
        else base.push(toPush);
    }
    return base;
}
function splitNewlines(str) {
    if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) return str.split("\n");
    return str;
}
function createTooltipItem(chart, item) {
    var element = item.element, datasetIndex = item.datasetIndex, index = item.index;
    var controller = chart.getDatasetMeta(datasetIndex).controller;
    var _controller_getLabelAndValue = controller.getLabelAndValue(index), label = _controller_getLabelAndValue.label, value = _controller_getLabelAndValue.value;
    return {
        chart: chart,
        label: label,
        parsed: controller.getParsed(index),
        raw: chart.data.datasets[datasetIndex].data[index],
        formattedValue: value,
        dataset: controller.getDataset(),
        dataIndex: index,
        datasetIndex: datasetIndex,
        element: element
    };
}
function getTooltipSize(tooltip, options) {
    var ctx = tooltip.chart.ctx;
    var body = tooltip.body, footer = tooltip.footer, title = tooltip.title;
    var boxWidth = options.boxWidth, boxHeight = options.boxHeight;
    var bodyFont = (0, _helpersSegmentJs.a0)(options.bodyFont);
    var titleFont = (0, _helpersSegmentJs.a0)(options.titleFont);
    var footerFont = (0, _helpersSegmentJs.a0)(options.footerFont);
    var titleLineCount = title.length;
    var footerLineCount = footer.length;
    var bodyLineItemCount = body.length;
    var padding = (0, _helpersSegmentJs.E)(options.padding);
    var height = padding.height;
    var width = 0;
    var combinedBodyLength = body.reduce(function(count, bodyItem) {
        return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
    }, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    if (combinedBodyLength) {
        var bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    var widthPadding = 0;
    var maxLineWidth = function maxLineWidth(line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    (0, _helpersSegmentJs.F)(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    (0, _helpersSegmentJs.F)(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    (0, _helpersSegmentJs.F)(body, function(bodyItem) {
        (0, _helpersSegmentJs.F)(bodyItem.before, maxLineWidth);
        (0, _helpersSegmentJs.F)(bodyItem.lines, maxLineWidth);
        (0, _helpersSegmentJs.F)(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    (0, _helpersSegmentJs.F)(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return {
        width: width,
        height: height
    };
}
function determineYAlign(chart, size) {
    var y = size.y, height = size.height;
    if (y < height / 2) return "top";
    else if (y > chart.height - height / 2) return "bottom";
    return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
    var x = size.x, width = size.width;
    var caret = options.caretSize + options.caretPadding;
    if (xAlign === "left" && x + width + caret > chart.width) return true;
    if (xAlign === "right" && x - width - caret < 0) return true;
}
function determineXAlign(chart, options, size, yAlign) {
    var x = size.x, width = size.width;
    var chartWidth = chart.width, _chart_chartArea = chart.chartArea, left = _chart_chartArea.left, right = _chart_chartArea.right;
    var xAlign = "center";
    if (yAlign === "center") xAlign = x <= (left + right) / 2 ? "left" : "right";
    else if (x <= width / 2) xAlign = "left";
    else if (x >= chartWidth - width / 2) xAlign = "right";
    if (doesNotFitWithAlign(xAlign, chart, options, size)) xAlign = "center";
    return xAlign;
}
function determineAlignment(chart, options, size) {
    var yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
    return {
        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
        yAlign: yAlign
    };
}
function alignX(size, xAlign) {
    var x = size.x, width = size.width;
    if (xAlign === "right") x -= width;
    else if (xAlign === "center") x -= width / 2;
    return x;
}
function alignY(size, yAlign, paddingAndSize) {
    var y = size.y, height = size.height;
    if (yAlign === "top") y += paddingAndSize;
    else if (yAlign === "bottom") y -= height + paddingAndSize;
    else y -= height / 2;
    return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
    var caretSize = options.caretSize, caretPadding = options.caretPadding, cornerRadius = options.cornerRadius;
    var xAlign = alignment.xAlign, yAlign = alignment.yAlign;
    var paddingAndSize = caretSize + caretPadding;
    var _toTRBLCorners = (0, _helpersSegmentJs.aw)(cornerRadius), topLeft = _toTRBLCorners.topLeft, topRight = _toTRBLCorners.topRight, bottomLeft = _toTRBLCorners.bottomLeft, bottomRight = _toTRBLCorners.bottomRight;
    var x = alignX(size, xAlign);
    var y = alignY(size, yAlign, paddingAndSize);
    if (yAlign === "center") {
        if (xAlign === "left") x += paddingAndSize;
        else if (xAlign === "right") x -= paddingAndSize;
    } else if (xAlign === "left") x -= Math.max(topLeft, bottomLeft) + caretSize;
    else if (xAlign === "right") x += Math.max(topRight, bottomRight) + caretSize;
    return {
        x: (0, _helpersSegmentJs.S)(x, 0, chart.width - size.width),
        y: (0, _helpersSegmentJs.S)(y, 0, chart.height - size.height)
    };
}
function getAlignedX(tooltip, align, options) {
    var padding = (0, _helpersSegmentJs.E)(options.padding);
    return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback) {
    return pushOrConcat([], splitNewlines(callback));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
    return (0, _helpersSegmentJs.j)(parent, {
        tooltip: tooltip,
        tooltipItems: tooltipItems,
        type: "tooltip"
    });
}
function overrideCallbacks(callbacks, context) {
    var override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
}
var defaultCallbacks = {
    beforeTitle: (0, _helpersSegmentJs.aF),
    title: function(tooltipItems) {
        if (tooltipItems.length > 0) {
            var item = tooltipItems[0];
            var labels = item.chart.data.labels;
            var labelCount = labels ? labels.length : 0;
            if (this && this.options && this.options.mode === "dataset") return item.dataset.label || "";
            else if (item.label) return item.label;
            else if (labelCount > 0 && item.dataIndex < labelCount) return labels[item.dataIndex];
        }
        return "";
    },
    afterTitle: (0, _helpersSegmentJs.aF),
    beforeBody: (0, _helpersSegmentJs.aF),
    beforeLabel: (0, _helpersSegmentJs.aF),
    label: function(tooltipItem) {
        if (this && this.options && this.options.mode === "dataset") return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
        var label = tooltipItem.dataset.label || "";
        if (label) label += ": ";
        var value = tooltipItem.formattedValue;
        if (!(0, _helpersSegmentJs.k)(value)) label += value;
        return label;
    },
    labelColor: function(tooltipItem) {
        var meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        var options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
            borderColor: options.borderColor,
            backgroundColor: options.backgroundColor,
            borderWidth: options.borderWidth,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderRadius: 0
        };
    },
    labelTextColor: function() {
        return this.options.bodyColor;
    },
    labelPointStyle: function(tooltipItem) {
        var meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        var options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
            pointStyle: options.pointStyle,
            rotation: options.rotation
        };
    },
    afterLabel: (0, _helpersSegmentJs.aF),
    afterBody: (0, _helpersSegmentJs.aF),
    beforeFooter: (0, _helpersSegmentJs.aF),
    footer: (0, _helpersSegmentJs.aF),
    afterFooter: (0, _helpersSegmentJs.aF)
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
    var result = callbacks[name].call(ctx, arg);
    if (typeof result === "undefined") return defaultCallbacks[name].call(ctx, arg);
    return result;
}
var Tooltip = /*#__PURE__*/ function(Element) {
    "use strict";
    (0, _inherits._)(Tooltip, Element);
    var _super = (0, _createSuper._)(Tooltip);
    function Tooltip(config) {
        (0, _classCallCheck._)(this, Tooltip);
        var _this;
        _this = _super.call(this);
        _this.opacity = 0;
        _this._active = [];
        _this._eventPosition = undefined;
        _this._size = undefined;
        _this._cachedAnimations = undefined;
        _this._tooltipItems = [];
        _this.$animations = undefined;
        _this.$context = undefined;
        _this.chart = config.chart;
        _this.options = config.options;
        _this.dataPoints = undefined;
        _this.title = undefined;
        _this.beforeBody = undefined;
        _this.body = undefined;
        _this.afterBody = undefined;
        _this.footer = undefined;
        _this.xAlign = undefined;
        _this.yAlign = undefined;
        _this.x = undefined;
        _this.y = undefined;
        _this.height = undefined;
        _this.width = undefined;
        _this.caretX = undefined;
        _this.caretY = undefined;
        _this.labelColors = undefined;
        _this.labelPointStyles = undefined;
        _this.labelTextColors = undefined;
        return _this;
    }
    (0, _createClass._)(Tooltip, [
        {
            key: "initialize",
            value: function initialize(options) {
                this.options = options;
                this._cachedAnimations = undefined;
                this.$context = undefined;
            }
        },
        {
            key: "_resolveAnimations",
            value: function _resolveAnimations() {
                var cached = this._cachedAnimations;
                if (cached) return cached;
                var chart = this.chart;
                var options = this.options.setContext(this.getContext());
                var opts = options.enabled && chart.options.animation && options.animations;
                var animations = new Animations(this.chart, opts);
                if (opts._cacheable) this._cachedAnimations = Object.freeze(animations);
                return animations;
            }
        },
        {
            key: "getContext",
            value: function getContext() {
                return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
            }
        },
        {
            key: "getTitle",
            value: function getTitle(context, options) {
                var callbacks = options.callbacks;
                var beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
                var title = invokeCallbackWithFallback(callbacks, "title", this, context);
                var afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
                var lines = [];
                lines = pushOrConcat(lines, splitNewlines(beforeTitle));
                lines = pushOrConcat(lines, splitNewlines(title));
                lines = pushOrConcat(lines, splitNewlines(afterTitle));
                return lines;
            }
        },
        {
            key: "getBeforeBody",
            value: function getBeforeBody(tooltipItems, options) {
                return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
            }
        },
        {
            key: "getBody",
            value: function getBody(tooltipItems, options) {
                var _this = this;
                var callbacks = options.callbacks;
                var bodyItems = [];
                (0, _helpersSegmentJs.F)(tooltipItems, function(context) {
                    var bodyItem = {
                        before: [],
                        lines: [],
                        after: []
                    };
                    var scoped = overrideCallbacks(callbacks, context);
                    pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", _this, context)));
                    pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", _this, context));
                    pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", _this, context)));
                    bodyItems.push(bodyItem);
                });
                return bodyItems;
            }
        },
        {
            key: "getAfterBody",
            value: function getAfterBody(tooltipItems, options) {
                return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
            }
        },
        {
            key: "getFooter",
            value: function getFooter(tooltipItems, options) {
                var callbacks = options.callbacks;
                var beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
                var footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
                var afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
                var lines = [];
                lines = pushOrConcat(lines, splitNewlines(beforeFooter));
                lines = pushOrConcat(lines, splitNewlines(footer));
                lines = pushOrConcat(lines, splitNewlines(afterFooter));
                return lines;
            }
        },
        {
            key: "_createItems",
            value: function _createItems(options) {
                var _this = this;
                var active = this._active;
                var data = this.chart.data;
                var labelColors = [];
                var labelPointStyles = [];
                var labelTextColors = [];
                var tooltipItems = [];
                var i, len;
                for(i = 0, len = active.length; i < len; ++i)tooltipItems.push(createTooltipItem(this.chart, active[i]));
                if (options.filter) tooltipItems = tooltipItems.filter(function(element, index, array) {
                    return options.filter(element, index, array, data);
                });
                if (options.itemSort) tooltipItems = tooltipItems.sort(function(a, b) {
                    return options.itemSort(a, b, data);
                });
                (0, _helpersSegmentJs.F)(tooltipItems, function(context) {
                    var scoped = overrideCallbacks(options.callbacks, context);
                    labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", _this, context));
                    labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", _this, context));
                    labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", _this, context));
                });
                this.labelColors = labelColors;
                this.labelPointStyles = labelPointStyles;
                this.labelTextColors = labelTextColors;
                this.dataPoints = tooltipItems;
                return tooltipItems;
            }
        },
        {
            key: "update",
            value: function update(changed, replay) {
                var options = this.options.setContext(this.getContext());
                var active = this._active;
                var properties;
                var tooltipItems = [];
                if (!active.length) {
                    if (this.opacity !== 0) properties = {
                        opacity: 0
                    };
                } else {
                    var position = positioners[options.position].call(this, active, this._eventPosition);
                    tooltipItems = this._createItems(options);
                    this.title = this.getTitle(tooltipItems, options);
                    this.beforeBody = this.getBeforeBody(tooltipItems, options);
                    this.body = this.getBody(tooltipItems, options);
                    this.afterBody = this.getAfterBody(tooltipItems, options);
                    this.footer = this.getFooter(tooltipItems, options);
                    var size = this._size = getTooltipSize(this, options);
                    var positionAndSize = Object.assign({}, position, size);
                    var alignment = determineAlignment(this.chart, options, positionAndSize);
                    var backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
                    this.xAlign = alignment.xAlign;
                    this.yAlign = alignment.yAlign;
                    properties = {
                        opacity: 1,
                        x: backgroundPoint.x,
                        y: backgroundPoint.y,
                        width: size.width,
                        height: size.height,
                        caretX: position.x,
                        caretY: position.y
                    };
                }
                this._tooltipItems = tooltipItems;
                this.$context = undefined;
                if (properties) this._resolveAnimations().update(this, properties);
                if (changed && options.external) options.external.call(this, {
                    chart: this.chart,
                    tooltip: this,
                    replay: replay
                });
            }
        },
        {
            key: "drawCaret",
            value: function drawCaret(tooltipPoint, ctx, size, options) {
                var caretPosition = this.getCaretPosition(tooltipPoint, size, options);
                ctx.lineTo(caretPosition.x1, caretPosition.y1);
                ctx.lineTo(caretPosition.x2, caretPosition.y2);
                ctx.lineTo(caretPosition.x3, caretPosition.y3);
            }
        },
        {
            key: "getCaretPosition",
            value: function getCaretPosition(tooltipPoint, size, options) {
                var _this = this, xAlign = _this.xAlign, yAlign = _this.yAlign;
                var caretSize = options.caretSize, cornerRadius = options.cornerRadius;
                var _toTRBLCorners = (0, _helpersSegmentJs.aw)(cornerRadius), topLeft = _toTRBLCorners.topLeft, topRight = _toTRBLCorners.topRight, bottomLeft = _toTRBLCorners.bottomLeft, bottomRight = _toTRBLCorners.bottomRight;
                var ptX = tooltipPoint.x, ptY = tooltipPoint.y;
                var width = size.width, height = size.height;
                var x1, x2, x3, y1, y2, y3;
                if (yAlign === "center") {
                    y2 = ptY + height / 2;
                    if (xAlign === "left") {
                        x1 = ptX;
                        x2 = x1 - caretSize;
                        y1 = y2 + caretSize;
                        y3 = y2 - caretSize;
                    } else {
                        x1 = ptX + width;
                        x2 = x1 + caretSize;
                        y1 = y2 - caretSize;
                        y3 = y2 + caretSize;
                    }
                    x3 = x1;
                } else {
                    if (xAlign === "left") x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
                    else if (xAlign === "right") x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
                    else x2 = this.caretX;
                    if (yAlign === "top") {
                        y1 = ptY;
                        y2 = y1 - caretSize;
                        x1 = x2 - caretSize;
                        x3 = x2 + caretSize;
                    } else {
                        y1 = ptY + height;
                        y2 = y1 + caretSize;
                        x1 = x2 + caretSize;
                        x3 = x2 - caretSize;
                    }
                    y3 = y1;
                }
                return {
                    x1: x1,
                    x2: x2,
                    x3: x3,
                    y1: y1,
                    y2: y2,
                    y3: y3
                };
            }
        },
        {
            key: "drawTitle",
            value: function drawTitle(pt, ctx, options) {
                var title = this.title;
                var length = title.length;
                var titleFont, titleSpacing, i;
                if (length) {
                    var rtlHelper = (0, _helpersSegmentJs.az)(options.rtl, this.x, this.width);
                    pt.x = getAlignedX(this, options.titleAlign, options);
                    ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
                    ctx.textBaseline = "middle";
                    titleFont = (0, _helpersSegmentJs.a0)(options.titleFont);
                    titleSpacing = options.titleSpacing;
                    ctx.fillStyle = options.titleColor;
                    ctx.font = titleFont.string;
                    for(i = 0; i < length; ++i){
                        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
                        pt.y += titleFont.lineHeight + titleSpacing;
                        if (i + 1 === length) pt.y += options.titleMarginBottom - titleSpacing;
                    }
                }
            }
        },
        {
            key: "_drawColorBox",
            value: function _drawColorBox(ctx, pt, i, rtlHelper, options) {
                var labelColor = this.labelColors[i];
                var labelPointStyle = this.labelPointStyles[i];
                var boxHeight = options.boxHeight, boxWidth = options.boxWidth;
                var bodyFont = (0, _helpersSegmentJs.a0)(options.bodyFont);
                var colorX = getAlignedX(this, "left", options);
                var rtlColorX = rtlHelper.x(colorX);
                var yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
                var colorY = pt.y + yOffSet;
                if (options.usePointStyle) {
                    var drawOptions = {
                        radius: Math.min(boxWidth, boxHeight) / 2,
                        pointStyle: labelPointStyle.pointStyle,
                        rotation: labelPointStyle.rotation,
                        borderWidth: 1
                    };
                    var centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
                    var centerY = colorY + boxHeight / 2;
                    ctx.strokeStyle = options.multiKeyBackground;
                    ctx.fillStyle = options.multiKeyBackground;
                    (0, _helpersSegmentJs.at)(ctx, drawOptions, centerX, centerY);
                    ctx.strokeStyle = labelColor.borderColor;
                    ctx.fillStyle = labelColor.backgroundColor;
                    (0, _helpersSegmentJs.at)(ctx, drawOptions, centerX, centerY);
                } else {
                    var _Math;
                    ctx.lineWidth = (0, _helpersSegmentJs.i)(labelColor.borderWidth) ? (_Math = Math).max.apply(_Math, (0, _toConsumableArray._)(Object.values(labelColor.borderWidth))) : labelColor.borderWidth || 1;
                    ctx.strokeStyle = labelColor.borderColor;
                    ctx.setLineDash(labelColor.borderDash || []);
                    ctx.lineDashOffset = labelColor.borderDashOffset || 0;
                    var outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
                    var innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
                    var borderRadius = (0, _helpersSegmentJs.aw)(labelColor.borderRadius);
                    if (Object.values(borderRadius).some(function(v) {
                        return v !== 0;
                    })) {
                        ctx.beginPath();
                        ctx.fillStyle = options.multiKeyBackground;
                        (0, _helpersSegmentJs.au)(ctx, {
                            x: outerX,
                            y: colorY,
                            w: boxWidth,
                            h: boxHeight,
                            radius: borderRadius
                        });
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = labelColor.backgroundColor;
                        ctx.beginPath();
                        (0, _helpersSegmentJs.au)(ctx, {
                            x: innerX,
                            y: colorY + 1,
                            w: boxWidth - 2,
                            h: boxHeight - 2,
                            radius: borderRadius
                        });
                        ctx.fill();
                    } else {
                        ctx.fillStyle = options.multiKeyBackground;
                        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                        ctx.fillStyle = labelColor.backgroundColor;
                        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
                    }
                }
                ctx.fillStyle = this.labelTextColors[i];
            }
        },
        {
            key: "drawBody",
            value: function drawBody(pt, ctx, options) {
                var body = this.body;
                var bodySpacing = options.bodySpacing, bodyAlign = options.bodyAlign, displayColors = options.displayColors, boxHeight = options.boxHeight, boxWidth = options.boxWidth, boxPadding = options.boxPadding;
                var bodyFont = (0, _helpersSegmentJs.a0)(options.bodyFont);
                var bodyLineHeight = bodyFont.lineHeight;
                var xLinePadding = 0;
                var rtlHelper = (0, _helpersSegmentJs.az)(options.rtl, this.x, this.width);
                var fillLineOfText = function fillLineOfText(line) {
                    ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
                    pt.y += bodyLineHeight + bodySpacing;
                };
                var bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
                var bodyItem, textColor, lines, i, j, ilen, jlen;
                ctx.textAlign = bodyAlign;
                ctx.textBaseline = "middle";
                ctx.font = bodyFont.string;
                pt.x = getAlignedX(this, bodyAlignForCalculation, options);
                ctx.fillStyle = options.bodyColor;
                (0, _helpersSegmentJs.F)(this.beforeBody, fillLineOfText);
                xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
                for(i = 0, ilen = body.length; i < ilen; ++i){
                    bodyItem = body[i];
                    textColor = this.labelTextColors[i];
                    ctx.fillStyle = textColor;
                    (0, _helpersSegmentJs.F)(bodyItem.before, fillLineOfText);
                    lines = bodyItem.lines;
                    if (displayColors && lines.length) {
                        this._drawColorBox(ctx, pt, i, rtlHelper, options);
                        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
                    }
                    for(j = 0, jlen = lines.length; j < jlen; ++j){
                        fillLineOfText(lines[j]);
                        bodyLineHeight = bodyFont.lineHeight;
                    }
                    (0, _helpersSegmentJs.F)(bodyItem.after, fillLineOfText);
                }
                xLinePadding = 0;
                bodyLineHeight = bodyFont.lineHeight;
                (0, _helpersSegmentJs.F)(this.afterBody, fillLineOfText);
                pt.y -= bodySpacing;
            }
        },
        {
            key: "drawFooter",
            value: function drawFooter(pt, ctx, options) {
                var footer = this.footer;
                var length = footer.length;
                var footerFont, i;
                if (length) {
                    var rtlHelper = (0, _helpersSegmentJs.az)(options.rtl, this.x, this.width);
                    pt.x = getAlignedX(this, options.footerAlign, options);
                    pt.y += options.footerMarginTop;
                    ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
                    ctx.textBaseline = "middle";
                    footerFont = (0, _helpersSegmentJs.a0)(options.footerFont);
                    ctx.fillStyle = options.footerColor;
                    ctx.font = footerFont.string;
                    for(i = 0; i < length; ++i){
                        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
                        pt.y += footerFont.lineHeight + options.footerSpacing;
                    }
                }
            }
        },
        {
            key: "drawBackground",
            value: function drawBackground(pt, ctx, tooltipSize, options) {
                var _this = this, xAlign = _this.xAlign, yAlign = _this.yAlign;
                var x = pt.x, y = pt.y;
                var width = tooltipSize.width, height = tooltipSize.height;
                var _toTRBLCorners = (0, _helpersSegmentJs.aw)(options.cornerRadius), topLeft = _toTRBLCorners.topLeft, topRight = _toTRBLCorners.topRight, bottomLeft = _toTRBLCorners.bottomLeft, bottomRight = _toTRBLCorners.bottomRight;
                ctx.fillStyle = options.backgroundColor;
                ctx.strokeStyle = options.borderColor;
                ctx.lineWidth = options.borderWidth;
                ctx.beginPath();
                ctx.moveTo(x + topLeft, y);
                if (yAlign === "top") this.drawCaret(pt, ctx, tooltipSize, options);
                ctx.lineTo(x + width - topRight, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
                if (yAlign === "center" && xAlign === "right") this.drawCaret(pt, ctx, tooltipSize, options);
                ctx.lineTo(x + width, y + height - bottomRight);
                ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
                if (yAlign === "bottom") this.drawCaret(pt, ctx, tooltipSize, options);
                ctx.lineTo(x + bottomLeft, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
                if (yAlign === "center" && xAlign === "left") this.drawCaret(pt, ctx, tooltipSize, options);
                ctx.lineTo(x, y + topLeft);
                ctx.quadraticCurveTo(x, y, x + topLeft, y);
                ctx.closePath();
                ctx.fill();
                if (options.borderWidth > 0) ctx.stroke();
            }
        },
        {
            key: "_updateAnimationTarget",
            value: function _updateAnimationTarget(options) {
                var chart = this.chart;
                var anims = this.$animations;
                var animX = anims && anims.x;
                var animY = anims && anims.y;
                if (animX || animY) {
                    var position = positioners[options.position].call(this, this._active, this._eventPosition);
                    if (!position) return;
                    var size = this._size = getTooltipSize(this, options);
                    var positionAndSize = Object.assign({}, position, this._size);
                    var alignment = determineAlignment(chart, options, positionAndSize);
                    var point = getBackgroundPoint(options, positionAndSize, alignment, chart);
                    if (animX._to !== point.x || animY._to !== point.y) {
                        this.xAlign = alignment.xAlign;
                        this.yAlign = alignment.yAlign;
                        this.width = size.width;
                        this.height = size.height;
                        this.caretX = position.x;
                        this.caretY = position.y;
                        this._resolveAnimations().update(this, point);
                    }
                }
            }
        },
        {
            key: "_willRender",
            value: function _willRender() {
                return !!this.opacity;
            }
        },
        {
            key: "draw",
            value: function draw(ctx) {
                var options = this.options.setContext(this.getContext());
                var opacity = this.opacity;
                if (!opacity) return;
                this._updateAnimationTarget(options);
                var tooltipSize = {
                    width: this.width,
                    height: this.height
                };
                var pt = {
                    x: this.x,
                    y: this.y
                };
                opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
                var padding = (0, _helpersSegmentJs.E)(options.padding);
                var hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
                if (options.enabled && hasTooltipContent) {
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    this.drawBackground(pt, ctx, tooltipSize, options);
                    (0, _helpersSegmentJs.aA)(ctx, options.textDirection);
                    pt.y += padding.top;
                    this.drawTitle(pt, ctx, options);
                    this.drawBody(pt, ctx, options);
                    this.drawFooter(pt, ctx, options);
                    (0, _helpersSegmentJs.aC)(ctx, options.textDirection);
                    ctx.restore();
                }
            }
        },
        {
            key: "getActiveElements",
            value: function getActiveElements() {
                return this._active || [];
            }
        },
        {
            key: "setActiveElements",
            value: function setActiveElements(activeElements, eventPosition) {
                var _this = this;
                var lastActive = this._active;
                var active = activeElements.map(function(param) {
                    var datasetIndex = param.datasetIndex, index = param.index;
                    var meta = _this.chart.getDatasetMeta(datasetIndex);
                    if (!meta) throw new Error("Cannot find a dataset at index " + datasetIndex);
                    return {
                        datasetIndex: datasetIndex,
                        element: meta.data[index],
                        index: index
                    };
                });
                var changed = !(0, _helpersSegmentJs.ah)(lastActive, active);
                var positionChanged = this._positionChanged(active, eventPosition);
                if (changed || positionChanged) {
                    this._active = active;
                    this._eventPosition = eventPosition;
                    this._ignoreReplayEvents = true;
                    this.update(true);
                }
            }
        },
        {
            key: "handleEvent",
            value: function handleEvent(e, replay) {
                var inChartArea = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
                if (replay && this._ignoreReplayEvents) return false;
                this._ignoreReplayEvents = false;
                var options = this.options;
                var lastActive = this._active || [];
                var active = this._getActiveElements(e, lastActive, replay, inChartArea);
                var positionChanged = this._positionChanged(active, e);
                var changed = replay || !(0, _helpersSegmentJs.ah)(active, lastActive) || positionChanged;
                if (changed) {
                    this._active = active;
                    if (options.enabled || options.external) {
                        this._eventPosition = {
                            x: e.x,
                            y: e.y
                        };
                        this.update(true, replay);
                    }
                }
                return changed;
            }
        },
        {
            key: "_getActiveElements",
            value: function _getActiveElements(e, lastActive, replay, inChartArea) {
                var _this = this;
                var options = this.options;
                if (e.type === "mouseout") return [];
                if (!inChartArea) return lastActive.filter(function(i) {
                    return _this.chart.data.datasets[i.datasetIndex] && _this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined;
                });
                var active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
                if (options.reverse) active.reverse();
                return active;
            }
        },
        {
            key: "_positionChanged",
            value: function _positionChanged(active, e) {
                var _this = this, caretX = _this.caretX, caretY = _this.caretY, options = _this.options;
                var position = positioners[options.position].call(this, active, e);
                return position !== false && (caretX !== position.x || caretY !== position.y);
            }
        }
    ]);
    return Tooltip;
}((0, _wrapNativeSuper._)(Element));
(0, _defineProperty._)(Tooltip, "positioners", positioners);
var plugin_tooltip = {
    id: "tooltip",
    _element: Tooltip,
    positioners: positioners,
    afterInit: function(chart, _args, options) {
        if (options) chart.tooltip = new Tooltip({
            chart: chart,
            options: options
        });
    },
    beforeUpdate: function(chart, _args, options) {
        if (chart.tooltip) chart.tooltip.initialize(options);
    },
    reset: function(chart, _args, options) {
        if (chart.tooltip) chart.tooltip.initialize(options);
    },
    afterDraw: function(chart) {
        var tooltip = chart.tooltip;
        if (tooltip && tooltip._willRender()) {
            var args = {
                tooltip: tooltip
            };
            if (chart.notifyPlugins("beforeTooltipDraw", (0, _objectSpreadProps._)((0, _objectSpread._)({}, args), {
                cancelable: true
            })) === false) return;
            tooltip.draw(chart.ctx);
            chart.notifyPlugins("afterTooltipDraw", args);
        }
    },
    afterEvent: function(chart, args) {
        if (chart.tooltip) {
            var useFinalPosition = args.replay;
            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) args.changed = true;
        }
    },
    defaults: {
        enabled: true,
        external: null,
        position: "average",
        backgroundColor: "rgba(0,0,0,0.8)",
        titleColor: "#fff",
        titleFont: {
            weight: "bold"
        },
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleAlign: "left",
        bodyColor: "#fff",
        bodySpacing: 2,
        bodyFont: {},
        bodyAlign: "left",
        footerColor: "#fff",
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFont: {
            weight: "bold"
        },
        footerAlign: "left",
        padding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        boxHeight: function(ctx, opts) {
            return opts.bodyFont.size;
        },
        boxWidth: function(ctx, opts) {
            return opts.bodyFont.size;
        },
        multiKeyBackground: "#fff",
        displayColors: true,
        boxPadding: 0,
        borderColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        animation: {
            duration: 400,
            easing: "easeOutQuart"
        },
        animations: {
            numbers: {
                type: "number",
                properties: [
                    "x",
                    "y",
                    "width",
                    "height",
                    "caretX",
                    "caretY"
                ]
            },
            opacity: {
                easing: "linear",
                duration: 200
            }
        },
        callbacks: defaultCallbacks
    },
    defaultRoutes: {
        bodyFont: "font",
        footerFont: "font",
        titleFont: "font"
    },
    descriptors: {
        _scriptable: function(name) {
            return name !== "filter" && name !== "itemSort" && name !== "external";
        },
        _indexable: false,
        callbacks: {
            _scriptable: false,
            _indexable: false
        },
        animation: {
            _fallback: false
        },
        animations: {
            _fallback: "animation"
        }
    },
    additionalOptionScopes: [
        "interaction"
    ]
};
var plugins = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Colors: plugin_colors,
    Decimation: plugin_decimation,
    Filler: index,
    Legend: plugin_legend,
    SubTitle: plugin_subtitle,
    Title: plugin_title,
    Tooltip: plugin_tooltip
});
var addIfString = function(labels, raw, index, addedLabels) {
    if (typeof raw === "string") {
        index = labels.push(raw) - 1;
        addedLabels.unshift({
            index: index,
            label: raw
        });
    } else if (isNaN(raw)) index = null;
    return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
    var first = labels.indexOf(raw);
    if (first === -1) return addIfString(labels, raw, index, addedLabels);
    var last = labels.lastIndexOf(raw);
    return first !== last ? index : first;
}
var validIndex = function(index, max) {
    return index === null ? null : (0, _helpersSegmentJs.S)(Math.round(index), 0, max);
};
function _getLabelForValue(value) {
    var labels = this.getLabels();
    if (value >= 0 && value < labels.length) return labels[value];
    return value;
}
var CategoryScale = /*#__PURE__*/ function(Scale) {
    "use strict";
    (0, _inherits._)(CategoryScale, Scale);
    var _super = (0, _createSuper._)(CategoryScale);
    function CategoryScale(cfg) {
        (0, _classCallCheck._)(this, CategoryScale);
        var _this;
        _this = _super.call(this, cfg);
        _this._startValue = undefined;
        _this._valueRange = 0;
        _this._addedLabels = [];
        return _this;
    }
    (0, _createClass._)(CategoryScale, [
        {
            key: "init",
            value: function init(scaleOptions) {
                var added = this._addedLabels;
                if (added.length) {
                    var labels = this.getLabels();
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = added[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var _step_value = _step.value, index = _step_value.index, label = _step_value.label;
                            if (labels[index] === label) labels.splice(index, 1);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    this._addedLabels = [];
                }
                (0, _get._)((0, _getPrototypeOf._)(CategoryScale.prototype), "init", this).call(this, scaleOptions);
            }
        },
        {
            key: "parse",
            value: function parse(raw, index) {
                if ((0, _helpersSegmentJs.k)(raw)) return null;
                var labels = this.getLabels();
                index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, (0, _helpersSegmentJs.v)(index, raw), this._addedLabels);
                return validIndex(index, labels.length - 1);
            }
        },
        {
            key: "determineDataLimits",
            value: function determineDataLimits() {
                var _this_getUserBounds = this.getUserBounds(), minDefined = _this_getUserBounds.minDefined, maxDefined = _this_getUserBounds.maxDefined;
                var _this_getMinMax = this.getMinMax(true), min = _this_getMinMax.min, max = _this_getMinMax.max;
                if (this.options.bounds === "ticks") {
                    if (!minDefined) min = 0;
                    if (!maxDefined) max = this.getLabels().length - 1;
                }
                this.min = min;
                this.max = max;
            }
        },
        {
            key: "buildTicks",
            value: function buildTicks() {
                var min = this.min;
                var max = this.max;
                var offset = this.options.offset;
                var ticks = [];
                var labels = this.getLabels();
                labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
                this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
                this._startValue = this.min - (offset ? 0.5 : 0);
                for(var value = min; value <= max; value++)ticks.push({
                    value: value
                });
                return ticks;
            }
        },
        {
            key: "getLabelForValue",
            value: function getLabelForValue(value) {
                return _getLabelForValue.call(this, value);
            }
        },
        {
            key: "configure",
            value: function configure() {
                (0, _get._)((0, _getPrototypeOf._)(CategoryScale.prototype), "configure", this).call(this);
                if (!this.isHorizontal()) this._reversePixels = !this._reversePixels;
            }
        },
        {
            key: "getPixelForValue",
            value: function getPixelForValue(value) {
                if (typeof value !== "number") value = this.parse(value);
                return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
            }
        },
        {
            key: "getPixelForTick",
            value: function getPixelForTick(index) {
                var ticks = this.ticks;
                if (index < 0 || index > ticks.length - 1) return null;
                return this.getPixelForValue(ticks[index].value);
            }
        },
        {
            key: "getValueForPixel",
            value: function getValueForPixel(pixel) {
                return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
            }
        },
        {
            key: "getBasePixel",
            value: function getBasePixel() {
                return this.bottom;
            }
        }
    ]);
    return CategoryScale;
}(Scale);
(0, _defineProperty._)(CategoryScale, "id", "category");
(0, _defineProperty._)(CategoryScale, "defaults", {
    ticks: {
        callback: _getLabelForValue
    }
});
function generateTicks$1(generationOptions, dataRange) {
    var ticks = [];
    var MIN_SPACING = 1e-14;
    var bounds = generationOptions.bounds, step = generationOptions.step, min = generationOptions.min, max = generationOptions.max, precision = generationOptions.precision, count = generationOptions.count, maxTicks = generationOptions.maxTicks, maxDigits = generationOptions.maxDigits, includeBounds = generationOptions.includeBounds;
    var unit = step || 1;
    var maxSpaces = maxTicks - 1;
    var rmin = dataRange.min, rmax = dataRange.max;
    var minDefined = !(0, _helpersSegmentJs.k)(min);
    var maxDefined = !(0, _helpersSegmentJs.k)(max);
    var countDefined = !(0, _helpersSegmentJs.k)(count);
    var minSpacing = (rmax - rmin) / (maxDigits + 1);
    var spacing = (0, _helpersSegmentJs.aH)((rmax - rmin) / maxSpaces / unit) * unit;
    var factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) return [
        {
            value: rmin
        },
        {
            value: rmax
        }
    ];
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) spacing = (0, _helpersSegmentJs.aH)(numSpaces * spacing / maxSpaces / unit) * unit;
    if (!(0, _helpersSegmentJs.k)(precision)) {
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === "ticks") {
        niceMin = Math.floor(rmin / spacing) * spacing;
        niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
        niceMin = rmin;
        niceMax = rmax;
    }
    if (minDefined && maxDefined && step && (0, _helpersSegmentJs.aI)((max - min) / step, spacing / 1000)) {
        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
        spacing = (max - min) / numSpaces;
        niceMin = min;
        niceMax = max;
    } else if (countDefined) {
        niceMin = minDefined ? min : niceMin;
        niceMax = maxDefined ? max : niceMax;
        numSpaces = count - 1;
        spacing = (niceMax - niceMin) / numSpaces;
    } else {
        numSpaces = (niceMax - niceMin) / spacing;
        if ((0, _helpersSegmentJs.aJ)(numSpaces, Math.round(numSpaces), spacing / 1000)) numSpaces = Math.round(numSpaces);
        else numSpaces = Math.ceil(numSpaces);
    }
    var decimalPlaces = Math.max((0, _helpersSegmentJs.aK)(spacing), (0, _helpersSegmentJs.aK)(niceMin));
    factor = Math.pow(10, (0, _helpersSegmentJs.k)(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    var j = 0;
    if (minDefined) {
        if (includeBounds && niceMin !== min) {
            ticks.push({
                value: min
            });
            if (niceMin < min) j++;
            if ((0, _helpersSegmentJs.aJ)(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) j++;
        } else if (niceMin < min) j++;
    }
    for(; j < numSpaces; ++j){
        var tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
        if (maxDefined && tickValue > max) break;
        ticks.push({
            value: tickValue
        });
    }
    if (maxDefined && includeBounds && niceMax !== max) {
        if (ticks.length && (0, _helpersSegmentJs.aJ)(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) ticks[ticks.length - 1].value = max;
        else ticks.push({
            value: max
        });
    } else if (!maxDefined || niceMax === max) ticks.push({
        value: niceMax
    });
    return ticks;
}
function relativeLabelSize(value, minSpacing, param) {
    var horizontal = param.horizontal, minRotation = param.minRotation;
    var rad = (0, _helpersSegmentJs.t)(minRotation);
    var ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
    var length = 0.75 * minSpacing * ("" + value).length;
    return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = /*#__PURE__*/ function(Scale) {
    "use strict";
    (0, _inherits._)(LinearScaleBase, Scale);
    var _super = (0, _createSuper._)(LinearScaleBase);
    function LinearScaleBase(cfg) {
        (0, _classCallCheck._)(this, LinearScaleBase);
        var _this;
        _this = _super.call(this, cfg);
        _this.start = undefined;
        _this.end = undefined;
        _this._startValue = undefined;
        _this._endValue = undefined;
        _this._valueRange = 0;
        return _this;
    }
    (0, _createClass._)(LinearScaleBase, [
        {
            key: "parse",
            value: function parse(raw, index) {
                if ((0, _helpersSegmentJs.k)(raw)) return null;
                if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) return null;
                return +raw;
            }
        },
        {
            key: "handleTickRangeOptions",
            value: function handleTickRangeOptions() {
                var beginAtZero = this.options.beginAtZero;
                var _this_getUserBounds = this.getUserBounds(), minDefined = _this_getUserBounds.minDefined, maxDefined = _this_getUserBounds.maxDefined;
                var _this = this, min = _this.min, max = _this.max;
                var setMin = function(v) {
                    return min = minDefined ? min : v;
                };
                var setMax = function(v) {
                    return max = maxDefined ? max : v;
                };
                if (beginAtZero) {
                    var minSign = (0, _helpersSegmentJs.s)(min);
                    var maxSign = (0, _helpersSegmentJs.s)(max);
                    if (minSign < 0 && maxSign < 0) setMax(0);
                    else if (minSign > 0 && maxSign > 0) setMin(0);
                }
                if (min === max) {
                    var offset = max === 0 ? 1 : Math.abs(max * 0.05);
                    setMax(max + offset);
                    if (!beginAtZero) setMin(min - offset);
                }
                this.min = min;
                this.max = max;
            }
        },
        {
            key: "getTickLimit",
            value: function getTickLimit() {
                var tickOpts = this.options.ticks;
                var maxTicksLimit = tickOpts.maxTicksLimit, stepSize = tickOpts.stepSize;
                var maxTicks;
                if (stepSize) {
                    maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
                    if (maxTicks > 1000) {
                        console.warn("scales.".concat(this.id, ".ticks.stepSize: ").concat(stepSize, " would result generating up to ").concat(maxTicks, " ticks. Limiting to 1000."));
                        maxTicks = 1000;
                    }
                } else {
                    maxTicks = this.computeTickLimit();
                    maxTicksLimit = maxTicksLimit || 11;
                }
                if (maxTicksLimit) maxTicks = Math.min(maxTicksLimit, maxTicks);
                return maxTicks;
            }
        },
        {
            key: "computeTickLimit",
            value: function computeTickLimit() {
                return Number.POSITIVE_INFINITY;
            }
        },
        {
            key: "buildTicks",
            value: function buildTicks() {
                var opts = this.options;
                var tickOpts = opts.ticks;
                var maxTicks = this.getTickLimit();
                maxTicks = Math.max(2, maxTicks);
                var numericGeneratorOptions = {
                    maxTicks: maxTicks,
                    bounds: opts.bounds,
                    min: opts.min,
                    max: opts.max,
                    precision: tickOpts.precision,
                    step: tickOpts.stepSize,
                    count: tickOpts.count,
                    maxDigits: this._maxDigits(),
                    horizontal: this.isHorizontal(),
                    minRotation: tickOpts.minRotation || 0,
                    includeBounds: tickOpts.includeBounds !== false
                };
                var dataRange = this._range || this;
                var ticks = generateTicks$1(numericGeneratorOptions, dataRange);
                if (opts.bounds === "ticks") (0, _helpersSegmentJs.aG)(ticks, this, "value");
                if (opts.reverse) {
                    ticks.reverse();
                    this.start = this.max;
                    this.end = this.min;
                } else {
                    this.start = this.min;
                    this.end = this.max;
                }
                return ticks;
            }
        },
        {
            key: "configure",
            value: function configure() {
                var ticks = this.ticks;
                var start = this.min;
                var end = this.max;
                (0, _get._)((0, _getPrototypeOf._)(LinearScaleBase.prototype), "configure", this).call(this);
                if (this.options.offset && ticks.length) {
                    var offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
                    start -= offset;
                    end += offset;
                }
                this._startValue = start;
                this._endValue = end;
                this._valueRange = end - start;
            }
        },
        {
            key: "getLabelForValue",
            value: function getLabelForValue(value) {
                return (0, _helpersSegmentJs.o)(value, this.chart.options.locale, this.options.ticks.format);
            }
        }
    ]);
    return LinearScaleBase;
}(Scale);
var LinearScale = /*#__PURE__*/ function(LinearScaleBase) {
    "use strict";
    (0, _inherits._)(LinearScale, LinearScaleBase);
    var _super = (0, _createSuper._)(LinearScale);
    function LinearScale() {
        (0, _classCallCheck._)(this, LinearScale);
        return _super.apply(this, arguments);
    }
    (0, _createClass._)(LinearScale, [
        {
            key: "determineDataLimits",
            value: function determineDataLimits() {
                var _this_getMinMax = this.getMinMax(true), min = _this_getMinMax.min, max = _this_getMinMax.max;
                this.min = (0, _helpersSegmentJs.g)(min) ? min : 0;
                this.max = (0, _helpersSegmentJs.g)(max) ? max : 1;
                this.handleTickRangeOptions();
            }
        },
        {
            key: "computeTickLimit",
            value: function computeTickLimit() {
                var horizontal = this.isHorizontal();
                var length = horizontal ? this.width : this.height;
                var minRotation = (0, _helpersSegmentJs.t)(this.options.ticks.minRotation);
                var ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;
                var tickFont = this._resolveTickFontOptions(0);
                return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
            }
        },
        {
            key: "getPixelForValue",
            value: function getPixelForValue(value) {
                return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
            }
        },
        {
            key: "getValueForPixel",
            value: function getValueForPixel(pixel) {
                return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
            }
        }
    ]);
    return LinearScale;
}(LinearScaleBase);
(0, _defineProperty._)(LinearScale, "id", "linear");
(0, _defineProperty._)(LinearScale, "defaults", {
    ticks: {
        callback: (0, _helpersSegmentJs.aL).formatters.numeric
    }
});
var log10Floor = function(v) {
    return Math.floor((0, _helpersSegmentJs.aM)(v));
};
var changeExponent = function(v, m) {
    return Math.pow(10, log10Floor(v) + m);
};
function isMajor(tickVal) {
    var remain = tickVal / Math.pow(10, log10Floor(tickVal));
    return remain === 1;
}
function steps(min, max, rangeExp) {
    var rangeStep = Math.pow(10, rangeExp);
    var start = Math.floor(min / rangeStep);
    var end = Math.ceil(max / rangeStep);
    return end - start;
}
function startExp(min, max) {
    var range = max - min;
    var rangeExp = log10Floor(range);
    while(steps(min, max, rangeExp) > 10)rangeExp++;
    while(steps(min, max, rangeExp) < 10)rangeExp--;
    return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, param) {
    var min = param.min, max = param.max;
    min = (0, _helpersSegmentJs.O)(generationOptions.min, min);
    var ticks = [];
    var minExp = log10Floor(min);
    var exp = startExp(min, max);
    var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    var stepSize = Math.pow(10, exp);
    var base = minExp > exp ? Math.pow(10, minExp) : 0;
    var start = Math.round((min - base) * precision) / precision;
    var offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
    var significand = Math.floor((start - offset) / Math.pow(10, exp));
    var value = (0, _helpersSegmentJs.O)(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
    while(value < max){
        ticks.push({
            value: value,
            major: isMajor(value),
            significand: significand
        });
        if (significand >= 10) significand = significand < 15 ? 15 : 20;
        else significand++;
        if (significand >= 20) {
            exp++;
            significand = 2;
            precision = exp >= 0 ? 1 : precision;
        }
        value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
    }
    var lastTick = (0, _helpersSegmentJs.O)(generationOptions.max, value);
    ticks.push({
        value: lastTick,
        major: isMajor(lastTick),
        significand: significand
    });
    return ticks;
}
var LogarithmicScale = /*#__PURE__*/ function(Scale) {
    "use strict";
    (0, _inherits._)(LogarithmicScale, Scale);
    var _super = (0, _createSuper._)(LogarithmicScale);
    function LogarithmicScale(cfg) {
        (0, _classCallCheck._)(this, LogarithmicScale);
        var _this;
        _this = _super.call(this, cfg);
        _this.start = undefined;
        _this.end = undefined;
        _this._startValue = undefined;
        _this._valueRange = 0;
        return _this;
    }
    (0, _createClass._)(LogarithmicScale, [
        {
            key: "parse",
            value: function parse(raw, index) {
                var value = LinearScaleBase.prototype.parse.apply(this, [
                    raw,
                    index
                ]);
                if (value === 0) {
                    this._zero = true;
                    return undefined;
                }
                return (0, _helpersSegmentJs.g)(value) && value > 0 ? value : null;
            }
        },
        {
            key: "determineDataLimits",
            value: function determineDataLimits() {
                var _this_getMinMax = this.getMinMax(true), min = _this_getMinMax.min, max = _this_getMinMax.max;
                this.min = (0, _helpersSegmentJs.g)(min) ? Math.max(0, min) : null;
                this.max = (0, _helpersSegmentJs.g)(max) ? Math.max(0, max) : null;
                if (this.options.beginAtZero) this._zero = true;
                if (this._zero && this.min !== this._suggestedMin && !(0, _helpersSegmentJs.g)(this._userMin)) this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
                this.handleTickRangeOptions();
            }
        },
        {
            key: "handleTickRangeOptions",
            value: function handleTickRangeOptions() {
                var _this_getUserBounds = this.getUserBounds(), minDefined = _this_getUserBounds.minDefined, maxDefined = _this_getUserBounds.maxDefined;
                var min = this.min;
                var max = this.max;
                var setMin = function(v) {
                    return min = minDefined ? min : v;
                };
                var setMax = function(v) {
                    return max = maxDefined ? max : v;
                };
                if (min === max) {
                    if (min <= 0) {
                        setMin(1);
                        setMax(10);
                    } else {
                        setMin(changeExponent(min, -1));
                        setMax(changeExponent(max, 1));
                    }
                }
                if (min <= 0) setMin(changeExponent(max, -1));
                if (max <= 0) setMax(changeExponent(min, 1));
                this.min = min;
                this.max = max;
            }
        },
        {
            key: "buildTicks",
            value: function buildTicks() {
                var opts = this.options;
                var generationOptions = {
                    min: this._userMin,
                    max: this._userMax
                };
                var ticks = generateTicks(generationOptions, this);
                if (opts.bounds === "ticks") (0, _helpersSegmentJs.aG)(ticks, this, "value");
                if (opts.reverse) {
                    ticks.reverse();
                    this.start = this.max;
                    this.end = this.min;
                } else {
                    this.start = this.min;
                    this.end = this.max;
                }
                return ticks;
            }
        },
        {
            key: "getLabelForValue",
            value: function getLabelForValue(value) {
                return value === undefined ? "0" : (0, _helpersSegmentJs.o)(value, this.chart.options.locale, this.options.ticks.format);
            }
        },
        {
            key: "configure",
            value: function configure() {
                var start = this.min;
                (0, _get._)((0, _getPrototypeOf._)(LogarithmicScale.prototype), "configure", this).call(this);
                this._startValue = (0, _helpersSegmentJs.aM)(start);
                this._valueRange = (0, _helpersSegmentJs.aM)(this.max) - (0, _helpersSegmentJs.aM)(start);
            }
        },
        {
            key: "getPixelForValue",
            value: function getPixelForValue(value) {
                if (value === undefined || value === 0) value = this.min;
                if (value === null || isNaN(value)) return NaN;
                return this.getPixelForDecimal(value === this.min ? 0 : ((0, _helpersSegmentJs.aM)(value) - this._startValue) / this._valueRange);
            }
        },
        {
            key: "getValueForPixel",
            value: function getValueForPixel(pixel) {
                var decimal = this.getDecimalForPixel(pixel);
                return Math.pow(10, this._startValue + decimal * this._valueRange);
            }
        }
    ]);
    return LogarithmicScale;
}(Scale);
(0, _defineProperty._)(LogarithmicScale, "id", "logarithmic");
(0, _defineProperty._)(LogarithmicScale, "defaults", {
    ticks: {
        callback: (0, _helpersSegmentJs.aL).formatters.logarithmic,
        major: {
            enabled: true
        }
    }
});
function getTickBackdropHeight(opts) {
    var tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
        var padding = (0, _helpersSegmentJs.E)(tickOpts.backdropPadding);
        return (0, _helpersSegmentJs.v)(tickOpts.font && tickOpts.font.size, (0, _helpersSegmentJs.d).font.size) + padding.height;
    }
    return 0;
}
function measureLabelSize(ctx, font, label) {
    label = (0, _helpersSegmentJs.b)(label) ? label : [
        label
    ];
    return {
        w: (0, _helpersSegmentJs.aN)(ctx, font.string, label),
        h: label.length * font.lineHeight
    };
}
function determineLimits(angle, pos, size, min, max) {
    if (angle === min || angle === max) return {
        start: pos - size / 2,
        end: pos + size / 2
    };
    else if (angle < min || angle > max) return {
        start: pos - size,
        end: pos
    };
    return {
        start: pos,
        end: pos + size
    };
}
function fitWithPointLabels(scale) {
    var orig = {
        l: scale.left + scale._padding.left,
        r: scale.right - scale._padding.right,
        t: scale.top + scale._padding.top,
        b: scale.bottom - scale._padding.bottom
    };
    var limits = Object.assign({}, orig);
    var labelSizes = [];
    var padding = [];
    var valueCount = scale._pointLabels.length;
    var pointLabelOpts = scale.options.pointLabels;
    var additionalAngle = pointLabelOpts.centerPointLabels ? (0, _helpersSegmentJs.P) / valueCount : 0;
    for(var i = 0; i < valueCount; i++){
        var opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
        padding[i] = opts.padding;
        var pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
        var plFont = (0, _helpersSegmentJs.a0)(opts.font);
        var textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
        labelSizes[i] = textSize;
        var angleRadians = (0, _helpersSegmentJs.ay)(scale.getIndexAngle(i) + additionalAngle);
        var angle = Math.round((0, _helpersSegmentJs.U)(angleRadians));
        var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
        var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
        updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
    var sin = Math.abs(Math.sin(angle));
    var cos = Math.abs(Math.cos(angle));
    var x = 0;
    var y = 0;
    if (hLimits.start < orig.l) {
        x = (orig.l - hLimits.start) / sin;
        limits.l = Math.min(limits.l, orig.l - x);
    } else if (hLimits.end > orig.r) {
        x = (hLimits.end - orig.r) / sin;
        limits.r = Math.max(limits.r, orig.r + x);
    }
    if (vLimits.start < orig.t) {
        y = (orig.t - vLimits.start) / cos;
        limits.t = Math.min(limits.t, orig.t - y);
    } else if (vLimits.end > orig.b) {
        y = (vLimits.end - orig.b) / cos;
        limits.b = Math.max(limits.b, orig.b + y);
    }
}
function createPointLabelItem(scale, index, itemOpts) {
    var outerDistance = scale.drawingArea;
    var extra = itemOpts.extra, additionalAngle = itemOpts.additionalAngle, padding = itemOpts.padding, size = itemOpts.size;
    var pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);
    var angle = Math.round((0, _helpersSegmentJs.U)((0, _helpersSegmentJs.ay)(pointLabelPosition.angle + (0, _helpersSegmentJs.H))));
    var y = yForAngle(pointLabelPosition.y, size.h, angle);
    var textAlign = getTextAlignForAngle(angle);
    var left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    return {
        visible: true,
        x: pointLabelPosition.x,
        y: y,
        textAlign: textAlign,
        left: left,
        top: y,
        right: left + size.w,
        bottom: y + size.h
    };
}
function isNotOverlapped(item, area) {
    if (!area) return true;
    var left = item.left, top = item.top, right = item.right, bottom = item.bottom;
    var apexesInArea = (0, _helpersSegmentJs.C)({
        x: left,
        y: top
    }, area) || (0, _helpersSegmentJs.C)({
        x: left,
        y: bottom
    }, area) || (0, _helpersSegmentJs.C)({
        x: right,
        y: top
    }, area) || (0, _helpersSegmentJs.C)({
        x: right,
        y: bottom
    }, area);
    return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
    var items = [];
    var valueCount = scale._pointLabels.length;
    var opts = scale.options;
    var _opts_pointLabels = opts.pointLabels, centerPointLabels = _opts_pointLabels.centerPointLabels, display = _opts_pointLabels.display;
    var itemOpts = {
        extra: getTickBackdropHeight(opts) / 2,
        additionalAngle: centerPointLabels ? (0, _helpersSegmentJs.P) / valueCount : 0
    };
    var area;
    for(var i = 0; i < valueCount; i++){
        itemOpts.padding = padding[i];
        itemOpts.size = labelSizes[i];
        var item = createPointLabelItem(scale, i, itemOpts);
        items.push(item);
        if (display === "auto") {
            item.visible = isNotOverlapped(item, area);
            if (item.visible) area = item;
        }
    }
    return items;
}
function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) return "center";
    else if (angle < 180) return "left";
    return "right";
}
function leftForTextAlign(x, w, align) {
    if (align === "right") x -= w;
    else if (align === "center") x -= w / 2;
    return x;
}
function yForAngle(y, h, angle) {
    if (angle === 90 || angle === 270) y -= h / 2;
    else if (angle > 270 || angle < 90) y -= h;
    return y;
}
function drawPointLabelBox(ctx, opts, item) {
    var left = item.left, top = item.top, right = item.right, bottom = item.bottom;
    var backdropColor = opts.backdropColor;
    if (!(0, _helpersSegmentJs.k)(backdropColor)) {
        var borderRadius = (0, _helpersSegmentJs.aw)(opts.borderRadius);
        var padding = (0, _helpersSegmentJs.E)(opts.backdropPadding);
        ctx.fillStyle = backdropColor;
        var backdropLeft = left - padding.left;
        var backdropTop = top - padding.top;
        var backdropWidth = right - left + padding.width;
        var backdropHeight = bottom - top + padding.height;
        if (Object.values(borderRadius).some(function(v) {
            return v !== 0;
        })) {
            ctx.beginPath();
            (0, _helpersSegmentJs.au)(ctx, {
                x: backdropLeft,
                y: backdropTop,
                w: backdropWidth,
                h: backdropHeight,
                radius: borderRadius
            });
            ctx.fill();
        } else ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
}
function drawPointLabels(scale, labelCount) {
    var ctx = scale.ctx, pointLabels = scale.options.pointLabels;
    for(var i = labelCount - 1; i >= 0; i--){
        var item = scale._pointLabelItems[i];
        if (!item.visible) continue;
        var optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
        drawPointLabelBox(ctx, optsAtIndex, item);
        var plFont = (0, _helpersSegmentJs.a0)(optsAtIndex.font);
        var x = item.x, y = item.y, textAlign = item.textAlign;
        (0, _helpersSegmentJs.Z)(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
            color: optsAtIndex.color,
            textAlign: textAlign,
            textBaseline: "middle"
        });
    }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
    var ctx = scale.ctx;
    if (circular) ctx.arc(scale.xCenter, scale.yCenter, radius, 0, (0, _helpersSegmentJs.T));
    else {
        var pointPosition = scale.getPointPosition(0, radius);
        ctx.moveTo(pointPosition.x, pointPosition.y);
        for(var i = 1; i < labelCount; i++){
            pointPosition = scale.getPointPosition(i, radius);
            ctx.lineTo(pointPosition.x, pointPosition.y);
        }
    }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
    var ctx = scale.ctx;
    var circular = gridLineOpts.circular;
    var color = gridLineOpts.color, lineWidth = gridLineOpts.lineWidth;
    if (!circular && !labelCount || !color || !lineWidth || radius < 0) return;
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(borderOpts.dash);
    ctx.lineDashOffset = borderOpts.dashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
}
function createPointLabelContext(parent, index, label) {
    return (0, _helpersSegmentJs.j)(parent, {
        label: label,
        index: index,
        type: "pointLabel"
    });
}
var RadialLinearScale = /*#__PURE__*/ function(LinearScaleBase1) {
    "use strict";
    (0, _inherits._)(RadialLinearScale, LinearScaleBase1);
    var _super = (0, _createSuper._)(RadialLinearScale);
    function RadialLinearScale(cfg) {
        (0, _classCallCheck._)(this, RadialLinearScale);
        var _this;
        _this = _super.call(this, cfg);
        _this.xCenter = undefined;
        _this.yCenter = undefined;
        _this.drawingArea = undefined;
        _this._pointLabels = [];
        _this._pointLabelItems = [];
        return _this;
    }
    (0, _createClass._)(RadialLinearScale, [
        {
            key: "setDimensions",
            value: function setDimensions() {
                var padding = this._padding = (0, _helpersSegmentJs.E)(getTickBackdropHeight(this.options) / 2);
                var w = this.width = this.maxWidth - padding.width;
                var h = this.height = this.maxHeight - padding.height;
                this.xCenter = Math.floor(this.left + w / 2 + padding.left);
                this.yCenter = Math.floor(this.top + h / 2 + padding.top);
                this.drawingArea = Math.floor(Math.min(w, h) / 2);
            }
        },
        {
            key: "determineDataLimits",
            value: function determineDataLimits() {
                var _this_getMinMax = this.getMinMax(false), min = _this_getMinMax.min, max = _this_getMinMax.max;
                this.min = (0, _helpersSegmentJs.g)(min) && !isNaN(min) ? min : 0;
                this.max = (0, _helpersSegmentJs.g)(max) && !isNaN(max) ? max : 0;
                this.handleTickRangeOptions();
            }
        },
        {
            key: "computeTickLimit",
            value: function computeTickLimit() {
                return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
            }
        },
        {
            key: "generateTickLabels",
            value: function generateTickLabels(ticks) {
                var _this = this;
                LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
                this._pointLabels = this.getLabels().map(function(value, index) {
                    var label = (0, _helpersSegmentJs.Q)(_this.options.pointLabels.callback, [
                        value,
                        index
                    ], _this);
                    return label || label === 0 ? label : "";
                }).filter(function(v, i) {
                    return _this.chart.getDataVisibility(i);
                });
            }
        },
        {
            key: "fit",
            value: function fit() {
                var opts = this.options;
                if (opts.display && opts.pointLabels.display) fitWithPointLabels(this);
                else this.setCenterPoint(0, 0, 0, 0);
            }
        },
        {
            key: "setCenterPoint",
            value: function setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
                this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
                this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
                this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
            }
        },
        {
            key: "getIndexAngle",
            value: function getIndexAngle(index) {
                var angleMultiplier = (0, _helpersSegmentJs.T) / (this._pointLabels.length || 1);
                var startAngle = this.options.startAngle || 0;
                return (0, _helpersSegmentJs.ay)(index * angleMultiplier + (0, _helpersSegmentJs.t)(startAngle));
            }
        },
        {
            key: "getDistanceFromCenterForValue",
            value: function getDistanceFromCenterForValue(value) {
                if ((0, _helpersSegmentJs.k)(value)) return NaN;
                var scalingFactor = this.drawingArea / (this.max - this.min);
                if (this.options.reverse) return (this.max - value) * scalingFactor;
                return (value - this.min) * scalingFactor;
            }
        },
        {
            key: "getValueForDistanceFromCenter",
            value: function getValueForDistanceFromCenter(distance) {
                if ((0, _helpersSegmentJs.k)(distance)) return NaN;
                var scaledDistance = distance / (this.drawingArea / (this.max - this.min));
                return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
            }
        },
        {
            key: "getPointLabelContext",
            value: function getPointLabelContext(index) {
                var pointLabels = this._pointLabels || [];
                if (index >= 0 && index < pointLabels.length) {
                    var pointLabel = pointLabels[index];
                    return createPointLabelContext(this.getContext(), index, pointLabel);
                }
            }
        },
        {
            key: "getPointPosition",
            value: function getPointPosition(index, distanceFromCenter) {
                var additionalAngle = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                var angle = this.getIndexAngle(index) - (0, _helpersSegmentJs.H) + additionalAngle;
                return {
                    x: Math.cos(angle) * distanceFromCenter + this.xCenter,
                    y: Math.sin(angle) * distanceFromCenter + this.yCenter,
                    angle: angle
                };
            }
        },
        {
            key: "getPointPositionForValue",
            value: function getPointPositionForValue(index, value) {
                return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
            }
        },
        {
            key: "getBasePosition",
            value: function getBasePosition(index) {
                return this.getPointPositionForValue(index || 0, this.getBaseValue());
            }
        },
        {
            key: "getPointLabelPosition",
            value: function getPointLabelPosition(index) {
                var _this__pointLabelItems_index = this._pointLabelItems[index], left = _this__pointLabelItems_index.left, top = _this__pointLabelItems_index.top, right = _this__pointLabelItems_index.right, bottom = _this__pointLabelItems_index.bottom;
                return {
                    left: left,
                    top: top,
                    right: right,
                    bottom: bottom
                };
            }
        },
        {
            key: "drawBackground",
            value: function drawBackground() {
                var _this_options = this.options, backgroundColor = _this_options.backgroundColor, circular = _this_options.grid.circular;
                if (backgroundColor) {
                    var ctx = this.ctx;
                    ctx.save();
                    ctx.beginPath();
                    pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
                    ctx.closePath();
                    ctx.fillStyle = backgroundColor;
                    ctx.fill();
                    ctx.restore();
                }
            }
        },
        {
            key: "drawGrid",
            value: function drawGrid() {
                var _this = this;
                var ctx = this.ctx;
                var opts = this.options;
                var angleLines = opts.angleLines, grid = opts.grid, border = opts.border;
                var labelCount = this._pointLabels.length;
                var i, offset, position;
                if (opts.pointLabels.display) drawPointLabels(this, labelCount);
                if (grid.display) this.ticks.forEach(function(tick, index) {
                    if (index !== 0) {
                        offset = _this.getDistanceFromCenterForValue(tick.value);
                        var context = _this.getContext(index);
                        var optsAtIndex = grid.setContext(context);
                        var optsAtIndexBorder = border.setContext(context);
                        drawRadiusLine(_this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
                    }
                });
                if (angleLines.display) {
                    ctx.save();
                    for(i = labelCount - 1; i >= 0; i--){
                        var optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
                        var color = optsAtIndex.color, lineWidth = optsAtIndex.lineWidth;
                        if (!lineWidth || !color) continue;
                        ctx.lineWidth = lineWidth;
                        ctx.strokeStyle = color;
                        ctx.setLineDash(optsAtIndex.borderDash);
                        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
                        position = this.getPointPosition(i, offset);
                        ctx.beginPath();
                        ctx.moveTo(this.xCenter, this.yCenter);
                        ctx.lineTo(position.x, position.y);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }
        },
        {
            key: "drawBorder",
            value: function drawBorder() {}
        },
        {
            key: "drawLabels",
            value: function drawLabels() {
                var _this = this;
                var ctx = this.ctx;
                var opts = this.options;
                var tickOpts = opts.ticks;
                if (!tickOpts.display) return;
                var startAngle = this.getIndexAngle(0);
                var offset, width;
                ctx.save();
                ctx.translate(this.xCenter, this.yCenter);
                ctx.rotate(startAngle);
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                this.ticks.forEach(function(tick, index) {
                    if (index === 0 && !opts.reverse) return;
                    var optsAtIndex = tickOpts.setContext(_this.getContext(index));
                    var tickFont = (0, _helpersSegmentJs.a0)(optsAtIndex.font);
                    offset = _this.getDistanceFromCenterForValue(_this.ticks[index].value);
                    if (optsAtIndex.showLabelBackdrop) {
                        ctx.font = tickFont.string;
                        width = ctx.measureText(tick.label).width;
                        ctx.fillStyle = optsAtIndex.backdropColor;
                        var padding = (0, _helpersSegmentJs.E)(optsAtIndex.backdropPadding);
                        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
                    }
                    (0, _helpersSegmentJs.Z)(ctx, tick.label, 0, -offset, tickFont, {
                        color: optsAtIndex.color,
                        strokeColor: optsAtIndex.textStrokeColor,
                        strokeWidth: optsAtIndex.textStrokeWidth
                    });
                });
                ctx.restore();
            }
        },
        {
            key: "drawTitle",
            value: function drawTitle() {}
        }
    ]);
    return RadialLinearScale;
}(LinearScaleBase);
(0, _defineProperty._)(RadialLinearScale, "id", "radialLinear");
(0, _defineProperty._)(RadialLinearScale, "defaults", {
    display: true,
    animate: true,
    position: "chartArea",
    angleLines: {
        display: true,
        lineWidth: 1,
        borderDash: [],
        borderDashOffset: 0.0
    },
    grid: {
        circular: false
    },
    startAngle: 0,
    ticks: {
        showLabelBackdrop: true,
        callback: (0, _helpersSegmentJs.aL).formatters.numeric
    },
    pointLabels: {
        backdropColor: undefined,
        backdropPadding: 2,
        display: true,
        font: {
            size: 10
        },
        callback: function(label) {
            return label;
        },
        padding: 5,
        centerPointLabels: false
    }
});
(0, _defineProperty._)(RadialLinearScale, "defaultRoutes", {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
});
(0, _defineProperty._)(RadialLinearScale, "descriptors", {
    angleLines: {
        _fallback: "grid"
    }
});
var INTERVALS = {
    millisecond: {
        common: true,
        size: 1,
        steps: 1000
    },
    second: {
        common: true,
        size: 1000,
        steps: 60
    },
    minute: {
        common: true,
        size: 60000,
        steps: 60
    },
    hour: {
        common: true,
        size: 3600000,
        steps: 24
    },
    day: {
        common: true,
        size: 86400000,
        steps: 30
    },
    week: {
        common: false,
        size: 604800000,
        steps: 4
    },
    month: {
        common: true,
        size: 2.628e9,
        steps: 12
    },
    quarter: {
        common: false,
        size: 7.884e9,
        steps: 4
    },
    year: {
        common: true,
        size: 3.154e10
    }
};
var UNITS = /* #__PURE__ */ Object.keys(INTERVALS);
function sorter(a, b) {
    return a - b;
}
function parse(scale, input) {
    if ((0, _helpersSegmentJs.k)(input)) return null;
    var adapter = scale._adapter;
    var _scale__parseOpts = scale._parseOpts, parser = _scale__parseOpts.parser, round = _scale__parseOpts.round, isoWeekday = _scale__parseOpts.isoWeekday;
    var value = input;
    if (typeof parser === "function") value = parser(value);
    if (!(0, _helpersSegmentJs.g)(value)) value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
    if (value === null) return null;
    if (round) value = round === "week" && ((0, _helpersSegmentJs.x)(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round);
    return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
    var ilen = UNITS.length;
    for(var i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){
        var interval = INTERVALS[UNITS[i]];
        var factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) return UNITS[i];
    }
    return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
    for(var i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){
        var unit = UNITS[i];
        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) return unit;
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
    for(var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){
        if (INTERVALS[UNITS[i]].common) return UNITS[i];
    }
}
function addTick(ticks, time, timestamps) {
    if (!timestamps) ticks[time] = true;
    else if (timestamps.length) {
        var _$_lookup = (0, _helpersSegmentJs.aP)(timestamps, time), lo = _$_lookup.lo, hi = _$_lookup.hi;
        var timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
        ticks[timestamp] = true;
    }
}
function setMajorTicks(scale, ticks, map, majorUnit) {
    var adapter = scale._adapter;
    var first = +adapter.startOf(ticks[0].value, majorUnit);
    var last = ticks[ticks.length - 1].value;
    var major, index;
    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){
        index = map[major];
        if (index >= 0) ticks[index].major = true;
    }
    return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
    var ticks = [];
    var map = {};
    var ilen = values.length;
    var i, value;
    for(i = 0; i < ilen; ++i){
        value = values[i];
        map[value] = i;
        ticks.push({
            value: value,
            major: false
        });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
}
var TimeScale = /*#__PURE__*/ function(Scale) {
    "use strict";
    (0, _inherits._)(TimeScale, Scale);
    var _super = (0, _createSuper._)(TimeScale);
    function TimeScale(props) {
        (0, _classCallCheck._)(this, TimeScale);
        var _this;
        _this = _super.call(this, props);
        _this._cache = {
            data: [],
            labels: [],
            all: []
        };
        _this._unit = "day";
        _this._majorUnit = undefined;
        _this._offsets = {};
        _this._normalized = false;
        _this._parseOpts = undefined;
        return _this;
    }
    (0, _createClass._)(TimeScale, [
        {
            key: "init",
            value: function init(scaleOpts) {
                var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var time = scaleOpts.time || (scaleOpts.time = {});
                var adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
                adapter.init(opts);
                (0, _helpersSegmentJs.ab)(time.displayFormats, adapter.formats());
                this._parseOpts = {
                    parser: time.parser,
                    round: time.round,
                    isoWeekday: time.isoWeekday
                };
                (0, _get._)((0, _getPrototypeOf._)(TimeScale.prototype), "init", this).call(this, scaleOpts);
                this._normalized = opts.normalized;
            }
        },
        {
            key: "parse",
            value: function parse1(raw, index) {
                if (raw === undefined) return null;
                return parse(this, raw);
            }
        },
        {
            key: "beforeLayout",
            value: function beforeLayout() {
                (0, _get._)((0, _getPrototypeOf._)(TimeScale.prototype), "beforeLayout", this).call(this);
                this._cache = {
                    data: [],
                    labels: [],
                    all: []
                };
            }
        },
        {
            key: "determineDataLimits",
            value: function determineDataLimits() {
                var options = this.options;
                var adapter = this._adapter;
                var unit = options.time.unit || "day";
                var _this_getUserBounds = this.getUserBounds(), min = _this_getUserBounds.min, max = _this_getUserBounds.max, minDefined = _this_getUserBounds.minDefined, maxDefined = _this_getUserBounds.maxDefined;
                function _applyBounds(bounds) {
                    if (!minDefined && !isNaN(bounds.min)) min = Math.min(min, bounds.min);
                    if (!maxDefined && !isNaN(bounds.max)) max = Math.max(max, bounds.max);
                }
                if (!minDefined || !maxDefined) {
                    _applyBounds(this._getLabelBounds());
                    if (options.bounds !== "ticks" || options.ticks.source !== "labels") _applyBounds(this.getMinMax(false));
                }
                min = (0, _helpersSegmentJs.g)(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
                max = (0, _helpersSegmentJs.g)(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
                this.min = Math.min(min, max - 1);
                this.max = Math.max(min + 1, max);
            }
        },
        {
            key: "_getLabelBounds",
            value: function _getLabelBounds() {
                var arr = this.getLabelTimestamps();
                var min = Number.POSITIVE_INFINITY;
                var max = Number.NEGATIVE_INFINITY;
                if (arr.length) {
                    min = arr[0];
                    max = arr[arr.length - 1];
                }
                return {
                    min: min,
                    max: max
                };
            }
        },
        {
            key: "buildTicks",
            value: function buildTicks() {
                var options = this.options;
                var timeOpts = options.time;
                var tickOpts = options.ticks;
                var timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
                if (options.bounds === "ticks" && timestamps.length) {
                    this.min = this._userMin || timestamps[0];
                    this.max = this._userMax || timestamps[timestamps.length - 1];
                }
                var min = this.min;
                var max = this.max;
                var ticks = (0, _helpersSegmentJs.aO)(timestamps, min, max);
                this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
                this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? undefined : determineMajorUnit(this._unit);
                this.initOffsets(timestamps);
                if (options.reverse) ticks.reverse();
                return ticksFromTimestamps(this, ticks, this._majorUnit);
            }
        },
        {
            key: "afterAutoSkip",
            value: function afterAutoSkip() {
                if (this.options.offsetAfterAutoskip) this.initOffsets(this.ticks.map(function(tick) {
                    return +tick.value;
                }));
            }
        },
        {
            key: "initOffsets",
            value: function initOffsets() {
                var timestamps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                var start = 0;
                var end = 0;
                var first, last;
                if (this.options.offset && timestamps.length) {
                    first = this.getDecimalForValue(timestamps[0]);
                    if (timestamps.length === 1) start = 1 - first;
                    else start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
                    last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
                    if (timestamps.length === 1) end = last;
                    else end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
                }
                var limit = timestamps.length < 3 ? 0.5 : 0.25;
                start = (0, _helpersSegmentJs.S)(start, 0, limit);
                end = (0, _helpersSegmentJs.S)(end, 0, limit);
                this._offsets = {
                    start: start,
                    end: end,
                    factor: 1 / (start + 1 + end)
                };
            }
        },
        {
            key: "_generate",
            value: function _generate() {
                var adapter = this._adapter;
                var min = this.min;
                var max = this.max;
                var options = this.options;
                var timeOpts = options.time;
                var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
                var stepSize = (0, _helpersSegmentJs.v)(options.ticks.stepSize, 1);
                var weekday = minor === "week" ? timeOpts.isoWeekday : false;
                var hasWeekday = (0, _helpersSegmentJs.x)(weekday) || weekday === true;
                var ticks = {};
                var first = min;
                var time, count;
                if (hasWeekday) first = +adapter.startOf(first, "isoWeek", weekday);
                first = +adapter.startOf(first, hasWeekday ? "day" : minor);
                if (adapter.diff(max, min, minor) > 100000 * stepSize) throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
                var timestamps = options.ticks.source === "data" && this.getDataTimestamps();
                for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++)addTick(ticks, time, timestamps);
                if (time === max || options.bounds === "ticks" || count === 1) addTick(ticks, time, timestamps);
                return Object.keys(ticks).sort(sorter).map(function(x) {
                    return +x;
                });
            }
        },
        {
            key: "getLabelForValue",
            value: function getLabelForValue(value) {
                var adapter = this._adapter;
                var timeOpts = this.options.time;
                if (timeOpts.tooltipFormat) return adapter.format(value, timeOpts.tooltipFormat);
                return adapter.format(value, timeOpts.displayFormats.datetime);
            }
        },
        {
            key: "format",
            value: function format(value, format) {
                var options = this.options;
                var formats = options.time.displayFormats;
                var unit = this._unit;
                var fmt = format || formats[unit];
                return this._adapter.format(value, fmt);
            }
        },
        {
            key: "_tickFormatFunction",
            value: function _tickFormatFunction(time, index, ticks, format) {
                var options = this.options;
                var formatter = options.ticks.callback;
                if (formatter) return (0, _helpersSegmentJs.Q)(formatter, [
                    time,
                    index,
                    ticks
                ], this);
                var formats = options.time.displayFormats;
                var unit = this._unit;
                var majorUnit = this._majorUnit;
                var minorFormat = unit && formats[unit];
                var majorFormat = majorUnit && formats[majorUnit];
                var tick = ticks[index];
                var major = majorUnit && majorFormat && tick && tick.major;
                return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
            }
        },
        {
            key: "generateTickLabels",
            value: function generateTickLabels(ticks) {
                var i, ilen, tick;
                for(i = 0, ilen = ticks.length; i < ilen; ++i){
                    tick = ticks[i];
                    tick.label = this._tickFormatFunction(tick.value, i, ticks);
                }
            }
        },
        {
            key: "getDecimalForValue",
            value: function getDecimalForValue(value) {
                return value === null ? NaN : (value - this.min) / (this.max - this.min);
            }
        },
        {
            key: "getPixelForValue",
            value: function getPixelForValue(value) {
                var offsets = this._offsets;
                var pos = this.getDecimalForValue(value);
                return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
            }
        },
        {
            key: "getValueForPixel",
            value: function getValueForPixel(pixel) {
                var offsets = this._offsets;
                var pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
                return this.min + pos * (this.max - this.min);
            }
        },
        {
            key: "_getLabelSize",
            value: function _getLabelSize(label) {
                var ticksOpts = this.options.ticks;
                var tickLabelWidth = this.ctx.measureText(label).width;
                var angle = (0, _helpersSegmentJs.t)(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
                var cosRotation = Math.cos(angle);
                var sinRotation = Math.sin(angle);
                var tickFontSize = this._resolveTickFontOptions(0).size;
                return {
                    w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
                    h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
                };
            }
        },
        {
            key: "_getLabelCapacity",
            value: function _getLabelCapacity(exampleTime) {
                var timeOpts = this.options.time;
                var displayFormats = timeOpts.displayFormats;
                var format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
                var exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
                    exampleTime
                ], this._majorUnit), format);
                var size = this._getLabelSize(exampleLabel);
                var capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
                return capacity > 0 ? capacity : 1;
            }
        },
        {
            key: "getDataTimestamps",
            value: function getDataTimestamps() {
                var timestamps = this._cache.data || [];
                var i, ilen;
                if (timestamps.length) return timestamps;
                var metas = this.getMatchingVisibleMetas();
                if (this._normalized && metas.length) return this._cache.data = metas[0].controller.getAllParsedValues(this);
                for(i = 0, ilen = metas.length; i < ilen; ++i)timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
                return this._cache.data = this.normalize(timestamps);
            }
        },
        {
            key: "getLabelTimestamps",
            value: function getLabelTimestamps() {
                var timestamps = this._cache.labels || [];
                var i, ilen;
                if (timestamps.length) return timestamps;
                var labels = this.getLabels();
                for(i = 0, ilen = labels.length; i < ilen; ++i)timestamps.push(parse(this, labels[i]));
                return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
            }
        },
        {
            key: "normalize",
            value: function normalize(values) {
                return (0, _helpersSegmentJs._)(values.sort(sorter));
            }
        }
    ]);
    return TimeScale;
}(Scale);
(0, _defineProperty._)(TimeScale, "id", "time");
(0, _defineProperty._)(TimeScale, "defaults", {
    bounds: "data",
    adapters: {},
    time: {
        parser: false,
        unit: false,
        round: false,
        isoWeekday: false,
        minUnit: "millisecond",
        displayFormats: {}
    },
    ticks: {
        source: "auto",
        callback: false,
        major: {
            enabled: false
        }
    }
});
function interpolate(table, val, reverse) {
    var lo = 0;
    var hi = table.length - 1;
    var prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
        var ref;
        if (val >= table[lo].pos && val <= table[hi].pos) ref = (0, _helpersSegmentJs.B)(table, "pos", val), lo = ref.lo, hi = ref.hi, ref;
        var ref1;
        ref1 = table[lo], prevSource = ref1.pos, prevTarget = ref1.time, ref1;
        var ref2;
        ref2 = table[hi], nextSource = ref2.pos, nextTarget = ref2.time, ref2;
    } else {
        var ref3;
        if (val >= table[lo].time && val <= table[hi].time) ref3 = (0, _helpersSegmentJs.B)(table, "time", val), lo = ref3.lo, hi = ref3.hi, ref3;
        var ref4;
        ref4 = table[lo], prevSource = ref4.time, prevTarget = ref4.pos, ref4;
        var ref5;
        ref5 = table[hi], nextSource = ref5.time, nextTarget = ref5.pos, ref5;
    }
    var span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = /*#__PURE__*/ function(TimeScale) {
    "use strict";
    (0, _inherits._)(TimeSeriesScale, TimeScale);
    var _super = (0, _createSuper._)(TimeSeriesScale);
    function TimeSeriesScale(props) {
        (0, _classCallCheck._)(this, TimeSeriesScale);
        var _this;
        _this = _super.call(this, props);
        _this._table = [];
        _this._minPos = undefined;
        _this._tableRange = undefined;
        return _this;
    }
    (0, _createClass._)(TimeSeriesScale, [
        {
            key: "initOffsets",
            value: function initOffsets() {
                var timestamps = this._getTimestampsForTable();
                var table = this._table = this.buildLookupTable(timestamps);
                this._minPos = interpolate(table, this.min);
                this._tableRange = interpolate(table, this.max) - this._minPos;
                (0, _get._)((0, _getPrototypeOf._)(TimeSeriesScale.prototype), "initOffsets", this).call(this, timestamps);
            }
        },
        {
            key: "buildLookupTable",
            value: function buildLookupTable(timestamps) {
                var _this = this, min = _this.min, max = _this.max;
                var items = [];
                var table = [];
                var i, ilen, prev, curr, next;
                for(i = 0, ilen = timestamps.length; i < ilen; ++i){
                    curr = timestamps[i];
                    if (curr >= min && curr <= max) items.push(curr);
                }
                if (items.length < 2) return [
                    {
                        time: min,
                        pos: 0
                    },
                    {
                        time: max,
                        pos: 1
                    }
                ];
                for(i = 0, ilen = items.length; i < ilen; ++i){
                    next = items[i + 1];
                    prev = items[i - 1];
                    curr = items[i];
                    if (Math.round((next + prev) / 2) !== curr) table.push({
                        time: curr,
                        pos: i / (ilen - 1)
                    });
                }
                return table;
            }
        },
        {
            key: "_generate",
            value: function _generate() {
                var min = this.min;
                var max = this.max;
                var timestamps = (0, _get._)((0, _getPrototypeOf._)(TimeSeriesScale.prototype), "getDataTimestamps", this).call(this);
                if (!timestamps.includes(min) || !timestamps.length) timestamps.splice(0, 0, min);
                if (!timestamps.includes(max) || timestamps.length === 1) timestamps.push(max);
                return timestamps.sort(function(a, b) {
                    return a - b;
                });
            }
        },
        {
            key: "_getTimestampsForTable",
            value: function _getTimestampsForTable() {
                var timestamps = this._cache.all || [];
                if (timestamps.length) return timestamps;
                var data = this.getDataTimestamps();
                var label = this.getLabelTimestamps();
                if (data.length && label.length) timestamps = this.normalize(data.concat(label));
                else timestamps = data.length ? data : label;
                timestamps = this._cache.all = timestamps;
                return timestamps;
            }
        },
        {
            key: "getDecimalForValue",
            value: function getDecimalForValue(value) {
                return (interpolate(this._table, value) - this._minPos) / this._tableRange;
            }
        },
        {
            key: "getValueForPixel",
            value: function getValueForPixel(pixel) {
                var offsets = this._offsets;
                var decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
                return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
            }
        }
    ]);
    return TimeSeriesScale;
}(TimeScale);
(0, _defineProperty._)(TimeSeriesScale, "id", "timeseries");
(0, _defineProperty._)(TimeSeriesScale, "defaults", TimeScale.defaults);
var scales = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    CategoryScale: CategoryScale,
    LinearScale: LinearScale,
    LogarithmicScale: LogarithmicScale,
    RadialLinearScale: RadialLinearScale,
    TimeScale: TimeScale,
    TimeSeriesScale: TimeSeriesScale
});
var registerables = [
    controllers,
    elements,
    plugins,
    scales
];

},{"@swc/helpers/_/_assert_this_initialized":"3PLnj","@swc/helpers/_/_class_call_check":"70JET","@swc/helpers/_/_create_class":"9CG3U","@swc/helpers/_/_define_property":"6dEyb","@swc/helpers/_/_get":"g9rpX","@swc/helpers/_/_get_prototype_of":"04T80","@swc/helpers/_/_inherits":"dofLt","@swc/helpers/_/_object_spread":"lyjzq","@swc/helpers/_/_object_spread_props":"5jOWC","@swc/helpers/_/_sliced_to_array":"lHDUI","@swc/helpers/_/_to_consumable_array":"ig3r6","@swc/helpers/_/_type_of":"b4wfg","@swc/helpers/_/_wrap_native_super":"863v2","@swc/helpers/_/_create_super":"gf9e2","./chunks/helpers.segment.js":"l0Jv6","@kurkle/color":"1Q4kk","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"g9rpX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_get", function() {
    return _get;
});
parcelHelpers.export(exports, "_", function() {
    return _get;
});
var _superPropBaseJs = require("./_super_prop_base.js");
function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) _get = Reflect.get;
    else _get = function get(target, property, receiver) {
        var base = (0, _superPropBaseJs._super_prop_base)(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) return desc.get.call(receiver || target);
        return desc.value;
    };
    return _get(target, property, receiver || target);
}

},{"./_super_prop_base.js":"l7QCS","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"l7QCS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_super_prop_base", function() {
    return _super_prop_base;
});
parcelHelpers.export(exports, "_", function() {
    return _super_prop_base;
});
var _getPrototypeOfJs = require("./_get_prototype_of.js");
function _super_prop_base(object, property) {
    while(!Object.prototype.hasOwnProperty.call(object, property)){
        object = (0, _getPrototypeOfJs._get_prototype_of)(object);
        if (object === null) break;
    }
    return object;
}

},{"./_get_prototype_of.js":"04T80","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"5jOWC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_object_spread_props", function() {
    return _object_spread_props;
});
parcelHelpers.export(exports, "_", function() {
    return _object_spread_props;
});
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    else ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
    return target;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"863v2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_wrap_native_super", function() {
    return _wrap_native_super;
});
parcelHelpers.export(exports, "_", function() {
    return _wrap_native_super;
});
var _constructJs = require("./_construct.js");
var _getPrototypeOfJs = require("./_get_prototype_of.js");
var _isNativeFunctionJs = require("./_is_native_function.js");
var _setPrototypeOfJs = require("./_set_prototype_of.js");
function _wrap_native_super(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrap_native_super = function(Class) {
        if (Class === null || !(0, _isNativeFunctionJs._is_native_function)(Class)) return Class;
        if (typeof Class !== "function") throw new TypeError("Super expression must either be null or a function");
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return (0, _constructJs._construct)(Class, arguments, (0, _getPrototypeOfJs._get_prototype_of)(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return (0, _setPrototypeOfJs._set_prototype_of)(Wrapper, Class);
    };
    return _wrap_native_super(Class);
}

},{"./_construct.js":"RJfJB","./_get_prototype_of.js":"04T80","./_is_native_function.js":"cdJ8m","./_set_prototype_of.js":"epPZP","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"RJfJB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_construct", function() {
    return _construct;
});
parcelHelpers.export(exports, "_", function() {
    return _construct;
});
var _isNativeReflectConstructJs = require("./_is_native_reflect_construct.js");
var _setPrototypeOfJs = require("./_set_prototype_of.js");
function _construct(Parent, args, Class) {
    if ((0, _isNativeReflectConstructJs._is_native_reflect_construct)()) _construct = Reflect.construct;
    else _construct = function construct(Parent, args, Class) {
        var a = [
            null
        ];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) (0, _setPrototypeOfJs._set_prototype_of)(instance, Class.prototype);
        return instance;
    };
    return _construct.apply(null, arguments);
}

},{"./_is_native_reflect_construct.js":"8VpOd","./_set_prototype_of.js":"epPZP","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"cdJ8m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_is_native_function", function() {
    return _is_native_function;
});
parcelHelpers.export(exports, "_", function() {
    return _is_native_function;
});
function _is_native_function(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"l0Jv6":[function(require,module,exports) {
/*!
 * Chart.js v4.4.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "$", function() {
    return unclipArea;
});
parcelHelpers.export(exports, "A", function() {
    return _rlookupByKey;
});
parcelHelpers.export(exports, "B", function() {
    return _lookupByKey;
});
parcelHelpers.export(exports, "C", function() {
    return _isPointInArea;
});
parcelHelpers.export(exports, "D", function() {
    return getAngleFromPoint;
});
parcelHelpers.export(exports, "E", function() {
    return toPadding;
});
parcelHelpers.export(exports, "F", function() {
    return each;
});
parcelHelpers.export(exports, "G", function() {
    return getMaximumSize;
});
parcelHelpers.export(exports, "H", function() {
    return HALF_PI;
});
parcelHelpers.export(exports, "I", function() {
    return _getParentNode;
});
parcelHelpers.export(exports, "J", function() {
    return readUsedSize;
});
parcelHelpers.export(exports, "K", function() {
    return supportsEventListenerOptions;
});
parcelHelpers.export(exports, "L", function() {
    return throttled;
});
parcelHelpers.export(exports, "M", function() {
    return _isDomSupported;
});
parcelHelpers.export(exports, "N", function() {
    return _factorize;
});
parcelHelpers.export(exports, "O", function() {
    return finiteOrDefault;
});
parcelHelpers.export(exports, "P", function() {
    return PI;
});
parcelHelpers.export(exports, "Q", function() {
    return callback;
});
parcelHelpers.export(exports, "R", function() {
    return _addGrace;
});
parcelHelpers.export(exports, "S", function() {
    return _limitValue;
});
parcelHelpers.export(exports, "T", function() {
    return TAU;
});
parcelHelpers.export(exports, "U", function() {
    return toDegrees;
});
parcelHelpers.export(exports, "V", function() {
    return _measureText;
});
parcelHelpers.export(exports, "W", function() {
    return _int16Range;
});
parcelHelpers.export(exports, "X", function() {
    return _alignPixel;
});
parcelHelpers.export(exports, "Y", function() {
    return clipArea;
});
parcelHelpers.export(exports, "Z", function() {
    return renderText;
});
parcelHelpers.export(exports, "_", function() {
    return _arrayUnique;
});
parcelHelpers.export(exports, "a", function() {
    return resolve;
});
parcelHelpers.export(exports, "a$", function() {
    return fontString;
});
parcelHelpers.export(exports, "a0", function() {
    return toFont;
});
parcelHelpers.export(exports, "a1", function() {
    return _toLeftRightCenter;
});
parcelHelpers.export(exports, "a2", function() {
    return _alignStartEnd;
});
parcelHelpers.export(exports, "a3", function() {
    return overrides;
});
parcelHelpers.export(exports, "a4", function() {
    return merge;
});
parcelHelpers.export(exports, "a5", function() {
    return _capitalize;
});
parcelHelpers.export(exports, "a6", function() {
    return descriptors;
});
parcelHelpers.export(exports, "a7", function() {
    return isFunction;
});
parcelHelpers.export(exports, "a8", function() {
    return _attachContext;
});
parcelHelpers.export(exports, "a9", function() {
    return _createResolver;
});
parcelHelpers.export(exports, "aA", function() {
    return overrideTextDirection;
});
parcelHelpers.export(exports, "aB", function() {
    return _textX;
});
parcelHelpers.export(exports, "aC", function() {
    return restoreTextDirection;
});
parcelHelpers.export(exports, "aD", function() {
    return drawPointLegend;
});
parcelHelpers.export(exports, "aE", function() {
    return distanceBetweenPoints;
});
parcelHelpers.export(exports, "aF", function() {
    return noop;
});
parcelHelpers.export(exports, "aG", function() {
    return _setMinAndMaxByKey;
});
parcelHelpers.export(exports, "aH", function() {
    return niceNum;
});
parcelHelpers.export(exports, "aI", function() {
    return almostWhole;
});
parcelHelpers.export(exports, "aJ", function() {
    return almostEquals;
});
parcelHelpers.export(exports, "aK", function() {
    return _decimalPlaces;
});
parcelHelpers.export(exports, "aL", function() {
    return Ticks;
});
parcelHelpers.export(exports, "aM", function() {
    return log10;
});
parcelHelpers.export(exports, "aN", function() {
    return _longestText;
});
parcelHelpers.export(exports, "aO", function() {
    return _filterBetween;
});
parcelHelpers.export(exports, "aP", function() {
    return _lookup;
});
parcelHelpers.export(exports, "aQ", function() {
    return isPatternOrGradient;
});
parcelHelpers.export(exports, "aR", function() {
    return getHoverColor;
});
parcelHelpers.export(exports, "aS", function() {
    return clone;
});
parcelHelpers.export(exports, "aT", function() {
    return _merger;
});
parcelHelpers.export(exports, "aU", function() {
    return _mergerIf;
});
parcelHelpers.export(exports, "aV", function() {
    return _deprecated;
});
parcelHelpers.export(exports, "aW", function() {
    return _splitKey;
});
parcelHelpers.export(exports, "aX", function() {
    return toFontString;
});
parcelHelpers.export(exports, "aY", function() {
    return splineCurve;
});
parcelHelpers.export(exports, "aZ", function() {
    return splineCurveMonotone;
});
parcelHelpers.export(exports, "a_", function() {
    return getStyle;
});
parcelHelpers.export(exports, "aa", function() {
    return _descriptors;
});
parcelHelpers.export(exports, "ab", function() {
    return mergeIf;
});
parcelHelpers.export(exports, "ac", function() {
    return uid;
});
parcelHelpers.export(exports, "ad", function() {
    return debounce;
});
parcelHelpers.export(exports, "ae", function() {
    return retinaScale;
});
parcelHelpers.export(exports, "af", function() {
    return clearCanvas;
});
parcelHelpers.export(exports, "ag", function() {
    return setsEqual;
});
parcelHelpers.export(exports, "ah", function() {
    return _elementsEqual;
});
parcelHelpers.export(exports, "ai", function() {
    return _isClickEvent;
});
parcelHelpers.export(exports, "aj", function() {
    return _isBetween;
});
parcelHelpers.export(exports, "ak", function() {
    return _readValueToProps;
});
parcelHelpers.export(exports, "al", function() {
    return _updateBezierControlPoints;
});
parcelHelpers.export(exports, "am", function() {
    return _computeSegments;
});
parcelHelpers.export(exports, "an", function() {
    return _boundSegments;
});
parcelHelpers.export(exports, "ao", function() {
    return _steppedInterpolation;
});
parcelHelpers.export(exports, "ap", function() {
    return _bezierInterpolation;
});
parcelHelpers.export(exports, "aq", function() {
    return _pointInLine;
});
parcelHelpers.export(exports, "ar", function() {
    return _steppedLineTo;
});
parcelHelpers.export(exports, "as", function() {
    return _bezierCurveTo;
});
parcelHelpers.export(exports, "at", function() {
    return drawPoint;
});
parcelHelpers.export(exports, "au", function() {
    return addRoundedRectPath;
});
parcelHelpers.export(exports, "av", function() {
    return toTRBL;
});
parcelHelpers.export(exports, "aw", function() {
    return toTRBLCorners;
});
parcelHelpers.export(exports, "ax", function() {
    return _boundSegment;
});
parcelHelpers.export(exports, "ay", function() {
    return _normalizeAngle;
});
parcelHelpers.export(exports, "az", function() {
    return getRtlAdapter;
});
parcelHelpers.export(exports, "b", function() {
    return isArray;
});
parcelHelpers.export(exports, "b0", function() {
    return toLineHeight;
});
parcelHelpers.export(exports, "b1", function() {
    return PITAU;
});
parcelHelpers.export(exports, "b2", function() {
    return INFINITY;
});
parcelHelpers.export(exports, "b3", function() {
    return RAD_PER_DEG;
});
parcelHelpers.export(exports, "b4", function() {
    return QUARTER_PI;
});
parcelHelpers.export(exports, "b5", function() {
    return TWO_THIRDS_PI;
});
parcelHelpers.export(exports, "b6", function() {
    return _angleDiff;
});
parcelHelpers.export(exports, "c", function() {
    return color;
});
parcelHelpers.export(exports, "d", function() {
    return defaults;
});
parcelHelpers.export(exports, "e", function() {
    return effects;
});
parcelHelpers.export(exports, "f", function() {
    return resolveObjectKey;
});
parcelHelpers.export(exports, "g", function() {
    return isNumberFinite;
});
parcelHelpers.export(exports, "h", function() {
    return defined;
});
parcelHelpers.export(exports, "i", function() {
    return isObject;
});
parcelHelpers.export(exports, "j", function() {
    return createContext;
});
parcelHelpers.export(exports, "k", function() {
    return isNullOrUndef;
});
parcelHelpers.export(exports, "l", function() {
    return listenArrayEvents;
});
parcelHelpers.export(exports, "m", function() {
    return toPercentage;
});
parcelHelpers.export(exports, "n", function() {
    return toDimension;
});
parcelHelpers.export(exports, "o", function() {
    return formatNumber;
});
parcelHelpers.export(exports, "p", function() {
    return _angleBetween;
});
parcelHelpers.export(exports, "q", function() {
    return _getStartAndCountOfVisiblePoints;
});
parcelHelpers.export(exports, "r", function() {
    return requestAnimFrame;
});
parcelHelpers.export(exports, "s", function() {
    return sign;
});
parcelHelpers.export(exports, "t", function() {
    return toRadians;
});
parcelHelpers.export(exports, "u", function() {
    return unlistenArrayEvents;
});
parcelHelpers.export(exports, "v", function() {
    return valueOrDefault;
});
parcelHelpers.export(exports, "w", function() {
    return _scaleRangesChanged;
});
parcelHelpers.export(exports, "x", function() {
    return isNumber;
});
parcelHelpers.export(exports, "y", function() {
    return _parseObjectDataRadialScale;
});
parcelHelpers.export(exports, "z", function() {
    return getRelativePosition;
});
var _classCallCheck = require("@swc/helpers/_/_class_call_check");
var _createClass = require("@swc/helpers/_/_create_class");
var _defineProperty = require("@swc/helpers/_/_define_property");
var _toConsumableArray = require("@swc/helpers/_/_to_consumable_array");
var _color = require("@kurkle/color");
/**
 * @namespace Chart.helpers
 */ /**
 * An empty function that can be used, for example, for optional callback.
 */ function noop() {
/* noop */ }
/**
 * Returns a unique id, sequentially generated from a global variable.
 */ var uid = function() {
    var id = 0;
    return function() {
        return id++;
    };
}();
/**
 * Returns true if `value` is neither null nor undefined, else returns false.
 * @param value - The value to test.
 * @since 2.7.0
 */ function isNullOrUndef(value) {
    return value === null || typeof value === "undefined";
}
/**
 * Returns true if `value` is an array (including typed arrays), else returns false.
 * @param value - The value to test.
 * @function
 */ function isArray(value) {
    if (Array.isArray && Array.isArray(value)) return true;
    var type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") return true;
    return false;
}
/**
 * Returns true if `value` is an object (excluding null), else returns false.
 * @param value - The value to test.
 * @since 2.7.0
 */ function isObject(value) {
    return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
/**
 * Returns true if `value` is a finite number, else returns false
 * @param value  - The value to test.
 */ function isNumberFinite(value) {
    return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
/**
 * Returns `value` if finite, else returns `defaultValue`.
 * @param value - The value to return if defined.
 * @param defaultValue - The value to return if `value` is not finite.
 */ function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
}
/**
 * Returns `value` if defined, else returns `defaultValue`.
 * @param value - The value to return if defined.
 * @param defaultValue - The value to return if `value` is undefined.
 */ function valueOrDefault(value, defaultValue) {
    return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = function(value, dimension) {
    return typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
};
var toDimension = function(value, dimension) {
    return typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
};
/**
 * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
 * value returned by `fn`. If `fn` is not a function, this method returns undefined.
 * @param fn - The function to call.
 * @param args - The arguments with which `fn` should be called.
 * @param [thisArg] - The value of `this` provided for the call to `fn`.
 */ function callback(fn, args, thisArg) {
    if (fn && typeof fn.call === "function") return fn.apply(thisArg, args);
}
function each(loopable, fn, thisArg, reverse) {
    var i, len, keys;
    if (isArray(loopable)) {
        len = loopable.length;
        if (reverse) for(i = len - 1; i >= 0; i--)fn.call(thisArg, loopable[i], i);
        else for(i = 0; i < len; i++)fn.call(thisArg, loopable[i], i);
    } else if (isObject(loopable)) {
        keys = Object.keys(loopable);
        len = keys.length;
        for(i = 0; i < len; i++)fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
}
/**
 * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
 * @param a0 - The array to compare
 * @param a1 - The array to compare
 * @private
 */ function _elementsEqual(a0, a1) {
    var i, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) return false;
    for(i = 0, ilen = a0.length; i < ilen; ++i){
        v0 = a0[i];
        v1 = a1[i];
        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) return false;
    }
    return true;
}
/**
 * Returns a deep copy of `source` without keeping references on objects and arrays.
 * @param source - The value to clone.
 */ function clone(source) {
    if (isArray(source)) return source.map(clone);
    if (isObject(source)) {
        var target = Object.create(null);
        var keys = Object.keys(source);
        var klen = keys.length;
        var k = 0;
        for(; k < klen; ++k)target[keys[k]] = clone(source[keys[k]]);
        return target;
    }
    return source;
}
function isValidKey(key) {
    return [
        "__proto__",
        "prototype",
        "constructor"
    ].indexOf(key) === -1;
}
/**
 * The default merger when Chart.helpers.merge is called without merger option.
 * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
 * @private
 */ function _merger(key, target, source, options) {
    if (!isValidKey(key)) return;
    var tval = target[key];
    var sval = source[key];
    if (isObject(tval) && isObject(sval)) // eslint-disable-next-line @typescript-eslint/no-use-before-define
    merge(tval, sval, options);
    else target[key] = clone(sval);
}
function merge(target, source, options) {
    var sources = isArray(source) ? source : [
        source
    ];
    var ilen = sources.length;
    if (!isObject(target)) return target;
    options = options || {};
    var merger = options.merger || _merger;
    var current;
    for(var i = 0; i < ilen; ++i){
        current = sources[i];
        if (!isObject(current)) continue;
        var keys = Object.keys(current);
        for(var k = 0, klen = keys.length; k < klen; ++k)merger(keys[k], target, current, options);
    }
    return target;
}
function mergeIf(target, source) {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return merge(target, source, {
        merger: _mergerIf
    });
}
/**
 * Merges source[key] in target[key] only if target[key] is undefined.
 * @private
 */ function _mergerIf(key, target, source) {
    if (!isValidKey(key)) return;
    var tval = target[key];
    var sval = source[key];
    if (isObject(tval) && isObject(sval)) mergeIf(tval, sval);
    else if (!Object.prototype.hasOwnProperty.call(target, key)) target[key] = clone(sval);
}
/**
 * @private
 */ function _deprecated(scope, value, previous, current) {
    if (value !== undefined) console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
}
// resolveObjectKey resolver cache
var keyResolvers = {
    // Chart.helpers.core resolveObjectKey should resolve empty key to root object
    "": function(v) {
        return v;
    },
    // default resolvers
    x: function(o) {
        return o.x;
    },
    y: function(o) {
        return o.y;
    }
};
/**
 * @private
 */ function _splitKey(key) {
    var parts = key.split(".");
    var keys = [];
    var tmp = "";
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var part = _step.value;
            tmp += part;
            if (tmp.endsWith("\\")) tmp = tmp.slice(0, -1) + ".";
            else {
                keys.push(tmp);
                tmp = "";
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return keys;
}
function _getKeyResolver(key) {
    var keys = _splitKey(key);
    return function(obj) {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var k = _step.value;
                if (k === "") break;
                obj = obj && obj[k];
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return obj;
    };
}
function resolveObjectKey(obj, key) {
    var resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
}
/**
 * @private
 */ function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = function(value) {
    return typeof value !== "undefined";
};
var isFunction = function(value) {
    return typeof value === "function";
};
// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384
var setsEqual = function(a, b) {
    if (a.size !== b.size) return false;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = a[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var item = _step.value;
            if (!b.has(item)) return false;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return true;
};
/**
 * @param e - The event
 * @private
 */ function _isClickEvent(e) {
    return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
/**
 * @alias Chart.helpers.math
 * @namespace
 */ var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function almostEquals(x, y, epsilon) {
    return Math.abs(x - y) < epsilon;
}
/**
 * Implementation of the nice number algorithm used in determining where axis labels will go
 */ function niceNum(range) {
    var roundedRange = Math.round(range);
    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
    var niceRange = Math.pow(10, Math.floor(log10(range)));
    var fraction = range / niceRange;
    var niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
}
/**
 * Returns an array of factors sorted from 1 to sqrt(value)
 * @private
 */ function _factorize(value) {
    var result = [];
    var sqrt = Math.sqrt(value);
    var i;
    for(i = 1; i < sqrt; i++)if (value % i === 0) {
        result.push(i);
        result.push(value / i);
    }
    if (sqrt === (sqrt | 0)) result.push(sqrt);
    result.sort(function(a, b) {
        return a - b;
    }).pop();
    return result;
}
function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x, epsilon) {
    var rounded = Math.round(x);
    return rounded - epsilon <= x && rounded + epsilon >= x;
}
/**
 * @private
 */ function _setMinAndMaxByKey(array, target, property) {
    var i, ilen, value;
    for(i = 0, ilen = array.length; i < ilen; i++){
        value = array[i][property];
        if (!isNaN(value)) {
            target.min = Math.min(target.min, value);
            target.max = Math.max(target.max, value);
        }
    }
}
function toRadians(degrees) {
    return degrees * (PI / 180);
}
function toDegrees(radians) {
    return radians * (180 / PI);
}
/**
 * Returns the number of decimal places
 * i.e. the number of digits after the decimal point, of the value of this Number.
 * @param x - A number.
 * @returns The number of decimal places.
 * @private
 */ function _decimalPlaces(x) {
    if (!isNumberFinite(x)) return;
    var e = 1;
    var p = 0;
    while(Math.round(x * e) / e !== x){
        e *= 10;
        p++;
    }
    return p;
}
// Gets the angle from vertical upright to the point about a centre.
function getAngleFromPoint(centrePoint, anglePoint) {
    var distanceFromXCenter = anglePoint.x - centrePoint.x;
    var distanceFromYCenter = anglePoint.y - centrePoint.y;
    var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
    return {
        angle: angle,
        distance: radialDistanceFromCenter
    };
}
function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
/**
 * Shortest distance between angles, in either direction.
 * @private
 */ function _angleDiff(a, b) {
    return (a - b + PITAU) % TAU - PI;
}
/**
 * Normalize angle to be between 0 and 2*PI
 * @private
 */ function _normalizeAngle(a) {
    return (a % TAU + TAU) % TAU;
}
/**
 * @private
 */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
    var a = _normalizeAngle(angle);
    var s = _normalizeAngle(start);
    var e = _normalizeAngle(end);
    var angleToStart = _normalizeAngle(s - a);
    var angleToEnd = _normalizeAngle(e - a);
    var startToAngle = _normalizeAngle(a - s);
    var endToAngle = _normalizeAngle(a - e);
    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
/**
 * Limit `value` between `min` and `max`
 * @param value
 * @param min
 * @param max
 * @private
 */ function _limitValue(value, min, max) {
    return Math.max(min, Math.min(max, value));
}
/**
 * @param {number} value
 * @private
 */ function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
}
/**
 * @param value
 * @param start
 * @param end
 * @param [epsilon]
 * @private
 */ function _isBetween(value, start, end) {
    var epsilon = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1e-6;
    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
    cmp = cmp || function(index) {
        return table[index] < value;
    };
    var hi = table.length - 1;
    var lo = 0;
    var mid;
    while(hi - lo > 1){
        mid = lo + hi >> 1;
        if (cmp(mid)) lo = mid;
        else hi = mid;
    }
    return {
        lo: lo,
        hi: hi
    };
}
/**
 * Binary search
 * @param table - the table search. must be sorted!
 * @param key - property name for the value in each entry
 * @param value - value to find
 * @param last - lookup last index
 * @private
 */ var _lookupByKey = function(table, key, value, last) {
    return _lookup(table, value, last ? function(index) {
        var ti = table[index][key];
        return ti < value || ti === value && table[index + 1][key] === value;
    } : function(index) {
        return table[index][key] < value;
    });
};
/**
 * Reverse binary search
 * @param table - the table search. must be sorted!
 * @param key - property name for the value in each entry
 * @param value - value to find
 * @private
 */ var _rlookupByKey = function(table, key, value) {
    return _lookup(table, value, function(index) {
        return table[index][key] >= value;
    });
};
/**
 * Return subset of `values` between `min` and `max` inclusive.
 * Values are assumed to be in sorted order.
 * @param values - sorted array of values
 * @param min - min value
 * @param max - max value
 */ function _filterBetween(values, min, max) {
    var start = 0;
    var end = values.length;
    while(start < end && values[start] < min)start++;
    while(end > start && values[end - 1] > max)end--;
    return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = [
    "push",
    "pop",
    "shift",
    "splice",
    "unshift"
];
function listenArrayEvents(array, listener) {
    if (array._chartjs) {
        array._chartjs.listeners.push(listener);
        return;
    }
    Object.defineProperty(array, "_chartjs", {
        configurable: true,
        enumerable: false,
        value: {
            listeners: [
                listener
            ]
        }
    });
    arrayEvents.forEach(function(key) {
        var method = "_onData" + _capitalize(key);
        var base = array[key];
        Object.defineProperty(array, key, {
            configurable: true,
            enumerable: false,
            value: function() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var res = base.apply(this, args);
                array._chartjs.listeners.forEach(function(object) {
                    var _object;
                    if (typeof object[method] === "function") (_object = object)[method].apply(_object, (0, _toConsumableArray._)(args));
                });
                return res;
            }
        });
    });
}
function unlistenArrayEvents(array, listener) {
    var stub = array._chartjs;
    if (!stub) return;
    var listeners = stub.listeners;
    var index = listeners.indexOf(listener);
    if (index !== -1) listeners.splice(index, 1);
    if (listeners.length > 0) return;
    arrayEvents.forEach(function(key) {
        delete array[key];
    });
    delete array._chartjs;
}
/**
 * @param items
 */ function _arrayUnique(items) {
    var set = new Set(items);
    if (set.size === items.length) return items;
    return Array.from(set);
}
function fontString(pixelSize, fontStyle, fontFamily) {
    return fontStyle + " " + pixelSize + "px " + fontFamily;
}
/**
* Request animation polyfill
*/ var requestAnimFrame = function() {
    if (typeof window === "undefined") return function(callback) {
        return callback();
    };
    return window.requestAnimationFrame;
}();
/**
 * Throttles calling `fn` once per animation frame
 * Latest arguments are used on the actual call
 */ function throttled(fn, thisArg) {
    var argsToUse = [];
    var ticking = false;
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        // Save the args for use later
        argsToUse = args;
        if (!ticking) {
            ticking = true;
            requestAnimFrame.call(window, function() {
                ticking = false;
                fn.apply(thisArg, argsToUse);
            });
        }
    };
}
/**
 * Debounces calling `fn` for `delay` ms
 */ function debounce(fn, delay) {
    var timeout;
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (delay) {
            clearTimeout(timeout);
            timeout = setTimeout(fn, delay, args);
        } else fn.apply(this, args);
        return delay;
    };
}
/**
 * Converts 'start' to 'left', 'end' to 'right' and others to 'center'
 * @private
 */ var _toLeftRightCenter = function(align) {
    return align === "start" ? "left" : align === "end" ? "right" : "center";
};
/**
 * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`
 * @private
 */ var _alignStartEnd = function(align, start, end) {
    return align === "start" ? start : align === "end" ? end : (start + end) / 2;
};
/**
 * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`
 * @private
 */ var _textX = function(align, left, right, rtl) {
    var check = rtl ? "left" : "right";
    return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
/**
 * Return start and count of visible points.
 * @private
 */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    var pointCount = points.length;
    var start = 0;
    var count = pointCount;
    if (meta._sorted) {
        var iScale = meta.iScale, _parsed = meta._parsed;
        var axis = iScale.axis;
        var _iScale_getUserBounds = iScale.getUserBounds(), min = _iScale_getUserBounds.min, max = _iScale_getUserBounds.max, minDefined = _iScale_getUserBounds.minDefined, maxDefined = _iScale_getUserBounds.maxDefined;
        if (minDefined) start = _limitValue(Math.min(_lookupByKey(_parsed, axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
        if (maxDefined) count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;
        else count = pointCount - start;
    }
    return {
        start: start,
        count: count
    };
}
/**
 * Checks if the scale ranges have changed.
 * @param {object} meta - dataset meta.
 * @returns {boolean}
 * @private
 */ function _scaleRangesChanged(meta) {
    var xScale = meta.xScale, yScale = meta.yScale, _scaleRanges = meta._scaleRanges;
    var newRanges = {
        xmin: xScale.min,
        xmax: xScale.max,
        ymin: yScale.min,
        ymax: yScale.max
    };
    if (!_scaleRanges) {
        meta._scaleRanges = newRanges;
        return true;
    }
    var changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
}
var atEdge = function(t) {
    return t === 0 || t === 1;
};
var elasticIn = function(t, s, p) {
    return -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
};
var elasticOut = function(t, s, p) {
    return Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
};
/**
 * Easing functions adapted from Robert Penner's easing equations.
 * @namespace Chart.helpers.easing.effects
 * @see http://www.robertpenner.com/easing/
 */ var effects = {
    linear: function(t) {
        return t;
    },
    easeInQuad: function(t) {
        return t * t;
    },
    easeOutQuad: function(t) {
        return -t * (t - 2);
    },
    easeInOutQuad: function(t) {
        return (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1);
    },
    easeInCubic: function(t) {
        return t * t * t;
    },
    easeOutCubic: function(t) {
        return (t -= 1) * t * t + 1;
    },
    easeInOutCubic: function(t) {
        return (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2);
    },
    easeInQuart: function(t) {
        return t * t * t * t;
    },
    easeOutQuart: function(t) {
        return -((t -= 1) * t * t * t - 1);
    },
    easeInOutQuart: function(t) {
        return (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2);
    },
    easeInQuint: function(t) {
        return t * t * t * t * t;
    },
    easeOutQuint: function(t) {
        return (t -= 1) * t * t * t * t + 1;
    },
    easeInOutQuint: function(t) {
        return (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2);
    },
    easeInSine: function(t) {
        return -Math.cos(t * HALF_PI) + 1;
    },
    easeOutSine: function(t) {
        return Math.sin(t * HALF_PI);
    },
    easeInOutSine: function(t) {
        return -0.5 * (Math.cos(PI * t) - 1);
    },
    easeInExpo: function(t) {
        return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
    },
    easeOutExpo: function(t) {
        return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
    },
    easeInOutExpo: function(t) {
        return atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2);
    },
    easeInCirc: function(t) {
        return t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1);
    },
    easeOutCirc: function(t) {
        return Math.sqrt(1 - (t -= 1) * t);
    },
    easeInOutCirc: function(t) {
        return (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
    },
    easeInElastic: function(t) {
        return atEdge(t) ? t : elasticIn(t, 0.075, 0.3);
    },
    easeOutElastic: function(t) {
        return atEdge(t) ? t : elasticOut(t, 0.075, 0.3);
    },
    easeInOutElastic: function(t) {
        var s = 0.1125;
        var p = 0.45;
        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
    },
    easeInBack: function(t) {
        var s = 1.70158;
        return t * t * ((s + 1) * t - s);
    },
    easeOutBack: function(t) {
        var s = 1.70158;
        return (t -= 1) * t * ((s + 1) * t + s) + 1;
    },
    easeInOutBack: function(t) {
        var s = 1.70158;
        if ((t /= 0.5) < 1) return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
    },
    easeInBounce: function(t) {
        return 1 - effects.easeOutBounce(1 - t);
    },
    easeOutBounce: function(t) {
        var m = 7.5625;
        var d = 2.75;
        if (t < 1 / d) return m * t * t;
        if (t < 2 / d) return m * (t -= 1.5 / d) * t + 0.75;
        if (t < 2.5 / d) return m * (t -= 2.25 / d) * t + 0.9375;
        return m * (t -= 2.625 / d) * t + 0.984375;
    },
    easeInOutBounce: function(t) {
        return t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
    }
};
function isPatternOrGradient(value) {
    if (value && typeof value === "object") {
        var type = value.toString();
        return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
    }
    return false;
}
function color(value) {
    return isPatternOrGradient(value) ? value : new (0, _color.Color)(value);
}
function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : new (0, _color.Color)(value).saturate(0.5).darken(0.1).hexString();
}
var numbers = [
    "x",
    "y",
    "borderWidth",
    "radius",
    "tension"
];
var colors = [
    "color",
    "borderColor",
    "backgroundColor"
];
function applyAnimationsDefaults(defaults) {
    defaults.set("animation", {
        delay: undefined,
        duration: 1000,
        easing: "easeOutQuart",
        fn: undefined,
        from: undefined,
        loop: undefined,
        to: undefined,
        type: undefined
    });
    defaults.describe("animation", {
        _fallback: false,
        _indexable: false,
        _scriptable: function(name) {
            return name !== "onProgress" && name !== "onComplete" && name !== "fn";
        }
    });
    defaults.set("animations", {
        colors: {
            type: "color",
            properties: colors
        },
        numbers: {
            type: "number",
            properties: numbers
        }
    });
    defaults.describe("animations", {
        _fallback: "animation"
    });
    defaults.set("transitions", {
        active: {
            animation: {
                duration: 400
            }
        },
        resize: {
            animation: {
                duration: 0
            }
        },
        show: {
            animations: {
                colors: {
                    from: "transparent"
                },
                visible: {
                    type: "boolean",
                    duration: 0
                }
            }
        },
        hide: {
            animations: {
                colors: {
                    to: "transparent"
                },
                visible: {
                    type: "boolean",
                    easing: "linear",
                    fn: function(v) {
                        return v | 0;
                    }
                }
            }
        }
    });
}
function applyLayoutsDefaults(defaults) {
    defaults.set("layout", {
        autoPadding: true,
        padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }
    });
}
var intlCache = new Map();
function getNumberFormat(locale, options) {
    options = options || {};
    var cacheKey = locale + JSON.stringify(options);
    var formatter = intlCache.get(cacheKey);
    if (!formatter) {
        formatter = new Intl.NumberFormat(locale, options);
        intlCache.set(cacheKey, formatter);
    }
    return formatter;
}
function formatNumber(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
}
var formatters = {
    values: function(value) {
        return isArray(value) ? value : "" + value;
    },
    numeric: function(tickValue, index, ticks) {
        if (tickValue === 0) return "0";
        var locale = this.chart.options.locale;
        var notation;
        var delta = tickValue;
        if (ticks.length > 1) {
            var maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
            if (maxTick < 1e-4 || maxTick > 1e+15) notation = "scientific";
            delta = calculateDelta(tickValue, ticks);
        }
        var logDelta = log10(Math.abs(delta));
        var numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
        var options = {
            notation: notation,
            minimumFractionDigits: numDecimal,
            maximumFractionDigits: numDecimal
        };
        Object.assign(options, this.options.ticks.format);
        return formatNumber(tickValue, locale, options);
    },
    logarithmic: function(tickValue, index, ticks) {
        if (tickValue === 0) return "0";
        var remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
        if ([
            1,
            2,
            3,
            5,
            10,
            15
        ].includes(remain) || index > 0.8 * ticks.length) return formatters.numeric.call(this, tickValue, index, ticks);
        return "";
    }
};
function calculateDelta(tickValue, ticks) {
    var delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) delta = tickValue - Math.floor(tickValue);
    return delta;
}
var Ticks = {
    formatters: formatters
};
function applyScaleDefaults(defaults) {
    defaults.set("scale", {
        display: true,
        offset: false,
        reverse: false,
        beginAtZero: false,
        bounds: "ticks",
        clip: true,
        grace: 0,
        grid: {
            display: true,
            lineWidth: 1,
            drawOnChartArea: true,
            drawTicks: true,
            tickLength: 8,
            tickWidth: function(_ctx, options) {
                return options.lineWidth;
            },
            tickColor: function(_ctx, options) {
                return options.color;
            },
            offset: false
        },
        border: {
            display: true,
            dash: [],
            dashOffset: 0.0,
            width: 1
        },
        title: {
            display: false,
            text: "",
            padding: {
                top: 4,
                bottom: 4
            }
        },
        ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: true,
            autoSkip: true,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: Ticks.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: false,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2
        }
    });
    defaults.route("scale.ticks", "color", "", "color");
    defaults.route("scale.grid", "color", "", "borderColor");
    defaults.route("scale.border", "color", "", "borderColor");
    defaults.route("scale.title", "color", "", "color");
    defaults.describe("scale", {
        _fallback: false,
        _scriptable: function(name) {
            return !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser";
        },
        _indexable: function(name) {
            return name !== "borderDash" && name !== "tickBorderDash" && name !== "dash";
        }
    });
    defaults.describe("scales", {
        _fallback: "scale"
    });
    defaults.describe("scale.ticks", {
        _scriptable: function(name) {
            return name !== "backdropPadding" && name !== "callback";
        },
        _indexable: function(name) {
            return name !== "backdropPadding";
        }
    });
}
var overrides = Object.create(null);
var descriptors = Object.create(null);
function getScope$1(node, key) {
    if (!key) return node;
    var keys = key.split(".");
    for(var i = 0, n = keys.length; i < n; ++i){
        var k = keys[i];
        node = node[k] || (node[k] = Object.create(null));
    }
    return node;
}
function set(root, scope, values) {
    if (typeof scope === "string") return merge(getScope$1(root, scope), values);
    return merge(getScope$1(root, ""), scope);
}
var Defaults = /*#__PURE__*/ function() {
    "use strict";
    function Defaults(_descriptors, _appliers) {
        (0, _classCallCheck._)(this, Defaults);
        this.animation = undefined;
        this.backgroundColor = "rgba(0,0,0,0.1)";
        this.borderColor = "rgba(0,0,0,0.1)";
        this.color = "#666";
        this.datasets = {};
        this.devicePixelRatio = function(context) {
            return context.chart.platform.getDevicePixelRatio();
        };
        this.elements = {};
        this.events = [
            "mousemove",
            "mouseout",
            "click",
            "touchstart",
            "touchmove"
        ];
        this.font = {
            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            size: 12,
            style: "normal",
            lineHeight: 1.2,
            weight: null
        };
        this.hover = {};
        this.hoverBackgroundColor = function(ctx, options) {
            return getHoverColor(options.backgroundColor);
        };
        this.hoverBorderColor = function(ctx, options) {
            return getHoverColor(options.borderColor);
        };
        this.hoverColor = function(ctx, options) {
            return getHoverColor(options.color);
        };
        this.indexAxis = "x";
        this.interaction = {
            mode: "nearest",
            intersect: true,
            includeInvisible: false
        };
        this.maintainAspectRatio = true;
        this.onHover = null;
        this.onClick = null;
        this.parsing = true;
        this.plugins = {};
        this.responsive = true;
        this.scale = undefined;
        this.scales = {};
        this.showLine = true;
        this.drawActiveElementsOnTop = true;
        this.describe(_descriptors);
        this.apply(_appliers);
    }
    (0, _createClass._)(Defaults, [
        {
            key: "set",
            value: function set1(scope, values) {
                return set(this, scope, values);
            }
        },
        {
            key: "get",
            value: function get(scope) {
                return getScope$1(this, scope);
            }
        },
        {
            key: "describe",
            value: function describe(scope, values) {
                return set(descriptors, scope, values);
            }
        },
        {
            key: "override",
            value: function override(scope, values) {
                return set(overrides, scope, values);
            }
        },
        {
            key: "route",
            value: function route(scope, name, targetScope, targetName) {
                var scopeObject = getScope$1(this, scope);
                var targetScopeObject = getScope$1(this, targetScope);
                var privateName = "_" + name;
                var _obj;
                Object.defineProperties(scopeObject, (_obj = {}, (0, _defineProperty._)(_obj, privateName, {
                    value: scopeObject[name],
                    writable: true
                }), (0, _defineProperty._)(_obj, name, {
                    enumerable: true,
                    get: function() {
                        var local = this[privateName];
                        var target = targetScopeObject[targetName];
                        if (isObject(local)) return Object.assign({}, target, local);
                        return valueOrDefault(local, target);
                    },
                    set: function(value) {
                        this[privateName] = value;
                    }
                }), _obj));
            }
        },
        {
            key: "apply",
            value: function apply(appliers) {
                var _this = this;
                appliers.forEach(function(apply) {
                    return apply(_this);
                });
            }
        }
    ]);
    return Defaults;
}();
var defaults = /* #__PURE__ */ new Defaults({
    _scriptable: function(name) {
        return !name.startsWith("on");
    },
    _indexable: function(name) {
        return name !== "events";
    },
    hover: {
        _fallback: "interaction"
    },
    interaction: {
        _scriptable: false,
        _indexable: false
    }
}, [
    applyAnimationsDefaults,
    applyLayoutsDefaults,
    applyScaleDefaults
]);
/**
 * Converts the given font object into a CSS font string.
 * @param font - A font object.
 * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
 * @private
 */ function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) return null;
    return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
/**
 * @private
 */ function _measureText(ctx, data, gc, longest, string) {
    var textWidth = data[string];
    if (!textWidth) {
        textWidth = data[string] = ctx.measureText(string).width;
        gc.push(string);
    }
    if (textWidth > longest) longest = textWidth;
    return longest;
}
/**
 * @private
 */ // eslint-disable-next-line complexity
function _longestText(ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    var data = cache.data = cache.data || {};
    var gc = cache.garbageCollect = cache.garbageCollect || [];
    if (cache.font !== font) {
        data = cache.data = {};
        gc = cache.garbageCollect = [];
        cache.font = font;
    }
    ctx.save();
    ctx.font = font;
    var longest = 0;
    var ilen = arrayOfThings.length;
    var i, j, jlen, thing, nestedThing;
    for(i = 0; i < ilen; i++){
        thing = arrayOfThings[i];
        // Undefined strings and arrays should not be measured
        if (thing !== undefined && thing !== null && !isArray(thing)) longest = _measureText(ctx, data, gc, longest, thing);
        else if (isArray(thing)) // if it is an array lets measure each element
        // to do maybe simplify this function a bit so we can do this more recursively?
        for(j = 0, jlen = thing.length; j < jlen; j++){
            nestedThing = thing[j];
            // Undefined strings and arrays should not be measured
            if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
    }
    ctx.restore();
    var gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
        for(i = 0; i < gcLen; i++)delete data[gc[i]];
        gc.splice(0, gcLen);
    }
    return longest;
}
/**
 * Returns the aligned pixel value to avoid anti-aliasing blur
 * @param chart - The chart instance.
 * @param pixel - A pixel value.
 * @param width - The width of the element.
 * @returns The aligned pixel value.
 * @private
 */ function _alignPixel(chart, pixel, width) {
    var devicePixelRatio = chart.currentDevicePixelRatio;
    var halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
/**
 * Clears the entire canvas.
 */ function clearCanvas(canvas, ctx) {
    ctx = ctx || canvas.getContext("2d");
    ctx.save();
    // canvas.width and canvas.height do not consider the canvas transform,
    // while clearRect does
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
}
function drawPoint(ctx, options, x, y) {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    drawPointLegend(ctx, options, x, y, null);
}
// eslint-disable-next-line complexity
function drawPointLegend(ctx, options, x, y, w) {
    var type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
    var style = options.pointStyle;
    var rotation = options.rotation;
    var radius = options.radius;
    var rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === "object") {
        type = style.toString();
        if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rad);
            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
            ctx.restore();
            return;
        }
    }
    if (isNaN(radius) || radius <= 0) return;
    ctx.beginPath();
    switch(style){
        // Default includes circle
        default:
            if (w) ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
            else ctx.arc(x, y, radius, 0, TAU);
            ctx.closePath();
            break;
        case "triangle":
            width = w ? w / 2 : radius;
            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;
        case "rectRounded":
            // NOTE: the rounded rect implementation changed to use `arc` instead of
            // `quadraticCurveTo` since it generates better results when rect is
            // almost a circle. 0.516 (instead of 0.5) produces results with visually
            // closer proportion to the previous impl and it is inscribed in the
            // circle with `radius`. For more details, see the following PRs:
            // https://github.com/chartjs/Chart.js/issues/5597
            // https://github.com/chartjs/Chart.js/issues/5858
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;
        case "rect":
            if (!rotation) {
                size = Math.SQRT1_2 * radius;
                width = w ? w / 2 : size;
                ctx.rect(x - width, y - size, 2 * width, 2 * size);
                break;
            }
            rad += QUARTER_PI;
        /* falls through */ case "rectRot":
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            ctx.closePath();
            break;
        case "crossRot":
            rad += QUARTER_PI;
        /* falls through */ case "cross":
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            break;
        case "star":
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            rad += QUARTER_PI;
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            break;
        case "line":
            xOffset = w ? w / 2 : Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;
        case "dash":
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
            break;
        case false:
            ctx.closePath();
            break;
    }
    ctx.fill();
    if (options.borderWidth > 0) ctx.stroke();
}
/**
 * Returns true if the point is inside the rectangle
 * @param point - The point to test
 * @param area - The rectangle
 * @param margin - allowed margin
 * @private
 */ function _isPointInArea(point, area, margin) {
    margin = margin || 0.5; // margin - default is to match rounded decimals
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
}
function unclipArea(ctx) {
    ctx.restore();
}
/**
 * @private
 */ function _steppedLineTo(ctx, previous, target, flip, mode) {
    if (!previous) return ctx.lineTo(target.x, target.y);
    if (mode === "middle") {
        var midpoint = (previous.x + target.x) / 2.0;
        ctx.lineTo(midpoint, previous.y);
        ctx.lineTo(midpoint, target.y);
    } else if (mode === "after" !== !!flip) ctx.lineTo(previous.x, target.y);
    else ctx.lineTo(target.x, previous.y);
    ctx.lineTo(target.x, target.y);
}
/**
 * @private
 */ function _bezierCurveTo(ctx, previous, target, flip) {
    if (!previous) return ctx.lineTo(target.x, target.y);
    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function setRenderOpts(ctx, opts) {
    if (opts.translation) ctx.translate(opts.translation[0], opts.translation[1]);
    if (!isNullOrUndef(opts.rotation)) ctx.rotate(opts.rotation);
    if (opts.color) ctx.fillStyle = opts.color;
    if (opts.textAlign) ctx.textAlign = opts.textAlign;
    if (opts.textBaseline) ctx.textBaseline = opts.textBaseline;
}
function decorateText(ctx, x, y, line, opts) {
    if (opts.strikethrough || opts.underline) {
        /**
     * Now that IE11 support has been dropped, we can use more
     * of the TextMetrics object. The actual bounding boxes
     * are unflagged in Chrome, Firefox, Edge, and Safari so they
     * can be safely used.
     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility
     */ var metrics = ctx.measureText(line);
        var left = x - metrics.actualBoundingBoxLeft;
        var right = x + metrics.actualBoundingBoxRight;
        var top = y - metrics.actualBoundingBoxAscent;
        var bottom = y + metrics.actualBoundingBoxDescent;
        var yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
        ctx.strokeStyle = ctx.fillStyle;
        ctx.beginPath();
        ctx.lineWidth = opts.decorationWidth || 2;
        ctx.moveTo(left, yDecoration);
        ctx.lineTo(right, yDecoration);
        ctx.stroke();
    }
}
function drawBackdrop(ctx, opts) {
    var oldColor = ctx.fillStyle;
    ctx.fillStyle = opts.color;
    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
    ctx.fillStyle = oldColor;
}
/**
 * Render text onto the canvas
 */ function renderText(ctx, text, x, y, font) {
    var opts = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    var lines = isArray(text) ? text : [
        text
    ];
    var stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
    var i, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for(i = 0; i < lines.length; ++i){
        line = lines[i];
        if (opts.backdrop) drawBackdrop(ctx, opts.backdrop);
        if (stroke) {
            if (opts.strokeColor) ctx.strokeStyle = opts.strokeColor;
            if (!isNullOrUndef(opts.strokeWidth)) ctx.lineWidth = opts.strokeWidth;
            ctx.strokeText(line, x, y, opts.maxWidth);
        }
        ctx.fillText(line, x, y, opts.maxWidth);
        decorateText(ctx, x, y, line, opts);
        y += Number(font.lineHeight);
    }
    ctx.restore();
}
/**
 * Add a path of a rectangle with rounded corners to the current sub-path
 * @param ctx - Context
 * @param rect - Bounding rect
 */ function addRoundedRectPath(ctx, rect) {
    var x = rect.x, y = rect.y, w = rect.w, h = rect.h, radius = rect.radius;
    // top left arc
    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
    // line from top left to bottom left
    ctx.lineTo(x, y + h - radius.bottomLeft);
    // bottom left arc
    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    // line from bottom left to bottom right
    ctx.lineTo(x + w - radius.bottomRight, y + h);
    // bottom right arc
    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    // line from bottom right to top right
    ctx.lineTo(x + w, y + radius.topRight);
    // top right arc
    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    // line from top right to top left
    ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
/**
 * @alias Chart.helpers.options
 * @namespace
 */ /**
 * Converts the given line height `value` in pixels for a specific font `size`.
 * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
 * @param size - The font size (in pixels) used to resolve relative `value`.
 * @returns The effective line height in pixels (size * 1.2 if value is invalid).
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
 * @since 2.7.0
 */ function toLineHeight(value, size) {
    var matches = ("" + value).match(LINE_HEIGHT);
    if (!matches || matches[1] === "normal") return size * 1.2;
    value = +matches[2];
    switch(matches[3]){
        case "px":
            return value;
        case "%":
            value /= 100;
            break;
    }
    return size * value;
}
var numberOrZero = function(v) {
    return +v || 0;
};
function _readValueToProps(value, props) {
    var ret = {};
    var objProps = isObject(props);
    var keys = objProps ? Object.keys(props) : props;
    var read = isObject(value) ? objProps ? function(prop) {
        return valueOrDefault(value[prop], value[props[prop]]);
    } : function(prop) {
        return value[prop];
    } : function() {
        return value;
    };
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var prop = _step.value;
            ret[prop] = numberOrZero(read(prop));
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return ret;
}
/**
 * Converts the given value into a TRBL object.
 * @param value - If a number, set the value to all TRBL component,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 *  x / y are shorthands for same value for left/right and top/bottom.
 * @returns The padding values (top, right, bottom, left)
 * @since 3.0.0
 */ function toTRBL(value) {
    return _readValueToProps(value, {
        top: "y",
        right: "x",
        bottom: "y",
        left: "x"
    });
}
/**
 * Converts the given value into a TRBL corners object (similar with css border-radius).
 * @param value - If a number, set the value to all TRBL corner components,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)
 * @since 3.0.0
 */ function toTRBLCorners(value) {
    return _readValueToProps(value, [
        "topLeft",
        "topRight",
        "bottomLeft",
        "bottomRight"
    ]);
}
/**
 * Converts the given value into a padding object with pre-computed width/height.
 * @param value - If a number, set the value to all TRBL component,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 *  x / y are shorthands for same value for left/right and top/bottom.
 * @returns The padding values (top, right, bottom, left, width, height)
 * @since 2.7.0
 */ function toPadding(value) {
    var obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
}
/**
 * Parses font options and returns the font object.
 * @param options - A object that contains font options to be parsed.
 * @param fallback - A object that contains fallback font options.
 * @return The font object.
 * @private
 */ function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults.font;
    var size = valueOrDefault(options.size, fallback.size);
    if (typeof size === "string") size = parseInt(size, 10);
    var style = valueOrDefault(options.style, fallback.style);
    if (style && !("" + style).match(FONT_STYLE)) {
        console.warn('Invalid font style specified: "' + style + '"');
        style = undefined;
    }
    var font = {
        family: valueOrDefault(options.family, fallback.family),
        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
        size: size,
        style: style,
        weight: valueOrDefault(options.weight, fallback.weight),
        string: ""
    };
    font.string = toFontString(font);
    return font;
}
/**
 * Evaluates the given `inputs` sequentially and returns the first defined value.
 * @param inputs - An array of values, falling back to the last value.
 * @param context - If defined and the current value is a function, the value
 * is called with `context` as first argument and the result becomes the new input.
 * @param index - If defined and the current value is an array, the value
 * at `index` become the new input.
 * @param info - object to return information about resolution in
 * @param info.cacheable - Will be set to `false` if option is not cacheable.
 * @since 2.7.0
 */ function resolve(inputs, context, index, info) {
    var cacheable = true;
    var i, ilen, value;
    for(i = 0, ilen = inputs.length; i < ilen; ++i){
        value = inputs[i];
        if (value === undefined) continue;
        if (context !== undefined && typeof value === "function") {
            value = value(context);
            cacheable = false;
        }
        if (index !== undefined && isArray(value)) {
            value = value[index % value.length];
            cacheable = false;
        }
        if (value !== undefined) {
            if (info && !cacheable) info.cacheable = false;
            return value;
        }
    }
}
/**
 * @param minmax
 * @param grace
 * @param beginAtZero
 * @private
 */ function _addGrace(minmax, grace, beginAtZero) {
    var min = minmax.min, max = minmax.max;
    var change = toDimension(grace, (max - min) / 2);
    var keepZero = function(value, add) {
        return beginAtZero && value === 0 ? 0 : value + add;
    };
    return {
        min: keepZero(min, -Math.abs(change)),
        max: keepZero(max, change)
    };
}
function createContext(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
}
/**
 * Creates a Proxy for resolving raw values for options.
 * @param scopes - The option scopes to look for values, in resolution order
 * @param prefixes - The prefixes for values, in resolution order.
 * @param rootScopes - The root option scopes
 * @param fallback - Parent scopes fallback
 * @param getTarget - callback for getting the target for changed values
 * @returns Proxy
 * @private
 */ function _createResolver(scopes) {
    var prefixes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [
        ""
    ], rootScopes = arguments.length > 2 ? arguments[2] : void 0, fallback = arguments.length > 3 ? arguments[3] : void 0, getTarget = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : function() {
        return scopes[0];
    };
    var finalRootScopes = rootScopes || scopes;
    if (typeof fallback === "undefined") fallback = _resolve("_fallback", scopes);
    var _obj;
    var cache = (_obj = {}, (0, _defineProperty._)(_obj, Symbol.toStringTag, "Object"), (0, _defineProperty._)(_obj, "_cacheable", true), (0, _defineProperty._)(_obj, "_scopes", scopes), (0, _defineProperty._)(_obj, "_rootScopes", finalRootScopes), (0, _defineProperty._)(_obj, "_fallback", fallback), (0, _defineProperty._)(_obj, "_getTarget", getTarget), (0, _defineProperty._)(_obj, "override", function(scope) {
        return _createResolver([
            scope
        ].concat((0, _toConsumableArray._)(scopes)), prefixes, finalRootScopes, fallback);
    }), _obj);
    return new Proxy(cache, {
        /**
     * A trap for the delete operator.
     */ deleteProperty: function(target, prop) {
            delete target[prop]; // remove from cache
            delete target._keys; // remove cached keys
            delete scopes[0][prop]; // remove from top level scope
            return true;
        },
        /**
     * A trap for getting property values.
     */ get: function(target, prop) {
            return _cached(target, prop, function() {
                return _resolveWithPrefixes(prop, prefixes, scopes, target);
            });
        },
        /**
     * A trap for Object.getOwnPropertyDescriptor.
     * Also used by Object.hasOwnProperty.
     */ getOwnPropertyDescriptor: function(target, prop) {
            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
        },
        /**
     * A trap for Object.getPrototypeOf.
     */ getPrototypeOf: function() {
            return Reflect.getPrototypeOf(scopes[0]);
        },
        /**
     * A trap for the in operator.
     */ has: function(target, prop) {
            return getKeysFromAllScopes(target).includes(prop);
        },
        /**
     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
     */ ownKeys: function(target) {
            return getKeysFromAllScopes(target);
        },
        /**
     * A trap for setting property values.
     */ set: function(target, prop, value) {
            var storage = target._storage || (target._storage = getTarget());
            target[prop] = storage[prop] = value; // set to top level scope + cache
            delete target._keys; // remove cached keys
            return true;
        }
    });
}
/**
 * Returns an Proxy for resolving option values with context.
 * @param proxy - The Proxy returned by `_createResolver`
 * @param context - Context object for scriptable/indexable options
 * @param subProxy - The proxy provided for scriptable options
 * @param descriptorDefaults - Defaults for descriptors
 * @private
 */ function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    var cache = {
        _cacheable: false,
        _proxy: proxy,
        _context: context,
        _subProxy: subProxy,
        _stack: new Set(),
        _descriptors: _descriptors(proxy, descriptorDefaults),
        setContext: function(ctx) {
            return _attachContext(proxy, ctx, subProxy, descriptorDefaults);
        },
        override: function(scope) {
            return _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults);
        }
    };
    return new Proxy(cache, {
        /**
     * A trap for the delete operator.
     */ deleteProperty: function(target, prop) {
            delete target[prop]; // remove from cache
            delete proxy[prop]; // remove from proxy
            return true;
        },
        /**
     * A trap for getting property values.
     */ get: function(target, prop, receiver) {
            return _cached(target, prop, function() {
                return _resolveWithContext(target, prop, receiver);
            });
        },
        /**
     * A trap for Object.getOwnPropertyDescriptor.
     * Also used by Object.hasOwnProperty.
     */ getOwnPropertyDescriptor: function(target, prop) {
            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
                enumerable: true,
                configurable: true
            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);
        },
        /**
     * A trap for Object.getPrototypeOf.
     */ getPrototypeOf: function() {
            return Reflect.getPrototypeOf(proxy);
        },
        /**
     * A trap for the in operator.
     */ has: function(target, prop) {
            return Reflect.has(proxy, prop);
        },
        /**
     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
     */ ownKeys: function() {
            return Reflect.ownKeys(proxy);
        },
        /**
     * A trap for setting property values.
     */ set: function(target, prop, value) {
            proxy[prop] = value; // set to proxy
            delete target[prop]; // remove from cache
            return true;
        }
    });
}
/**
 * @private
 */ function _descriptors(proxy) {
    var defaults = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        scriptable: true,
        indexable: true
    };
    var _proxy__scriptable = proxy._scriptable, _scriptable = _proxy__scriptable === void 0 ? defaults.scriptable : _proxy__scriptable, _proxy__indexable = proxy._indexable, _indexable = _proxy__indexable === void 0 ? defaults.indexable : _proxy__indexable, _proxy__allKeys = proxy._allKeys, _allKeys = _proxy__allKeys === void 0 ? defaults.allKeys : _proxy__allKeys;
    return {
        allKeys: _allKeys,
        scriptable: _scriptable,
        indexable: _indexable,
        isScriptable: isFunction(_scriptable) ? _scriptable : function() {
            return _scriptable;
        },
        isIndexable: isFunction(_indexable) ? _indexable : function() {
            return _indexable;
        }
    };
}
var readKey = function(prefix, name) {
    return prefix ? prefix + _capitalize(name) : name;
};
var needsSubResolver = function(prop, value) {
    return isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
};
function _cached(target, prop, resolve) {
    if (Object.prototype.hasOwnProperty.call(target, prop)) return target[prop];
    var value = resolve();
    // cache the resolved value
    target[prop] = value;
    return value;
}
function _resolveWithContext(target, prop, receiver) {
    var _proxy = target._proxy, _context = target._context, _subProxy = target._subProxy, descriptors = target._descriptors;
    var value = _proxy[prop]; // resolve from proxy
    // resolve with context
    if (isFunction(value) && descriptors.isScriptable(prop)) value = _resolveScriptable(prop, value, target, receiver);
    if (isArray(value) && value.length) value = _resolveArray(prop, value, target, descriptors.isIndexable);
    if (needsSubResolver(prop, value)) // if the resolved value is an object, create a sub resolver for it
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
    return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
    var _proxy = target._proxy, _context = target._context, _subProxy = target._subProxy, _stack = target._stack;
    if (_stack.has(prop)) throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
    _stack.add(prop);
    var value = getValue(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) // When scriptable option returns an object, create a resolver on that.
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    return value;
}
function _resolveArray(prop, value, target, isIndexable) {
    var _proxy = target._proxy, _context = target._context, _subProxy = target._subProxy, descriptors = target._descriptors;
    if (typeof _context.index !== "undefined" && isIndexable(prop)) return value[_context.index % value.length];
    else if (isObject(value[0])) {
        // Array of objects, return array or resolvers
        var arr = value;
        var scopes = _proxy._scopes.filter(function(s) {
            return s !== arr;
        });
        value = [];
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = arr[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var item = _step.value;
                var resolver = createSubResolver(scopes, _proxy, prop, item);
                value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
    return value;
}
function resolveFallback(fallback, prop, value) {
    return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = function(key, parent) {
    return key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : undefined;
};
function addScopes(set, parentScopes, key, parentFallback, value) {
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = parentScopes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var parent = _step.value;
            var scope = getScope(key, parent);
            if (scope) {
                set.add(scope);
                var fallback = resolveFallback(scope._fallback, key, value);
                if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) // When we reach the descriptor that defines a new _fallback, return that.
                // The fallback will resume to that new scope.
                return fallback;
            } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) // Fallback to `false` results to `false`, when falling back to different key.
            // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`
            return null;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
    var rootScopes = resolver._rootScopes;
    var fallback = resolveFallback(resolver._fallback, prop, value);
    var allScopes = (0, _toConsumableArray._)(parentScopes).concat((0, _toConsumableArray._)(rootScopes));
    var set = new Set();
    set.add(value);
    var key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);
    if (key === null) return false;
    if (typeof fallback !== "undefined" && fallback !== prop) {
        key = addScopesFromKey(set, allScopes, fallback, key, value);
        if (key === null) return false;
    }
    return _createResolver(Array.from(set), [
        ""
    ], rootScopes, fallback, function() {
        return subGetTarget(resolver, prop, value);
    });
}
function addScopesFromKey(set, allScopes, key, fallback, item) {
    while(key)key = addScopes(set, allScopes, key, fallback, item);
    return key;
}
function subGetTarget(resolver, prop, value) {
    var parent = resolver._getTarget();
    if (!(prop in parent)) parent[prop] = {};
    var target = parent[prop];
    if (isArray(target) && isObject(value)) // For array of objects, the object is used to store updated values
    return value;
    return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    var value;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = prefixes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var prefix = _step.value;
            value = _resolve(readKey(prefix, prop), scopes);
            if (typeof value !== "undefined") return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}
function _resolve(key, scopes) {
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = scopes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var scope = _step.value;
            if (!scope) continue;
            var value = scope[key];
            if (typeof value !== "undefined") return value;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}
function getKeysFromAllScopes(target) {
    var keys = target._keys;
    if (!keys) keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    return keys;
}
function resolveKeysFromAllScopes(scopes) {
    var set = new Set();
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined, _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
    try {
        for(var _iterator = scopes[Symbol.iterator](), _step; !(_iteratorNormalCompletion1 = (_step = _iterator.next()).done); _iteratorNormalCompletion1 = true){
            var scope = _step.value;
            try {
                for(var _iterator1 = Object.keys(scope).filter(function(k) {
                    return !k.startsWith("_");
                })[Symbol.iterator](), _step1; !(_iteratorNormalCompletion = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion = true){
                    var key = _step1.value;
                    set.add(key);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator1.return != null) {
                        _iterator1.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    } catch (err) {
        _didIteratorError1 = true;
        _iteratorError1 = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion1 && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError1) {
                throw _iteratorError1;
            }
        }
    }
    return Array.from(set);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
    var iScale = meta.iScale;
    var _this__parsing = this._parsing, _this__parsing_key = _this__parsing.key, key = _this__parsing_key === void 0 ? "r" : _this__parsing_key;
    var parsed = new Array(count);
    var i, ilen, index, item;
    for(i = 0, ilen = count; i < ilen; ++i){
        index = i + start;
        item = data[index];
        parsed[i] = {
            r: iScale.parse(resolveObjectKey(item, key), index)
        };
    }
    return parsed;
}
var EPSILON = Number.EPSILON || 1e-14;
var getPoint = function(points, i) {
    return i < points.length && !points[i].skip && points[i];
};
var getValueAxis = function(indexAxis) {
    return indexAxis === "x" ? "y" : "x";
};
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
    // Props to Rob Spencer at scaled innovation for his post on splining between points
    // http://scaledinnovation.com/analytics/splines/aboutSplines.html
    // This function must also respect "skipped" points
    var previous = firstPoint.skip ? middlePoint : firstPoint;
    var current = middlePoint;
    var next = afterPoint.skip ? middlePoint : afterPoint;
    var d01 = distanceBetweenPoints(current, previous);
    var d12 = distanceBetweenPoints(next, current);
    var s01 = d01 / (d01 + d12);
    var s12 = d12 / (d01 + d12);
    // If all points are the same, s01 & s02 will be inf
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    var fa = t * s01; // scaling factor for triangle Ta
    var fb = t * s12;
    return {
        previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
        },
        next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
        }
    };
}
/**
 * Adjust tangents to ensure monotonic properties
 */ function monotoneAdjust(points, deltaK, mK) {
    var pointsLen = points.length;
    var alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    var pointAfter = getPoint(points, 0);
    for(var i = 0; i < pointsLen - 1; ++i){
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent || !pointAfter) continue;
        if (almostEquals(deltaK[i], 0, EPSILON)) {
            mK[i] = mK[i + 1] = 0;
            continue;
        }
        alphaK = mK[i] / deltaK[i];
        betaK = mK[i + 1] / deltaK[i];
        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
        if (squaredMagnitude <= 9) continue;
        tauK = 3 / Math.sqrt(squaredMagnitude);
        mK[i] = alphaK * tauK * deltaK[i];
        mK[i + 1] = betaK * tauK * deltaK[i];
    }
}
function monotoneCompute(points, mK) {
    var indexAxis = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "x";
    var valueAxis = getValueAxis(indexAxis);
    var pointsLen = points.length;
    var delta, pointBefore, pointCurrent;
    var pointAfter = getPoint(points, 0);
    for(var i = 0; i < pointsLen; ++i){
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) continue;
        var iPixel = pointCurrent[indexAxis];
        var vPixel = pointCurrent[valueAxis];
        if (pointBefore) {
            delta = (iPixel - pointBefore[indexAxis]) / 3;
            pointCurrent["cp1".concat(indexAxis)] = iPixel - delta;
            pointCurrent["cp1".concat(valueAxis)] = vPixel - delta * mK[i];
        }
        if (pointAfter) {
            delta = (pointAfter[indexAxis] - iPixel) / 3;
            pointCurrent["cp2".concat(indexAxis)] = iPixel + delta;
            pointCurrent["cp2".concat(valueAxis)] = vPixel + delta * mK[i];
        }
    }
}
/**
 * This function calculates Bzier control points in a similar way than |splineCurve|,
 * but preserves monotonicity of the provided data and ensures no local extremums are added
 * between the dataset discrete points due to the interpolation.
 * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
 */ function splineCurveMonotone(points) {
    var indexAxis = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x";
    var valueAxis = getValueAxis(indexAxis);
    var pointsLen = points.length;
    var deltaK = Array(pointsLen).fill(0);
    var mK = Array(pointsLen);
    // Calculate slopes (deltaK) and initialize tangents (mK)
    var i, pointBefore, pointCurrent;
    var pointAfter = getPoint(points, 0);
    for(i = 0; i < pointsLen; ++i){
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) continue;
        if (pointAfter) {
            var slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0
            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
        }
        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
    return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
    var i, ilen, point, inArea, inAreaPrev;
    var inAreaNext = _isPointInArea(points[0], area);
    for(i = 0, ilen = points.length; i < ilen; ++i){
        inAreaPrev = inArea;
        inArea = inAreaNext;
        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
        if (!inArea) continue;
        point = points[i];
        if (inAreaPrev) {
            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
        }
        if (inAreaNext) {
            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
        }
    }
}
/**
 * @private
 */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
    var i, ilen, point, controlPoints;
    // Only consider points that are drawn in case the spanGaps option is used
    if (options.spanGaps) points = points.filter(function(pt) {
        return !pt.skip;
    });
    if (options.cubicInterpolationMode === "monotone") splineCurveMonotone(points, indexAxis);
    else {
        var prev = loop ? points[points.length - 1] : points[0];
        for(i = 0, ilen = points.length; i < ilen; ++i){
            point = points[i];
            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
            point.cp1x = controlPoints.previous.x;
            point.cp1y = controlPoints.previous.y;
            point.cp2x = controlPoints.next.x;
            point.cp2y = controlPoints.next.y;
            prev = point;
        }
    }
    if (options.capBezierPoints) capBezierPoints(points, area);
}
/**
 * Note: typedefs are auto-exported, so use a made-up `dom` namespace where
 * necessary to avoid duplicates with `export * from './helpers`; see
 * https://github.com/microsoft/TypeScript/issues/46011
 * @typedef { import('../core/core.controller.js').default } dom.Chart
 * @typedef { import('../../types').ChartEvent } ChartEvent
 */ /**
 * @private
 */ function _isDomSupported() {
    return typeof window !== "undefined" && typeof document !== "undefined";
}
/**
 * @private
 */ function _getParentNode(domNode) {
    var parent = domNode.parentNode;
    if (parent && parent.toString() === "[object ShadowRoot]") parent = parent.host;
    return parent;
}
/**
 * convert max-width/max-height values that may be percentages into a number
 * @private
 */ function parseMaxStyle(styleValue, node, parentProperty) {
    var valueInPixels;
    if (typeof styleValue === "string") {
        valueInPixels = parseInt(styleValue, 10);
        if (styleValue.indexOf("%") !== -1) // percentage * size in dimension
        valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    } else valueInPixels = styleValue;
    return valueInPixels;
}
var getComputedStyle = function(element) {
    return element.ownerDocument.defaultView.getComputedStyle(element, null);
};
function getStyle(el, property) {
    return getComputedStyle(el).getPropertyValue(property);
}
var positions = [
    "top",
    "right",
    "bottom",
    "left"
];
function getPositionedStyle(styles, style, suffix) {
    var result = {};
    suffix = suffix ? "-" + suffix : "";
    for(var i = 0; i < 4; i++){
        var pos = positions[i];
        result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
}
var useOffsetPos = function(x, y, target) {
    return (x > 0 || y > 0) && (!target || !target.shadowRoot);
};
/**
 * @param e
 * @param canvas
 * @returns Canvas position
 */ function getCanvasPosition(e, canvas) {
    var touches = e.touches;
    var source = touches && touches.length ? touches[0] : e;
    var offsetX = source.offsetX, offsetY = source.offsetY;
    var box = false;
    var x, y;
    if (useOffsetPos(offsetX, offsetY, e.target)) {
        x = offsetX;
        y = offsetY;
    } else {
        var rect = canvas.getBoundingClientRect();
        x = source.clientX - rect.left;
        y = source.clientY - rect.top;
        box = true;
    }
    return {
        x: x,
        y: y,
        box: box
    };
}
/**
 * Gets an event's x, y coordinates, relative to the chart area
 * @param event
 * @param chart
 * @returns x and y coordinates of the event
 */ function getRelativePosition(event, chart) {
    if ("native" in event) return event;
    var canvas = chart.canvas, currentDevicePixelRatio = chart.currentDevicePixelRatio;
    var style = getComputedStyle(canvas);
    var borderBox = style.boxSizing === "border-box";
    var paddings = getPositionedStyle(style, "padding");
    var borders = getPositionedStyle(style, "border", "width");
    var _getCanvasPosition = getCanvasPosition(event, canvas), x = _getCanvasPosition.x, y = _getCanvasPosition.y, box = _getCanvasPosition.box;
    var xOffset = paddings.left + (box && borders.left);
    var yOffset = paddings.top + (box && borders.top);
    var width = chart.width, height = chart.height;
    if (borderBox) {
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
    }
    return {
        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
}
function getContainerSize(canvas, width, height) {
    var maxWidth, maxHeight;
    if (width === undefined || height === undefined) {
        var container = _getParentNode(canvas);
        if (!container) {
            width = canvas.clientWidth;
            height = canvas.clientHeight;
        } else {
            var rect = container.getBoundingClientRect(); // this is the border box of the container
            var containerStyle = getComputedStyle(container);
            var containerBorder = getPositionedStyle(containerStyle, "border", "width");
            var containerPadding = getPositionedStyle(containerStyle, "padding");
            width = rect.width - containerPadding.width - containerBorder.width;
            height = rect.height - containerPadding.height - containerBorder.height;
            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
        }
    }
    return {
        width: width,
        height: height,
        maxWidth: maxWidth || INFINITY,
        maxHeight: maxHeight || INFINITY
    };
}
var round1 = function(v) {
    return Math.round(v * 10) / 10;
};
// eslint-disable-next-line complexity
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    var style = getComputedStyle(canvas);
    var margins = getPositionedStyle(style, "margin");
    var maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
    var maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
    var containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    var width = containerSize.width, height = containerSize.height;
    if (style.boxSizing === "content-box") {
        var borders = getPositionedStyle(style, "border", "width");
        var paddings = getPositionedStyle(style, "padding");
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) // https://github.com/chartjs/Chart.js/issues/4659
    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)
    height = round1(width / 2);
    var maintainHeight = bbWidth !== undefined || bbHeight !== undefined;
    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
        height = containerSize.height;
        width = round1(Math.floor(height * aspectRatio));
    }
    return {
        width: width,
        height: height
    };
}
/**
 * @param chart
 * @param forceRatio
 * @param forceStyle
 * @returns True if the canvas context size or transformation has changed.
 */ function retinaScale(chart, forceRatio, forceStyle) {
    var pixelRatio = forceRatio || 1;
    var deviceHeight = Math.floor(chart.height * pixelRatio);
    var deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = Math.floor(chart.height);
    chart.width = Math.floor(chart.width);
    var canvas = chart.canvas;
    // If no style has been set on the canvas, the render size is used as display size,
    // making the chart visually bigger, so let's enforce it to the "correct" values.
    // See https://github.com/chartjs/Chart.js/issues/3575
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
        canvas.style.height = "".concat(chart.height, "px");
        canvas.style.width = "".concat(chart.width, "px");
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
        chart.currentDevicePixelRatio = pixelRatio;
        canvas.height = deviceHeight;
        canvas.width = deviceWidth;
        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        return true;
    }
    return false;
}
/**
 * Detects support for options object argument in addEventListener.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
 * @private
 */ var supportsEventListenerOptions = function() {
    var passiveSupported = false;
    try {
        var options = {
            get passive () {
                passiveSupported = true;
                return false;
            }
        };
        if (_isDomSupported()) {
            window.addEventListener("test", null, options);
            window.removeEventListener("test", null, options);
        }
    } catch (e) {
    // continue regardless of error
    }
    return passiveSupported;
}();
/**
 * The "used" size is the final value of a dimension property after all calculations have
 * been performed. This method uses the computed style of `element` but returns undefined
 * if the computed style is not expressed in pixels. That can happen in some cases where
 * `element` has a size relative to its parent and this last one is not yet displayed,
 * for example because of `display: none` on a parent node.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
 * @returns Size in pixels or undefined if unknown.
 */ function readUsedSize(element, property) {
    var value = getStyle(element, property);
    var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? +matches[1] : undefined;
}
/**
 * @private
 */ function _pointInLine(p1, p2, t, mode) {
    return {
        x: p1.x + t * (p2.x - p1.x),
        y: p1.y + t * (p2.y - p1.y)
    };
}
/**
 * @private
 */ function _steppedInterpolation(p1, p2, t, mode) {
    return {
        x: p1.x + t * (p2.x - p1.x),
        y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
    };
}
/**
 * @private
 */ function _bezierInterpolation(p1, p2, t, mode) {
    var cp1 = {
        x: p1.cp2x,
        y: p1.cp2y
    };
    var cp2 = {
        x: p2.cp1x,
        y: p2.cp1y
    };
    var a = _pointInLine(p1, cp1, t);
    var b = _pointInLine(cp1, cp2, t);
    var c = _pointInLine(cp2, p2, t);
    var d = _pointInLine(a, b, t);
    var e = _pointInLine(b, c, t);
    return _pointInLine(d, e, t);
}
var getRightToLeftAdapter = function getRightToLeftAdapter(rectX, width) {
    return {
        x: function(x) {
            return rectX + rectX + width - x;
        },
        setWidth: function(w) {
            width = w;
        },
        textAlign: function(align) {
            if (align === "center") return align;
            return align === "right" ? "left" : "right";
        },
        xPlus: function(x, value) {
            return x - value;
        },
        leftForLtr: function(x, itemWidth) {
            return x - itemWidth;
        }
    };
};
var getLeftToRightAdapter = function getLeftToRightAdapter() {
    return {
        x: function(x) {
            return x;
        },
        setWidth: function(w) {},
        textAlign: function(align) {
            return align;
        },
        xPlus: function(x, value) {
            return x + value;
        },
        leftForLtr: function(x, _itemWidth) {
            return x;
        }
    };
};
function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
    var style, original;
    if (direction === "ltr" || direction === "rtl") {
        style = ctx.canvas.style;
        original = [
            style.getPropertyValue("direction"),
            style.getPropertyPriority("direction")
        ];
        style.setProperty("direction", direction, "important");
        ctx.prevTextDirection = original;
    }
}
function restoreTextDirection(ctx, original) {
    if (original !== undefined) {
        delete ctx.prevTextDirection;
        ctx.canvas.style.setProperty("direction", original[0], original[1]);
    }
}
function propertyFn(property) {
    if (property === "angle") return {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle
    };
    return {
        between: _isBetween,
        compare: function(a, b) {
            return a - b;
        },
        normalize: function(x) {
            return x;
        }
    };
}
function normalizeSegment(param) {
    var start = param.start, end = param.end, count = param.count, loop = param.loop, style = param.style;
    return {
        start: start % count,
        end: end % count,
        loop: loop && (end - start + 1) % count === 0,
        style: style
    };
}
function getSegment(segment, points, bounds) {
    var property = bounds.property, startBound = bounds.start, endBound = bounds.end;
    var _propertyFn = propertyFn(property), between = _propertyFn.between, normalize = _propertyFn.normalize;
    var count = points.length;
    var start = segment.start, end = segment.end, loop = segment.loop;
    var i, ilen;
    if (loop) {
        start += count;
        end += count;
        for(i = 0, ilen = count; i < ilen; ++i){
            if (!between(normalize(points[start % count][property]), startBound, endBound)) break;
            start--;
            end--;
        }
        start %= count;
        end %= count;
    }
    if (end < start) end += count;
    return {
        start: start,
        end: end,
        loop: loop,
        style: segment.style
    };
}
function _boundSegment(segment, points, bounds) {
    if (!bounds) return [
        segment
    ];
    var property = bounds.property, startBound = bounds.start, endBound = bounds.end;
    var count = points.length;
    var _propertyFn = propertyFn(property), compare = _propertyFn.compare, between = _propertyFn.between, normalize = _propertyFn.normalize;
    var _getSegment = getSegment(segment, points, bounds), start = _getSegment.start, end = _getSegment.end, loop = _getSegment.loop, style = _getSegment.style;
    var result = [];
    var inside = false;
    var subStart = null;
    var value, point, prevValue;
    var startIsBefore = function() {
        return between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
    };
    var endIsBefore = function() {
        return compare(endBound, value) === 0 || between(endBound, prevValue, value);
    };
    var shouldStart = function() {
        return inside || startIsBefore();
    };
    var shouldStop = function() {
        return !inside || endIsBefore();
    };
    for(var i = start, prev = start; i <= end; ++i){
        point = points[i % count];
        if (point.skip) continue;
        value = normalize(point[property]);
        if (value === prevValue) continue;
        inside = between(value, startBound, endBound);
        if (subStart === null && shouldStart()) subStart = compare(value, startBound) === 0 ? i : prev;
        if (subStart !== null && shouldStop()) {
            result.push(normalizeSegment({
                start: subStart,
                end: i,
                loop: loop,
                count: count,
                style: style
            }));
            subStart = null;
        }
        prev = i;
        prevValue = value;
    }
    if (subStart !== null) result.push(normalizeSegment({
        start: subStart,
        end: end,
        loop: loop,
        count: count,
        style: style
    }));
    return result;
}
function _boundSegments(line, bounds) {
    var result = [];
    var segments = line.segments;
    for(var i = 0; i < segments.length; i++){
        var _result;
        var sub = _boundSegment(segments[i], line.points, bounds);
        if (sub.length) (_result = result).push.apply(_result, (0, _toConsumableArray._)(sub));
    }
    return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
    var start = 0;
    var end = count - 1;
    if (loop && !spanGaps) while(start < count && !points[start].skip)start++;
    while(start < count && points[start].skip)start++;
    start %= count;
    if (loop) end += start;
    while(end > start && points[end % count].skip)end--;
    end %= count;
    return {
        start: start,
        end: end
    };
}
function solidSegments(points, start, max, loop) {
    var count = points.length;
    var result = [];
    var last = start;
    var prev = points[start];
    var end;
    for(end = start + 1; end <= max; ++end){
        var cur = points[end % count];
        if (cur.skip || cur.stop) {
            if (!prev.skip) {
                loop = false;
                result.push({
                    start: start % count,
                    end: (end - 1) % count,
                    loop: loop
                });
                start = last = cur.stop ? end : null;
            }
        } else {
            last = end;
            if (prev.skip) start = end;
        }
        prev = cur;
    }
    if (last !== null) result.push({
        start: start % count,
        end: last % count,
        loop: loop
    });
    return result;
}
function _computeSegments(line, segmentOptions) {
    var points = line.points;
    var spanGaps = line.options.spanGaps;
    var count = points.length;
    if (!count) return [];
    var loop = !!line._loop;
    var _findStartAndEnd = findStartAndEnd(points, count, loop, spanGaps), start = _findStartAndEnd.start, end = _findStartAndEnd.end;
    if (spanGaps === true) return splitByStyles(line, [
        {
            start: start,
            end: end,
            loop: loop
        }
    ], points, segmentOptions);
    var max = end < start ? end + count : end;
    var completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) return segments;
    return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
    var chartContext = line._chart.getContext();
    var baseStyle = readStyle(line.options);
    var datasetIndex = line._datasetIndex, spanGaps = line.options.spanGaps;
    var count = points.length;
    var result = [];
    var prevStyle = baseStyle;
    var start = segments[0].start;
    var i = start;
    function addStyle(s, e, l, st) {
        var dir = spanGaps ? -1 : 1;
        if (s === e) return;
        s += count;
        while(points[s % count].skip)s -= dir;
        while(points[e % count].skip)e += dir;
        if (s % count !== e % count) {
            result.push({
                start: s % count,
                end: e % count,
                loop: l,
                style: st
            });
            prevStyle = st;
            start = e % count;
        }
    }
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = segments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var segment = _step.value;
            start = spanGaps ? start : segment.start;
            var prev = points[start % count];
            var style = void 0;
            for(i = start + 1; i <= segment.end; i++){
                var pt = points[i % count];
                style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                    type: "segment",
                    p0: prev,
                    p1: pt,
                    p0DataIndex: (i - 1) % count,
                    p1DataIndex: i % count,
                    datasetIndex: datasetIndex
                })));
                if (styleChanged(style, prevStyle)) addStyle(start, i - 1, segment.loop, prevStyle);
                prev = pt;
                prevStyle = style;
            }
            if (start < i - 1) addStyle(start, i - 1, segment.loop, prevStyle);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return result;
}
function readStyle(options) {
    return {
        backgroundColor: options.backgroundColor,
        borderCapStyle: options.borderCapStyle,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderJoinStyle: options.borderJoinStyle,
        borderWidth: options.borderWidth,
        borderColor: options.borderColor
    };
}
function styleChanged(style, prevStyle) {
    if (!prevStyle) return false;
    var cache = [];
    var replacer = function replacer(key, value) {
        if (!isPatternOrGradient(value)) return value;
        if (!cache.includes(value)) cache.push(value);
        return cache.indexOf(value);
    };
    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}

},{"@swc/helpers/_/_class_call_check":"70JET","@swc/helpers/_/_create_class":"9CG3U","@swc/helpers/_/_define_property":"6dEyb","@swc/helpers/_/_to_consumable_array":"ig3r6","@kurkle/color":"1Q4kk","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"1Q4kk":[function(require,module,exports) {
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Color", function() {
    return Color;
});
parcelHelpers.export(exports, "b2n", function() {
    return b2n;
});
parcelHelpers.export(exports, "b2p", function() {
    return b2p;
});
parcelHelpers.export(exports, "default", function() {
    return index_esm;
});
parcelHelpers.export(exports, "hexParse", function() {
    return hexParse;
});
parcelHelpers.export(exports, "hexString", function() {
    return hexString;
});
parcelHelpers.export(exports, "hsl2rgb", function() {
    return hsl2rgb;
});
parcelHelpers.export(exports, "hslString", function() {
    return hslString;
});
parcelHelpers.export(exports, "hsv2rgb", function() {
    return hsv2rgb;
});
parcelHelpers.export(exports, "hueParse", function() {
    return hueParse;
});
parcelHelpers.export(exports, "hwb2rgb", function() {
    return hwb2rgb;
});
parcelHelpers.export(exports, "lim", function() {
    return lim;
});
parcelHelpers.export(exports, "n2b", function() {
    return n2b;
});
parcelHelpers.export(exports, "n2p", function() {
    return n2p;
});
parcelHelpers.export(exports, "nameParse", function() {
    return nameParse;
});
parcelHelpers.export(exports, "p2b", function() {
    return p2b;
});
parcelHelpers.export(exports, "rgb2hsl", function() {
    return rgb2hsl;
});
parcelHelpers.export(exports, "rgbParse", function() {
    return rgbParse;
});
parcelHelpers.export(exports, "rgbString", function() {
    return rgbString;
});
parcelHelpers.export(exports, "rotate", function() {
    return rotate;
});
parcelHelpers.export(exports, "round", function() {
    return round;
});
var _classCallCheck = require("@swc/helpers/_/_class_call_check");
var _createClass = require("@swc/helpers/_/_create_class");
var _typeOf = require("@swc/helpers/_/_type_of");
function round(v) {
    return v + 0.5 | 0;
}
var lim = function(v, l, h) {
    return Math.max(Math.min(v, h), l);
};
function p2b(v) {
    return lim(round(v * 2.55), 0, 255);
}
function b2p(v) {
    return lim(round(v / 2.55), 0, 100);
}
function n2b(v) {
    return lim(round(v * 255), 0, 255);
}
function b2n(v) {
    return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
    return lim(round(v * 100), 0, 100);
}
var map$1 = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
};
var hex = Array.from("0123456789ABCDEF");
var h1 = function(b) {
    return hex[b & 0xF];
};
var h2 = function(b) {
    return hex[(b & 0xF0) >> 4] + hex[b & 0xF];
};
var eq = function(b) {
    return (b & 0xF0) >> 4 === (b & 0xF);
};
var isShort = function(v) {
    return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
};
function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === "#") {
        if (len === 4 || len === 5) ret = {
            r: 255 & map$1[str[1]] * 17,
            g: 255 & map$1[str[2]] * 17,
            b: 255 & map$1[str[3]] * 17,
            a: len === 5 ? map$1[str[4]] * 17 : 255
        };
        else if (len === 7 || len === 9) ret = {
            r: map$1[str[1]] << 4 | map$1[str[2]],
            g: map$1[str[3]] << 4 | map$1[str[4]],
            b: map$1[str[5]] << 4 | map$1[str[6]],
            a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
        };
    }
    return ret;
}
var alpha = function(a, f) {
    return a < 255 ? f(a) : "";
};
function hexString(v) {
    var f = isShort(v) ? h1 : h2;
    return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : undefined;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
    var a = s * Math.min(l, 1 - l);
    var f = function(n) {
        var k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (n + h / 30) % 12;
        return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    };
    return [
        f(0),
        f(8),
        f(4)
    ];
}
function hsv2rgbn(h, s, v) {
    var f = function(n) {
        var k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (n + h / 60) % 6;
        return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    };
    return [
        f(5),
        f(3),
        f(1)
    ];
}
function hwb2rgbn(h, w, b) {
    var rgb = hsl2rgbn(h, 1, 0.5);
    var i;
    if (w + b > 1) {
        i = 1 / (w + b);
        w *= i;
        b *= i;
    }
    for(i = 0; i < 3; i++){
        rgb[i] *= 1 - w - b;
        rgb[i] += w;
    }
    return rgb;
}
function hueValue(r, g, b, d, max) {
    if (r === max) return (g - b) / d + (g < b ? 6 : 0);
    if (g === max) return (b - r) / d + 2;
    return (r - g) / d + 4;
}
function rgb2hsl(v) {
    var range = 255;
    var r = v.r / range;
    var g = v.g / range;
    var b = v.b / range;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var l = (max + min) / 2;
    var h, s, d;
    if (max !== min) {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = hueValue(r, g, b, d, max);
        h = h * 60 + 0.5;
    }
    return [
        h | 0,
        s || 0,
        l
    ];
}
function calln(f, a, b, c) {
    return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h, s, l) {
    return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
    return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
    return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
    return (h % 360 + 360) % 360;
}
function hueParse(str) {
    var m = HUE_RE.exec(str);
    var a = 255;
    var v;
    if (!m) return;
    if (m[5] !== v) a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
    var h = hue(+m[2]);
    var p1 = +m[3] / 100;
    var p2 = +m[4] / 100;
    if (m[1] === "hwb") v = hwb2rgb(h, p1, p2);
    else if (m[1] === "hsv") v = hsv2rgb(h, p1, p2);
    else v = hsl2rgb(h, p1, p2);
    return {
        r: v[0],
        g: v[1],
        b: v[2],
        a: a
    };
}
function rotate(v, deg) {
    var h = rgb2hsl(v);
    h[0] = hue(h[0] + deg);
    h = hsl2rgb(h);
    v.r = h[0];
    v.g = h[1];
    v.b = h[2];
}
function hslString(v) {
    if (!v) return;
    var a = rgb2hsl(v);
    var h = a[0];
    var s = n2p(a[1]);
    var l = n2p(a[2]);
    return v.a < 255 ? "hsla(".concat(h, ", ").concat(s, "%, ").concat(l, "%, ").concat(b2n(v.a), ")") : "hsl(".concat(h, ", ").concat(s, "%, ").concat(l, "%)");
}
var map = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
};
var names$1 = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
};
function unpack() {
    var unpacked = {};
    var keys = Object.keys(names$1);
    var tkeys = Object.keys(map);
    var i, j, k, ok, nk;
    for(i = 0; i < keys.length; i++){
        ok = nk = keys[i];
        for(j = 0; j < tkeys.length; j++){
            k = tkeys[j];
            nk = nk.replace(k, map[k]);
        }
        k = parseInt(names$1[ok], 16);
        unpacked[nk] = [
            k >> 16 & 0xFF,
            k >> 8 & 0xFF,
            k & 0xFF
        ];
    }
    return unpacked;
}
var names;
function nameParse(str) {
    if (!names) {
        names = unpack();
        names.transparent = [
            0,
            0,
            0,
            0
        ];
    }
    var a = names[str.toLowerCase()];
    return a && {
        r: a[0],
        g: a[1],
        b: a[2],
        a: a.length === 4 ? a[3] : 255
    };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
    var m = RGB_RE.exec(str);
    var a = 255;
    var r, g, b;
    if (!m) return;
    if (m[7] !== r) {
        var v = +m[7];
        a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
    }
    r = +m[1];
    g = +m[3];
    b = +m[5];
    r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
    g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
    b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
    return {
        r: r,
        g: g,
        b: b,
        a: a
    };
}
function rgbString(v) {
    return v && (v.a < 255 ? "rgba(".concat(v.r, ", ").concat(v.g, ", ").concat(v.b, ", ").concat(b2n(v.a), ")") : "rgb(".concat(v.r, ", ").concat(v.g, ", ").concat(v.b, ")"));
}
var to = function(v) {
    return v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;
};
var from = function(v) {
    return v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
};
function interpolate(rgb1, rgb2, t) {
    var r = from(b2n(rgb1.r));
    var g = from(b2n(rgb1.g));
    var b = from(b2n(rgb1.b));
    return {
        r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
        g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
        b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
        a: rgb1.a + t * (rgb2.a - rgb1.a)
    };
}
function modHSL(v, i, ratio) {
    if (v) {
        var tmp = rgb2hsl(v);
        tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
        tmp = hsl2rgb(tmp);
        v.r = tmp[0];
        v.g = tmp[1];
        v.b = tmp[2];
    }
}
function clone(v, proto) {
    return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
    var v = {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    };
    if (Array.isArray(input)) {
        if (input.length >= 3) {
            v = {
                r: input[0],
                g: input[1],
                b: input[2],
                a: 255
            };
            if (input.length > 3) v.a = n2b(input[3]);
        }
    } else {
        v = clone(input, {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        });
        v.a = n2b(v.a);
    }
    return v;
}
function functionParse(str) {
    if (str.charAt(0) === "r") return rgbParse(str);
    return hueParse(str);
}
var Color = /*#__PURE__*/ function() {
    "use strict";
    function Color(input) {
        (0, _classCallCheck._)(this, Color);
        if (input instanceof Color) return input;
        var type = typeof input === "undefined" ? "undefined" : (0, _typeOf._)(input);
        var v;
        if (type === "object") v = fromObject(input);
        else if (type === "string") v = hexParse(input) || nameParse(input) || functionParse(input);
        this._rgb = v;
        this._valid = !!v;
    }
    (0, _createClass._)(Color, [
        {
            key: "valid",
            get: function get() {
                return this._valid;
            }
        },
        {
            key: "rgb",
            get: function get() {
                var v = clone(this._rgb);
                if (v) v.a = b2n(v.a);
                return v;
            },
            set: function set(obj) {
                this._rgb = fromObject(obj);
            }
        },
        {
            key: "rgbString",
            value: function rgbString1() {
                return this._valid ? rgbString(this._rgb) : undefined;
            }
        },
        {
            key: "hexString",
            value: function hexString1() {
                return this._valid ? hexString(this._rgb) : undefined;
            }
        },
        {
            key: "hslString",
            value: function hslString1() {
                return this._valid ? hslString(this._rgb) : undefined;
            }
        },
        {
            key: "mix",
            value: function mix(color, weight) {
                if (color) {
                    var c1 = this.rgb;
                    var c2 = color.rgb;
                    var w2;
                    var p = weight === w2 ? 0.5 : weight;
                    var w = 2 * p - 1;
                    var a = c1.a - c2.a;
                    var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
                    w2 = 1 - w1;
                    c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;
                    c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;
                    c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;
                    c1.a = p * c1.a + (1 - p) * c2.a;
                    this.rgb = c1;
                }
                return this;
            }
        },
        {
            key: "interpolate",
            value: function interpolate1(color, t) {
                if (color) this._rgb = interpolate(this._rgb, color._rgb, t);
                return this;
            }
        },
        {
            key: "clone",
            value: function clone() {
                return new Color(this.rgb);
            }
        },
        {
            key: "alpha",
            value: function alpha(a) {
                this._rgb.a = n2b(a);
                return this;
            }
        },
        {
            key: "clearer",
            value: function clearer(ratio) {
                var rgb = this._rgb;
                rgb.a *= 1 - ratio;
                return this;
            }
        },
        {
            key: "greyscale",
            value: function greyscale() {
                var rgb = this._rgb;
                var val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
                rgb.r = rgb.g = rgb.b = val;
                return this;
            }
        },
        {
            key: "opaquer",
            value: function opaquer(ratio) {
                var rgb = this._rgb;
                rgb.a *= 1 + ratio;
                return this;
            }
        },
        {
            key: "negate",
            value: function negate() {
                var v = this._rgb;
                v.r = 255 - v.r;
                v.g = 255 - v.g;
                v.b = 255 - v.b;
                return this;
            }
        },
        {
            key: "lighten",
            value: function lighten(ratio) {
                modHSL(this._rgb, 2, ratio);
                return this;
            }
        },
        {
            key: "darken",
            value: function darken(ratio) {
                modHSL(this._rgb, 2, -ratio);
                return this;
            }
        },
        {
            key: "saturate",
            value: function saturate(ratio) {
                modHSL(this._rgb, 1, ratio);
                return this;
            }
        },
        {
            key: "desaturate",
            value: function desaturate(ratio) {
                modHSL(this._rgb, 1, -ratio);
                return this;
            }
        },
        {
            key: "rotate",
            value: function rotate1(deg) {
                rotate(this._rgb, deg);
                return this;
            }
        }
    ]);
    return Color;
}();
function index_esm(input) {
    return new Color(input);
}

},{"@swc/helpers/_/_class_call_check":"70JET","@swc/helpers/_/_create_class":"9CG3U","@swc/helpers/_/_type_of":"b4wfg","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"7PsJg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bookmark", function() {
    return bookmark;
});
parcelHelpers.export(exports, "renderBookmarkStatus", function() {
    return renderBookmarkStatus;
});
parcelHelpers.export(exports, "updateStarRating", function() {
    return updateStarRating;
});
parcelHelpers.export(exports, "submitReview", function() {
    return submitReview;
});
parcelHelpers.export(exports, "slideToLeft", function() {
    return slideToLeft;
});
parcelHelpers.export(exports, "slideToRight", function() {
    return slideToRight;
});
parcelHelpers.export(exports, "displayChekout", function() {
    return displayChekout;
});
parcelHelpers.export(exports, "renderBookingDates", function() {
    return renderBookingDates;
});
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _sweetalert2 = require("sweetalert2");
var _sweetalert2Default = parcelHelpers.interopDefault(_sweetalert2);
var _routeChanger = require("./routeChanger");
// DOM elements
var reviewSection = document.querySelector(".customer-feedback-section");
var submitBtn = document.querySelector(".review-feedback-btn");
var sliderContainer = document.querySelector(".slider-container");
var slides = sliderContainer === null || sliderContainer === void 0 ? void 0 : sliderContainer.childNodes;
var testimonialHeading = document.querySelector(".testimonial-heading");
var starValue, currentSlide = 0;
var createStarMarkup = function createStarMarkup(rating) {
    var markup = "";
    for(var i = 0; i < 5; i++){
        var starClass = i <= rating ? "fa-solid green-text" : "fa-regular";
        markup += '<i class="'.concat(starClass, ' fa fa-star"></i>');
    }
    return markup;
};
var createSliderMarkup = function createSliderMarkup(data, i) {
    var markup = '<div class="slide slide-'.concat(i + 1, '" style="transform:translate(').concat(i * 100, '%,-50%)">\n                    <div class="customer-info">\n                        <img class="review-img" src=').concat(data.user.profileImg, ' alt="User image">\n                        <p>').concat(data.user.name, '\n                    </div>\n                    <div class="customer-saying">\n                        <p class="customer-img-saying">').concat(data.review, '\n                        <div class="star"> \n                            ').concat(createStarMarkup(data.rating), "\n                    </div>    \n                  </div>");
    return markup;
};
var toggleBookmark = function(el) {
    el.classList.toggle("fa-regular");
    el.classList.toggle("bookmark-icon");
    el.classList.toggle("fa-solid");
    el.classList.toggle("unbookmark-icon");
};
var getCurrentUser = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var data;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "GET",
                            url: "/api/v1/users/account"
                        })
                    ];
                case 1:
                    data = _state.sent();
                    return [
                        2,
                        data.data.data.user
                    ];
            }
        });
    });
    return function getCurrentUser() {
        return _ref.apply(this, arguments);
    };
}();
var addToBookmark = function() {
    var _ref = (0, _asyncToGenerator._)(function(tourId) {
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "PATCH",
                            url: "/api/v1/users/bookmark/".concat(tourId)
                        })
                    ];
                case 1:
                    _state.sent();
                    return [
                        2
                    ];
            }
        });
    });
    return function addToBookmark(tourId) {
        return _ref.apply(this, arguments);
    };
}();
var removeBookmark = function() {
    var _ref = (0, _asyncToGenerator._)(function(tourId) {
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "DELETE",
                            url: "/api/v1/users/bookmark/".concat(tourId)
                        })
                    ];
                case 1:
                    _state.sent();
                    return [
                        2
                    ];
            }
        });
    });
    return function removeBookmark(tourId) {
        return _ref.apply(this, arguments);
    };
}();
var bookmark = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var user, tourId, bookmarkBtn, unbBookmarkBtn;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    return [
                        4,
                        getCurrentUser()
                    ];
                case 1:
                    user = _state.sent();
                    tourId = this.dataset.tourId;
                    bookmarkBtn = this.classList.contains("bookmark-icon");
                    unbBookmarkBtn = this.classList.contains("unbookmark-icon");
                    if (!bookmarkBtn) return [
                        3,
                        3
                    ];
                    return [
                        4,
                        addToBookmark(tourId)
                    ];
                case 2:
                    _state.sent();
                    _state.label = 3;
                case 3:
                    if (!unbBookmarkBtn) return [
                        3,
                        5
                    ];
                    return [
                        4,
                        removeBookmark(tourId)
                    ];
                case 4:
                    _state.sent();
                    _state.label = 5;
                case 5:
                    toggleBookmark(this);
                    return [
                        2
                    ];
            }
        });
    });
    return function bookmark() {
        return _ref.apply(this, arguments);
    };
}();
var renderBookmarkStatus = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var user, bookmarkIcon, tourId, isBookmarked;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    return [
                        4,
                        getCurrentUser()
                    ];
                case 1:
                    user = _state.sent();
                    bookmarkIcon = document.querySelector(".bookmark-icon");
                    if (!bookmarkIcon) return [
                        2
                    ];
                    tourId = bookmarkIcon.dataset.tourId;
                    isBookmarked = user.bookmarks.some(function(tour) {
                        return tour._id === tourId;
                    });
                    if (isBookmarked) toggleBookmark(bookmarkIcon);
                    return [
                        2
                    ];
            }
        });
    });
    return function renderBookmarkStatus() {
        return _ref.apply(this, arguments);
    };
}();
var updateStarRating = function updateStarRating(e) {
    var stars = Array.from(document.querySelectorAll(".star-size"));
    var star = e.target.classList.contains("star-size");
    starValue = +e.target.dataset.value;
    if (!star) return;
    stars.forEach(function(el) {
        el.classList.add("fa-regular");
        el.classList.remove("fa-solid");
    });
    stars.some(function(el, i) {
        if (i === starValue) return true;
        el.classList.remove("fa-regular");
        el.classList.add("fa-solid");
    });
    return starValue;
};
// updating testimonial section
var updateTestimonials = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var tourId, data, reviews, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (sliderContainer) sliderContainer.innerHTML = "";
                    tourId = submitBtn.dataset.tourId;
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "GET",
                            url: "/api/v1/tours/".concat(tourId, "/reviews")
                        })
                    ];
                case 2:
                    data = _state.sent();
                    testimonialHeading.textContent = "TESTIMONIALS(".concat(data.data.totalReviews, ")");
                    reviews = data.data.data.reviews;
                    reviews.forEach(function(review, i) {
                        var html = createSliderMarkup(review, i);
                        sliderContainer.insertAdjacentHTML("beforeend", html);
                    });
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    console.log(err);
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function updateTestimonials() {
        return _ref.apply(this, arguments);
    };
}();
var submitReview = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var rating, review, tourId, reviewErr, data, message, err, message1;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    // get inputs
                    rating = +starValue;
                    review = document.querySelector(".input-customer-feedback").value;
                    tourId = this.dataset.tourId;
                    // validate inputs
                    reviewErr = document.querySelector(".feeedback-err");
                    if (!rating) return [
                        2,
                        reviewErr.textContent = "Review needs rating"
                    ];
                    if (review.trim().length < 20) return [
                        2,
                        reviewErr.textContent = "Review atleast need 20 charcters"
                    ];
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        4,
                        ,
                        5
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            url: "/api/v1/tours/".concat(tourId, "/reviews"),
                            method: "POST",
                            data: {
                                review: review,
                                rating: rating
                            }
                        })
                    ];
                case 2:
                    data = _state.sent();
                    reviewErr.textContent = "";
                    message = data.data.message;
                    (0, _sweetalert2Default.default).fire(message);
                    // update testimonials
                    return [
                        4,
                        updateTestimonials()
                    ];
                case 3:
                    _state.sent();
                    return [
                        3,
                        5
                    ];
                case 4:
                    err = _state.sent();
                    console.log(err);
                    message1 = err.response.data.message;
                    reviewErr.textContent = message1;
                    return [
                        3,
                        5
                    ];
                case 5:
                    return [
                        2
                    ];
            }
        });
    });
    return function submitReview() {
        return _ref.apply(this, arguments);
    };
}();
// slider
var goToSlide = function goToSlide(slide) {
    slides.forEach(function(el, i) {
        el.style.transform = "translate(".concat(100 * (i - slide), "%, -50%)");
    });
};
var slideToLeft = function slideToLeft() {
    var maxSlide = sliderContainer.childNodes.length - 1;
    currentSlide--;
    if (currentSlide < 0) currentSlide = maxSlide;
    goToSlide(currentSlide);
};
var slideToRight = function slideToRight() {
    var maxSlide = sliderContainer.childNodes.length;
    currentSlide++;
    if (currentSlide === maxSlide) currentSlide = 0;
    goToSlide(currentSlide);
};
var validatePeople = function validatePeople(input) {
    var maxLength = 10;
    var minLength = 1;
    var value = Number.parseInt(input);
    var errLabel = document.querySelector(".people-err-label");
    console.log(input);
    if (value < minLength || value > maxLength) {
        errLabel.textContent = "Value should be greater than 0 and less than or equal to 10";
        return false;
    }
    errLabel.textContent = "";
    return true;
};
var displayChekout = function displayChekout(e) {
    var _e_target_dataset = e.target.dataset, tourId = _e_target_dataset.tourId, tourSlug = _e_target_dataset.tourSlug, bookingDate = _e_target_dataset.bookingDate;
    var peopleCount = document.getElementById("numberOfPeople").value;
    console.log(peopleCount);
    var isValid = validatePeople(peopleCount);
    if (!isValid) return;
    (0, _routeChanger.routeChanger)("/checkout/".concat(tourSlug, "?bookingDate=").concat(bookingDate, "&size=").concat(peopleCount));
};
var renderBookingDates = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var _this_dataset, tourId, tourSlug, res, bookingTourDates, bookingMarkup, htmlContent;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    _this_dataset = this.dataset, tourId = _this_dataset.tourId, tourSlug = _this_dataset.tourSlug;
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "GET",
                            url: "/api/v1/tours/".concat(tourId, "/avialable-bookings")
                        })
                    ];
                case 1:
                    res = _state.sent();
                    bookingTourDates = res.data.data.bookingTourDates;
                    bookingTourDates = bookingTourDates.filter(function(booking) {
                        return new Date(booking) > Date.now();
                    });
                    bookingMarkup = '<div style="display: flex; flex-direction: column;">\n  '.concat(bookingTourDates.map(function(date, index) {
                        return '\n    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid #ddd;">\n      <div>\n        <h3>BOOKING '.concat(index + 1, ":</h3>\n        <p>Booking Date: ").concat(new Date(date).toDateString(), '</p>\n      </div>\n      <div>\n        <button id="purchaseBtn').concat(index, '" class="btn bookingBtn green" data-tour-id=').concat(tourId, " data-tour-slug=").concat(tourSlug, " data-booking-date=").concat(date, " >Purchase</button>\n      </div>\n    </div>\n  ");
                    }).join(""), '\n  \n  <div style="display: flex; justify-content: center; align-items: center; padding: 10px; border-bottom: 1px solid #ddd;">\n    <div>\n      <h3>Number of People:</h3>\n      <input  type="number" min="1" max="10" id="numberOfPeople" class="input-max-people"  value="1" placeholder="size" />\n      <p style=" color: red"; font-size: "15px"; " class="people-err-label"><p/>\n    </div>\n  </div>\n</div>');
                    htmlContent = bookingTourDates.length === 0 ? "<h3>Bookings has filled out </h3>" : bookingMarkup;
                    (0, _sweetalert2Default.default).fire({
                        title: "Bookings",
                        html: htmlContent,
                        showCancelButton: false,
                        showConfirmButton: false,
                        preConfirm: function() {}
                    });
                    return [
                        2
                    ];
            }
        });
    });
    return function renderBookingDates() {
        return _ref.apply(this, arguments);
    };
}();

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_ts_generator":"dhhs4","axios":"eCZhQ","sweetalert2":"2OR50","./routeChanger":"ful9o","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"6zQkQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bookTour", function() {
    return bookTour;
});
parcelHelpers.export(exports, "cancelBooking", function() {
    return cancelBooking;
});
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var stripe = Stripe("pk_test_51OH5rqSI832q4lmFwL6nM3XNMLJE4tWqXvV8p9kKQA5A7WZ61EJIGEVEwPS6b5Df50NvyLE6h7MnD2bUjZN6cmq700WUDnvWwE");
var bookTour = function() {
    var _ref = (0, _asyncToGenerator._)(function(tourId, bookingDate, peopleCount) {
        var res, id, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    _state.trys.push([
                        0,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "POST",
                            url: "/api/v1/bookings/checkout/".concat(tourId),
                            data: {
                                bookingDate: new Date(bookingDate),
                                peopleCount: peopleCount
                            }
                        })
                    ];
                case 1:
                    res = _state.sent();
                    id = res.data.data.id;
                    return [
                        4,
                        stripe.redirectToCheckout({
                            sessionId: id
                        })
                    ];
                case 2:
                    _state.sent();
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    console.log(err);
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function bookTour(tourId, bookingDate, peopleCount) {
        return _ref.apply(this, arguments);
    };
}();
var cancelBooking = function() {
    var _ref = (0, _asyncToGenerator._)(function(bookingId) {
        var res, booking;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "DELETE",
                            url: "/api/v1/bookings/".concat(bookingId)
                        })
                    ];
                case 1:
                    res = _state.sent();
                    booking = res.data.data.booking;
                    // adding refund wallet to user
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "PATCH",
                            url: "/api/v1/users/wallet",
                            data: {
                                wallet: booking
                            }
                        })
                    ];
                case 2:
                    _state.sent();
                    return [
                        2
                    ];
            }
        });
    });
    return function cancelBooking(bookingId) {
        return _ref.apply(this, arguments);
    };
}();

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_ts_generator":"dhhs4","axios":"eCZhQ","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"iiVov":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "applyCoupon", function() {
    return applyCoupon;
});
parcelHelpers.export(exports, "checkout", function() {
    return checkout;
});
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var inputCoupon = document.querySelector(".input-coupon");
var couponErrLabel = document.querySelector(".coupon-err-label");
var priceLabel = document.querySelector(".product-price-label");
var form = document.querySelector(".checkout-form");
var applyCoupon = function() {
    var _ref = (0, _asyncToGenerator._)(function(e) {
        var tourId, couponCode, message, res, finalPrice, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    e.preventDefault();
                    tourId = this.dataset.tourId;
                    couponCode = inputCoupon.value;
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "POST",
                            url: "/api/v1/coupons/discount",
                            data: {
                                tourId: tourId,
                                couponCode: couponCode
                            }
                        })
                    ];
                case 2:
                    res = _state.sent();
                    finalPrice = res.data.data.finalPrice;
                    couponErrLabel.classList.add("green-text");
                    couponErrLabel.classList.remove("red-text");
                    message = res.data.message;
                    couponErrLabel.textContent = message;
                    priceLabel.textContent = "Price: $".concat(finalPrice);
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    couponErrLabel.classList.remove("green-text");
                    couponErrLabel.classList.add("red-text");
                    message = err.response.data.message;
                    couponErrLabel.textContent = message;
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function applyCoupon(e) {
        return _ref.apply(this, arguments);
    };
}();
var checkout = function checkout(fn) {
    return function(e) {
        if (form.checkValidity()) {
            e.preventDefault();
            var _this_dataset = this.dataset, tourId = _this_dataset.tourId, bookingDate = _this_dataset.bookingDate, peopleCount = _this_dataset.peopleCount;
            fn(tourId, bookingDate, peopleCount);
        }
    };
};

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_ts_generator":"dhhs4","axios":"eCZhQ","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"6DZE5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "renderBookings", function() {
    return renderBookings;
});
parcelHelpers.export(exports, "renderWallet", function() {
    return renderWallet;
});
parcelHelpers.export(exports, "renderFeedbackInputs", function() {
    return renderFeedbackInputs;
});
parcelHelpers.export(exports, "renderSecurityInputs", function() {
    return renderSecurityInputs;
});
parcelHelpers.export(exports, "renderCancellationWindow", function() {
    return renderCancellationWindow;
});
parcelHelpers.export(exports, "renderMemories", function() {
    return renderMemories;
});
parcelHelpers.export(exports, "renderBookmarks", function() {
    return renderBookmarks;
});
parcelHelpers.export(exports, "sendFeedback", function() {
    return sendFeedback;
});
parcelHelpers.export(exports, "resetPassword", function() {
    return resetPassword;
});
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _sweetalert2 = require("sweetalert2");
var _sweetalert2Default = parcelHelpers.interopDefault(_sweetalert2);
var _routeChanger = require("./routeChanger");
var _catchAsync = require("../../utils/catchAsync");
var _catchAsyncDefault = parcelHelpers.interopDefault(_catchAsync);
var itemsContainer = document.querySelector(".dash-board-commodity");
var dashboardHeading = document.querySelector(".dashboard-heading");
var dashboardActions = document.querySelector(".dash-board-actions");
var getCurrentUser = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var data;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "GET",
                            url: "/api/v1/users/account"
                        })
                    ];
                case 1:
                    data = _state.sent();
                    return [
                        2,
                        data.data.data.user
                    ];
            }
        });
    });
    return function getCurrentUser() {
        return _ref.apply(this, arguments);
    };
}();
// markup rendering in profile page
var renderMarkup = function renderMarkup(markup, sectionName) {
    dashboardHeading.textContent = sectionName;
    itemsContainer.innerHTML = "";
    itemsContainer.insertAdjacentHTML("beforeend", markup);
};
// creating Tour markup
var generateTourMarkup = function generateTourMarkup(data) {
    var bookingId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    var invoiceBtn = bookingId !== null ? "<a href=/api/v1/bookings/".concat(bookingId, '/invoice class="invoice-btn" id="light-blue">Invoice</a>') : "";
    return ' <div class="item" data-slug="'.concat(data.slug, '">\n                  <div class="contents">\n                      <img class="item-img" src=').concat(data.coverImg, '>\n                      <p class="item-name">').concat(data.tourName, '</p>\n                      <div class="booking-btns">\n                        <a class="more-btn" id="light-green" href="/tour/').concat(data.slug, '">More</a> \n                        ').concat(invoiceBtn, "\n                      </div>   \n                  </div>\n           </div>");
};
// creating wallet markup
var generateWalletMarkup = function generateWalletMarkup(booking) {
    var months = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
    ];
    var bookingMonth = months[new Date(booking.createdAt).getMonth()];
    console.log(booking);
    return '<div class="tour">\n            <img class="booking-tour-img" src='.concat(booking.tour.coverImg, ' alt="Tour image" />\n            <p class="booking-tour-date">').concat(bookingMonth, '</p>\n            <p class="booking-tour-price">').concat(booking.tour.price, '</p>\n            <a class="more-btn" id="light-green" href="/tour/').concat(booking.tour.slug, '">Info</a> \n          </div>');
};
var renderWalletBar = function renderWalletBar() {
    var markup = '<div class="booking-heading">\n                    <p class="boooking-tour-name">Tour </p>\n                    <p class="boooking-Date">Date </p>\n                    <p class="booking-user-name">Customer </p>\n                    <p class="booking-price">Price</p>\n                  </div>';
    itemsContainer.insertAdjacentHTML("beforeend", markup);
};
// creating memories markup
var generateMemoriesMarkup = function generateMemoriesMarkup(data) {
    var date = new Date(data.date).toLocaleDateString();
    return ' <div class="item" data-slug="'.concat(data._id, '">\n                  <div class="contents">\n                      <img class="item-img" src=').concat(data.photo, '>\n                      <p class="item-name">').concat(date, '</p>\n                      <a class="btn" id="light-green" href="/memories/').concat(data.id, '">More</a></div>  \n                  </div>\n                \n           </div>');
};
// rendering items
var renderTour = function renderTour(bookings) {
    bookings.forEach(function(booking) {
        var html = generateTourMarkup(booking.tour, booking._id);
        itemsContainer.insertAdjacentHTML("beforeend", html);
    });
};
var renderBookings = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var response, userId, bookings, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    itemsContainer.innerHTML = "";
                    dashboardActions.innerHTML = "";
                    dashboardHeading.textContent = "bookings";
                    itemsContainer.classList = "";
                    itemsContainer.classList.add("dash-board-commodity");
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        4,
                        ,
                        5
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "GET",
                            url: "api/v1/users/account"
                        })
                    ];
                case 2:
                    response = _state.sent();
                    userId = response.data.data.user._id;
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "GET",
                            url: "api/v1/bookings/".concat(userId)
                        })
                    ];
                case 3:
                    response = _state.sent();
                    bookings = response.data.data.bookings;
                    renderTour(bookings);
                    return [
                        3,
                        5
                    ];
                case 4:
                    err = _state.sent();
                    console.log(err);
                    return [
                        3,
                        5
                    ];
                case 5:
                    return [
                        2
                    ];
            }
        });
    });
    return function renderBookings() {
        return _ref.apply(this, arguments);
    };
}();
var renderWallet = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var res, userWallet, total;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    itemsContainer.innerHTML = "";
                    itemsContainer.classList = "";
                    itemsContainer.classList.add("grouped-booking");
                    dashboardHeading.textContent = "wallet";
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "GET",
                            url: "/api/v1/users/wallet"
                        })
                    ];
                case 1:
                    res = _state.sent();
                    userWallet = res.data.data.userWallet;
                    console.log(res.data.data);
                    // render the top bar heading
                    renderWalletBar();
                    // render the items in wallet
                    userWallet[0].forEach(function(tour) {
                        var Walletmarkup = generateWalletMarkup(tour);
                        itemsContainer.insertAdjacentHTML("beforeend", Walletmarkup);
                    });
                    total = userWallet[0].reduce(function(acc, booking) {
                        return Math.round(acc + booking.price);
                    }, 0);
                    console.log(total);
                    dashboardActions.innerHTML = "<h3>Total:".concat(total, "</h3>");
                    return [
                        2
                    ];
            }
        });
    });
    return function renderWallet() {
        return _ref.apply(this, arguments);
    };
}();
var renderFeedbackInputs = function renderFeedbackInputs() {
    dashboardActions.innerHTML = "";
    itemsContainer.classList = "";
    itemsContainer.classList.add("dash-board-commodity-feedback");
    var feedbackMarkup = '<div class="feedback">\n                            <form class="feedback-form">\n                              <input class="input-subject" type="text" placeholder="subject" required minlength=4 pattern="[a-zA-Z]*"/>\n                              <textarea class="message-area" placeholder="Describe yourself issue or anything" required minlength=20 pattern="[a-zA-Z]*"></textarea>\n                              <button class="btn center feedback-submit-btn">submit</button>\n                            </form>\n                          </div>';
    renderMarkup(feedbackMarkup, "Feedback");
};
var renderSecurityInputs = function renderSecurityInputs() {
    dashboardActions.innerHTML = "";
    itemsContainer.classList = "";
    itemsContainer.classList.add("dash-board-commodity");
    dashboardHeading.textContent = "Security";
    var securityMarkup = '<form class="security"> \n                              <div class="column"> \n                                <input class="password current-password" type="text" placeholder="Current password" required minlength=8 pattern=\'(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,}\'  title=\'password must contain 8 character with atleast 1 lowercase character and 1 uppercase character\' />\n                                <label class="message label-current-password-err"></label>\n                              </div>\n                              <div class="column">  \n                                <input class="password new-password" type="text" placeholder="New password" required minlength=8 pattern=\'(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,}\'  title=\'password must contain 8 character with atleast 1 lowercase character and 1 uppercase character\' />\n                                <label class="message label-new-password-err"></label>\n                              </div>  \n                                <div class="column">\n                                  <input class="password confirm-new-password" type="text" placeholder="Confirm new password" required minlength=8 pattern=\'(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,}\'  title=\'Password must be same as new password\'/>\n                                  <label class="message label-confirm-password-err"></label>\n                                </div>  \n                                <button class="btn reset-btn">Submit</button>\n                                <p class="forget-text">forget password?</p>\n                          </form>';
    renderMarkup(securityMarkup, "Security");
};
var renderCancellationWindow = function renderCancellationWindow(fn, bookingId) {
    var cancellationMarkup = '\n  <form class="cancellationForm">\n      <div style="margin-bottom:10px" class="reason">\n          <label>\n              <input type="radio" name="cancellationReason" value="not_satisfied">\n              Not Satisfied\n          </label>\n      </div>\n\n      <div style="margin-bottom:10px" class="reason">\n          <label>\n              <input type="radio" name="cancellationReason" value="change_of_plans">\n              Change of Plans\n          </label>\n      </div>\n\n      <div style="margin-bottom:10px" class="reason">\n          <label>\n              <input type="radio" name="cancellationReason" value="other">\n              Other\n          </label>\n      </div>\n\n      <div style="margin-bottom:10px" class="reason">\n          <label>\n              <input type="radio" name="cancellationReason" value="family_emergency">\n              Family Emergency\n              \n          </label>\n      </div>\n\n      <div style="margin-bottom:10px" class="reason">\n          <label>\n              <input type="radio" name="cancellationReason" value="weather_conditions">\n              Weather Conditions\n             \n          </label>\n      </div>\n\n      <div style="margin-bottom:10px" class="reason">\n          <label>\n              <input type="radio" name="cancellationReason" value="displeasure_with_itinerary">\n              Displeasure with Itinerary\n             \n          </label>\n      </div>\n  </form>\n';
    (0, _sweetalert2Default.default).fire({
        title: "Reason for Cancellation",
        html: cancellationMarkup,
        preConfirm: function() {
            var form = document.querySelector(".cancellationForm");
            var selectedReason = form.querySelector('input[name="cancellationReason"]:checked');
            if (!selectedReason) return (0, _sweetalert2Default.default).showValidationMessage("Please select any of those");
            fn(bookingId);
        }
    });
};
var renderMemories = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var addIcon, data, memories, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    // memories page setup
                    dashboardActions.innerHTML = "";
                    itemsContainer.innerHTML = "";
                    itemsContainer.classList = "";
                    itemsContainer.classList.add("dash-board-commodity");
                    dashboardHeading.textContent = "Memories";
                    addIcon = '<a href="/create-memory"><i class="fa fa-plus add-icon"></i></a>';
                    dashboardActions.insertAdjacentHTML("beforeend", addIcon);
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "GET",
                            url: "/api/v1/users/memories"
                        })
                    ];
                case 2:
                    data = _state.sent();
                    memories = data.data.data.memories;
                    memories.forEach(function(memory) {
                        var html = generateMemoriesMarkup(memory);
                        itemsContainer.insertAdjacentHTML("beforeend", html);
                    });
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    console.log(err);
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function renderMemories() {
        return _ref.apply(this, arguments);
    };
}();
var renderBookmarks = (0, _catchAsyncDefault.default)(/*#__PURE__*/ (0, _asyncToGenerator._)(function() {
    var user, data, bookmarks, err;
    return (0, _tsGenerator._)(this, function(_state) {
        switch(_state.label){
            case 0:
                itemsContainer.innerHTML = "";
                dashboardHeading.textContent = "Bookmarks";
                itemsContainer.classList = "";
                itemsContainer.classList.add("dash-board-commodity");
                dashboardActions.innerHTML = "";
                return [
                    4,
                    getCurrentUser()
                ];
            case 1:
                user = _state.sent();
                _state.label = 2;
            case 2:
                _state.trys.push([
                    2,
                    4,
                    ,
                    5
                ]);
                return [
                    4,
                    (0, _axiosDefault.default)({
                        method: "GET",
                        url: "/api/v1/users/bookmark/".concat(user._id)
                    })
                ];
            case 3:
                data = _state.sent();
                bookmarks = data.data.data.bookmarks.bookmarks;
                bookmarks.forEach(function(tour) {
                    var markup = generateTourMarkup(tour);
                    itemsContainer.insertAdjacentHTML("beforeend", markup);
                });
                return [
                    3,
                    5
                ];
            case 4:
                err = _state.sent();
                console.log(err);
                return [
                    3,
                    5
                ];
            case 5:
                return [
                    2
                ];
        }
    });
}));
var sendFeedback = function() {
    var _ref = (0, _asyncToGenerator._)(function(e) {
        var inputSubject, inputMessage, form, data, message, err, message1;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    inputSubject = document.querySelector(".input-subject").value;
                    inputMessage = document.querySelector(".message-area").value;
                    form = document.querySelector(".feedback-form");
                    if (!form.checkValidity()) return [
                        2,
                        e.preventDefault()
                    ];
                    e.preventDefault();
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            url: "api/v1/users/submit-feedback",
                            method: "POST",
                            data: {
                                subject: inputSubject,
                                message: inputMessage
                            }
                        })
                    ];
                case 2:
                    data = _state.sent();
                    // const message
                    message = data.data.message;
                    (0, _sweetalert2Default.default).fire(message);
                    (0, _routeChanger.routeChanger)("/profile");
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    console.log(err);
                    message1 = err.data.data.message;
                    (0, _sweetalert2Default.default).fire(message1);
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function sendFeedback(e) {
        return _ref.apply(this, arguments);
    };
}();
var resetPassword = function() {
    var _ref = (0, _asyncToGenerator._)(function(e) {
        var form, password, newPassword, confirmPassword, newPasswordErrLabel, currentPasswordErrLabel, confirmErrPasswordLabel, data, message, err, message1;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    form = document.querySelector(".security");
                    // inputs
                    password = document.querySelector(".current-password").value;
                    newPassword = document.querySelector(".new-password").value;
                    confirmPassword = document.querySelector(".confirm-new-password").value;
                    // error labels
                    newPasswordErrLabel = document.querySelector(".label-new-password-err");
                    currentPasswordErrLabel = document.querySelector(".label-current-password-err");
                    confirmErrPasswordLabel = document.querySelector(".label-confirm-password-err");
                    if (newPassword !== confirmPassword) {
                        e.preventDefault();
                        return [
                            2,
                            confirmErrPasswordLabel.textContent = "New password and confrim password are not same"
                        ];
                    }
                    if (!form.checkValidity()) return [
                        2
                    ];
                    e.preventDefault();
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "PATCH",
                            url: "api/v1/users/password",
                            data: {
                                password: password,
                                newPassword: newPassword,
                                confirmPassword: confirmPassword
                            }
                        })
                    ];
                case 2:
                    data = _state.sent();
                    message = data.data.message;
                    newPasswordErrLabel.textContent = currentPasswordErrLabel.textContent = confirmErrPasswordLabel.textContent = "";
                    (0, _sweetalert2Default.default).fire(message);
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    message1 = err.response.data.message;
                    currentPasswordErrLabel.textContent = message1;
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function resetPassword(e) {
        return _ref.apply(this, arguments);
    };
}();

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_ts_generator":"dhhs4","axios":"eCZhQ","sweetalert2":"2OR50","./routeChanger":"ful9o","../../utils/catchAsync":"6ySvs","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"6ySvs":[function(require,module,exports) {
var catchAsync = function catchAsync(fn) {
    return function(req, res, next) {
        fn(req, res, next).catch(function(err) {
            console.log(err);
            next(err);
        });
    };
};
module.exports = catchAsync;

},{}],"eQweB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "renderAllMarkers", function() {
    return renderAllMarkers;
});
var _leaflet = require("leaflet");
var _leafletDefault = parcelHelpers.interopDefault(_leaflet);
var getAllMarkers = function getAllMarkers(markers, map) {
    var group = new (0, _leafletDefault.default).featureGroup(markers);
    map.fitBounds(group.getBounds().pad(0.1));
};
var renderAllMarkers = function renderAllMarkers(coordinates) {
    var markers = [];
    // displaying map
    var map = (0, _leafletDefault.default).map("map", {
        center: (0, _leafletDefault.default).latLng(49.2125578, 16.62662018),
        zoom: 1
    });
    //Adding a Tile layer to map
    (0, _leafletDefault.default).tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);
    coordinates.forEach(function(coordinate) {
        var marker = (0, _leafletDefault.default).marker(coordinate.latLng).addTo(map);
        // binding a popup  for every marker
        marker.bindPopup(coordinate.description, {
            autoClose: false
        }).openPopup();
        // pushing it to marker array for displaying every marker in map
        markers.push(marker);
    });
    getAllMarkers(markers, map);
};

},{"leaflet":"97rBD","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"97rBD":[function(require,module,exports) {
var _typeOf = require("@swc/helpers/_/_type_of");
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */ (function(global, factory) {
    factory(exports);
})(undefined, function(exports1) {
    "use strict";
    var version = "1.9.4";
    /*
   * @namespace Util
   *
   * Various utility functions, used by Leaflet internally.
   */ // @function extend(dest: Object, src?: Object): Object
    // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
    function extend(dest) {
        var i, j, len, src;
        for(j = 1, len = arguments.length; j < len; j++){
            src = arguments[j];
            for(i in src)dest[i] = src[i];
        }
        return dest;
    }
    // @function create(proto: Object, properties?: Object): Object
    // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
    var create$2 = Object.create || function() {
        function F() {}
        return function(proto) {
            F.prototype = proto;
            return new F();
        };
    }();
    // @function bind(fn: Function, ): Function
    // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
    // Has a `L.bind()` shortcut.
    function bind(fn, obj) {
        var slice = Array.prototype.slice;
        if (fn.bind) return fn.bind.apply(fn, slice.call(arguments, 1));
        var args = slice.call(arguments, 2);
        return function() {
            return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
        };
    }
    // @property lastId: Number
    // Last unique ID used by [`stamp()`](#util-stamp)
    var lastId = 0;
    // @function stamp(obj: Object): Number
    // Returns the unique ID of an object, assigning it one if it doesn't have it.
    function stamp(obj) {
        if (!("_leaflet_id" in obj)) obj["_leaflet_id"] = ++lastId;
        return obj._leaflet_id;
    }
    // @function throttle(fn: Function, time: Number, context: Object): Function
    // Returns a function which executes function `fn` with the given scope `context`
    // (so that the `this` keyword refers to `context` inside `fn`'s code). The function
    // `fn` will be called no more than one time per given amount of `time`. The arguments
    // received by the bound function will be any arguments passed when binding the
    // function, followed by any arguments passed when invoking the bound function.
    // Has an `L.throttle` shortcut.
    function throttle(fn, time, context) {
        var lock, args, wrapperFn, later;
        later = function later() {
            // reset lock and call if queued
            lock = false;
            if (args) {
                wrapperFn.apply(context, args);
                args = false;
            }
        };
        wrapperFn = function wrapperFn() {
            if (lock) // called too soon, queue to call later
            args = arguments;
            else {
                // call and lock until later
                fn.apply(context, arguments);
                setTimeout(later, time);
                lock = true;
            }
        };
        return wrapperFn;
    }
    // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
    // Returns the number `num` modulo `range` in such a way so it lies within
    // `range[0]` and `range[1]`. The returned value will be always smaller than
    // `range[1]` unless `includeMax` is set to `true`.
    function wrapNum(x, range, includeMax) {
        var max = range[1], min = range[0], d = max - min;
        return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
    }
    // @function falseFn(): Function
    // Returns a function which always returns `false`.
    function falseFn() {
        return false;
    }
    // @function formatNum(num: Number, precision?: Number|false): Number
    // Returns the number `num` rounded with specified `precision`.
    // The default `precision` value is 6 decimal places.
    // `false` can be passed to skip any processing (can be useful to avoid round-off errors).
    function formatNum(num, precision) {
        if (precision === false) return num;
        var pow = Math.pow(10, precision === undefined ? 6 : precision);
        return Math.round(num * pow) / pow;
    }
    // @function trim(str: String): String
    // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
    function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    // @function splitWords(str: String): String[]
    // Trims and splits the string on whitespace and returns the array of parts.
    function splitWords(str) {
        return trim(str).split(/\s+/);
    }
    // @function setOptions(obj: Object, options: Object): Object
    // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
    function setOptions(obj, options) {
        if (!Object.prototype.hasOwnProperty.call(obj, "options")) obj.options = obj.options ? create$2(obj.options) : {};
        for(var i in options)obj.options[i] = options[i];
        return obj.options;
    }
    // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
    // Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
    // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
    // be appended at the end. If `uppercase` is `true`, the parameter names will
    // be uppercased (e.g. `'?A=foo&B=bar'`)
    function getParamString(obj, existingUrl, uppercase) {
        var params = [];
        for(var i in obj)params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
        return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
    }
    var templateRe = /\{ *([\w_ -]+) *\}/g;
    // @function template(str: String, data: Object): String
    // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
    // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
    // `('Hello foo, bar')`. You can also specify functions instead of strings for
    // data values  they will be evaluated passing `data` as an argument.
    function template(str, data) {
        return str.replace(templateRe, function(str, key) {
            var value = data[key];
            if (value === undefined) throw new Error("No value provided for variable " + str);
            else if (typeof value === "function") value = value(data);
            return value;
        });
    }
    // @function isArray(obj): Boolean
    // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
    var isArray = Array.isArray || function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
    };
    // @function indexOf(array: Array, el: Object): Number
    // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
    function indexOf(array, el) {
        for(var i = 0; i < array.length; i++){
            if (array[i] === el) return i;
        }
        return -1;
    }
    // @property emptyImageUrl: String
    // Data URI string containing a base64-encoded empty GIF image.
    // Used as a hack to free memory from unused images on WebKit-powered
    // mobile devices (by setting image `src` to this string).
    var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
    // inspired by https://paulirish.com/2011/requestanimationframe-for-smart-animating/
    function getPrefixed(name) {
        return window["webkit" + name] || window["moz" + name] || window["ms" + name];
    }
    var lastTime = 0;
    // fallback for IE 7-8
    function timeoutDefer(fn) {
        var time = +new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
        lastTime = time + timeToCall;
        return window.setTimeout(fn, timeToCall);
    }
    var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
    var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
        window.clearTimeout(id);
    };
    // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
    // Schedules `fn` to be executed when the browser repaints. `fn` is bound to
    // `context` if given. When `immediate` is set, `fn` is called immediately if
    // the browser doesn't have native support for
    // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
    // otherwise it's delayed. Returns a request ID that can be used to cancel the request.
    function requestAnimFrame(fn, context, immediate) {
        if (immediate && requestFn === timeoutDefer) fn.call(context);
        else return requestFn.call(window, bind(fn, context));
    }
    // @function cancelAnimFrame(id: Number): undefined
    // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
    function cancelAnimFrame(id) {
        if (id) cancelFn.call(window, id);
    }
    var Util = {
        __proto__: null,
        extend: extend,
        create: create$2,
        bind: bind,
        get lastId () {
            return lastId;
        },
        stamp: stamp,
        throttle: throttle,
        wrapNum: wrapNum,
        falseFn: falseFn,
        formatNum: formatNum,
        trim: trim,
        splitWords: splitWords,
        setOptions: setOptions,
        getParamString: getParamString,
        template: template,
        isArray: isArray,
        indexOf: indexOf,
        emptyImageUrl: emptyImageUrl,
        requestFn: requestFn,
        cancelFn: cancelFn,
        requestAnimFrame: requestAnimFrame,
        cancelAnimFrame: cancelAnimFrame
    };
    // @class Class
    // @aka L.Class
    // @section
    // @uninheritable
    // Thanks to John Resig and Dean Edwards for inspiration!
    function Class() {}
    Class.extend = function(props) {
        // @function extend(props: Object): Function
        // [Extends the current class](#class-inheritance) given the properties to be included.
        // Returns a Javascript function that is a class constructor (to be called with `new`).
        var NewClass = function NewClass() {
            setOptions(this);
            // call the constructor
            if (this.initialize) this.initialize.apply(this, arguments);
            // call all constructor hooks
            this.callInitHooks();
        };
        var parentProto = NewClass.__super__ = this.prototype;
        var proto = create$2(parentProto);
        proto.constructor = NewClass;
        NewClass.prototype = proto;
        // inherit parent's statics
        for(var i in this)if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") NewClass[i] = this[i];
        // mix static properties into the class
        if (props.statics) extend(NewClass, props.statics);
        // mix includes into the prototype
        if (props.includes) {
            checkDeprecatedMixinEvents(props.includes);
            extend.apply(null, [
                proto
            ].concat(props.includes));
        }
        // mix given properties into the prototype
        extend(proto, props);
        delete proto.statics;
        delete proto.includes;
        // merge options
        if (proto.options) {
            proto.options = parentProto.options ? create$2(parentProto.options) : {};
            extend(proto.options, props.options);
        }
        proto._initHooks = [];
        // add method for calling all hooks
        proto.callInitHooks = function() {
            if (this._initHooksCalled) return;
            if (parentProto.callInitHooks) parentProto.callInitHooks.call(this);
            this._initHooksCalled = true;
            for(var i = 0, len = proto._initHooks.length; i < len; i++)proto._initHooks[i].call(this);
        };
        return NewClass;
    };
    // @function include(properties: Object): this
    // [Includes a mixin](#class-includes) into the current class.
    Class.include = function(props) {
        var parentOptions = this.prototype.options;
        extend(this.prototype, props);
        if (props.options) {
            this.prototype.options = parentOptions;
            this.mergeOptions(props.options);
        }
        return this;
    };
    // @function mergeOptions(options: Object): this
    // [Merges `options`](#class-options) into the defaults of the class.
    Class.mergeOptions = function(options) {
        extend(this.prototype.options, options);
        return this;
    };
    // @function addInitHook(fn: Function): this
    // Adds a [constructor hook](#class-constructor-hooks) to the class.
    Class.addInitHook = function(fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        var init = typeof fn === "function" ? fn : function init() {
            this[fn].apply(this, args);
        };
        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(init);
        return this;
    };
    function checkDeprecatedMixinEvents(includes) {
        /* global L: true */ if (typeof L === "undefined" || !L || !L.Mixin) return;
        includes = isArray(includes) ? includes : [
            includes
        ];
        for(var i = 0; i < includes.length; i++)if (includes[i] === L.Mixin.Events) console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
    }
    /*
   * @class Evented
   * @aka L.Evented
   * @inherits Class
   *
   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
   *
   * @example
   *
   * ```js
   * map.on('click', function(e) {
   * 	alert(e.latlng);
   * } );
   * ```
   *
   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
   *
   * ```js
   * function onClick(e) { ... }
   *
   * map.on('click', onClick);
   * map.off('click', onClick);
   * ```
   */ var Events = {
        /* @method on(type: String, fn: Function, context?: Object): this
  	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
  	 *
  	 * @alternative
  	 * @method on(eventMap: Object): this
  	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
  	 */ on: function on(types, fn, context) {
            // types can be a map of types/handlers
            if (typeof types === "object") for(var type in types)// we don't process space-separated events here for performance;
            // it's a hot path since Layer uses the on(obj) syntax
            this._on(type, types[type], fn);
            else {
                // types can be a string of space-separated words
                types = splitWords(types);
                for(var i = 0, len = types.length; i < len; i++)this._on(types[i], fn, context);
            }
            return this;
        },
        /* @method off(type: String, fn?: Function, context?: Object): this
  	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
  	 *
  	 * @alternative
  	 * @method off(eventMap: Object): this
  	 * Removes a set of type/listener pairs.
  	 *
  	 * @alternative
  	 * @method off: this
  	 * Removes all listeners to all events on the object. This includes implicitly attached events.
  	 */ off: function off(types, fn, context) {
            if (!arguments.length) // clear all listeners if called without arguments
            delete this._events;
            else if (typeof types === "object") for(var type in types)this._off(type, types[type], fn);
            else {
                types = splitWords(types);
                var removeAll = arguments.length === 1;
                for(var i = 0, len = types.length; i < len; i++)if (removeAll) this._off(types[i]);
                else this._off(types[i], fn, context);
            }
            return this;
        },
        // attach listener (without syntactic sugar now)
        _on: function _on(type, fn, context, _once) {
            if (typeof fn !== "function") {
                console.warn("wrong listener type: " + (typeof fn === "undefined" ? "undefined" : (0, _typeOf._)(fn)));
                return;
            }
            // check if fn already there
            if (this._listens(type, fn, context) !== false) return;
            if (context === this) // Less memory footprint.
            context = undefined;
            var newListener = {
                fn: fn,
                ctx: context
            };
            if (_once) newListener.once = true;
            this._events = this._events || {};
            this._events[type] = this._events[type] || [];
            this._events[type].push(newListener);
        },
        _off: function _off(type, fn, context) {
            var listeners, i, len;
            if (!this._events) return;
            listeners = this._events[type];
            if (!listeners) return;
            if (arguments.length === 1) {
                if (this._firingCount) // Set all removed listeners to noop
                // so they are not called if remove happens in fire
                for(i = 0, len = listeners.length; i < len; i++)listeners[i].fn = falseFn;
                // clear all listeners for a type if function isn't specified
                delete this._events[type];
                return;
            }
            if (typeof fn !== "function") {
                console.warn("wrong listener type: " + (typeof fn === "undefined" ? "undefined" : (0, _typeOf._)(fn)));
                return;
            }
            // find fn and remove it
            var index = this._listens(type, fn, context);
            if (index !== false) {
                var listener = listeners[index];
                if (this._firingCount) {
                    // set the removed listener to noop so that's not called if remove happens in fire
                    listener.fn = falseFn;
                    /* copy array in case events are being fired */ this._events[type] = listeners = listeners.slice();
                }
                listeners.splice(index, 1);
            }
        },
        // @method fire(type: String, data?: Object, propagate?: Boolean): this
        // Fires an event of the specified type. You can optionally provide a data
        // object  the first argument of the listener function will contain its
        // properties. The event can optionally be propagated to event parents.
        fire: function fire(type, data, propagate) {
            if (!this.listens(type, propagate)) return this;
            var event = extend({}, data, {
                type: type,
                target: this,
                sourceTarget: data && data.sourceTarget || this
            });
            if (this._events) {
                var listeners = this._events[type];
                if (listeners) {
                    this._firingCount = this._firingCount + 1 || 1;
                    for(var i = 0, len = listeners.length; i < len; i++){
                        var l = listeners[i];
                        // off overwrites l.fn, so we need to copy fn to a var
                        var fn = l.fn;
                        if (l.once) this.off(type, fn, l.ctx);
                        fn.call(l.ctx || this, event);
                    }
                    this._firingCount--;
                }
            }
            if (propagate) // propagate the event to parents (set with addEventParent)
            this._propagateEvent(event);
            return this;
        },
        // @method listens(type: String, propagate?: Boolean): Boolean
        // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
        // Returns `true` if a particular event type has any listeners attached to it.
        // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
        listens: function listens(type, fn, context, propagate) {
            if (typeof type !== "string") console.warn('"string" type argument expected');
            // we don't overwrite the input `fn` value, because we need to use it for propagation
            var _fn = fn;
            if (typeof fn !== "function") {
                propagate = !!fn;
                _fn = undefined;
                context = undefined;
            }
            var listeners = this._events && this._events[type];
            if (listeners && listeners.length) {
                if (this._listens(type, _fn, context) !== false) return true;
            }
            if (propagate) // also check parents for listeners if event propagates
            for(var id in this._eventParents){
                if (this._eventParents[id].listens(type, fn, context, propagate)) return true;
            }
            return false;
        },
        // returns the index (number) or false
        _listens: function _listens(type, fn, context) {
            if (!this._events) return false;
            var listeners = this._events[type] || [];
            if (!fn) return !!listeners.length;
            if (context === this) // Less memory footprint.
            context = undefined;
            for(var i = 0, len = listeners.length; i < len; i++){
                if (listeners[i].fn === fn && listeners[i].ctx === context) return i;
            }
            return false;
        },
        // @method once(): this
        // Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
        once: function once(types, fn, context) {
            // types can be a map of types/handlers
            if (typeof types === "object") for(var type in types)// we don't process space-separated events here for performance;
            // it's a hot path since Layer uses the on(obj) syntax
            this._on(type, types[type], fn, true);
            else {
                // types can be a string of space-separated words
                types = splitWords(types);
                for(var i = 0, len = types.length; i < len; i++)this._on(types[i], fn, context, true);
            }
            return this;
        },
        // @method addEventParent(obj: Evented): this
        // Adds an event parent - an `Evented` that will receive propagated events
        addEventParent: function addEventParent(obj) {
            this._eventParents = this._eventParents || {};
            this._eventParents[stamp(obj)] = obj;
            return this;
        },
        // @method removeEventParent(obj: Evented): this
        // Removes an event parent, so it will stop receiving propagated events
        removeEventParent: function removeEventParent(obj) {
            if (this._eventParents) delete this._eventParents[stamp(obj)];
            return this;
        },
        _propagateEvent: function _propagateEvent(e) {
            for(var id in this._eventParents)this._eventParents[id].fire(e.type, extend({
                layer: e.target,
                propagatedFrom: e.target
            }, e), true);
        }
    };
    // aliases; we should ditch those eventually
    // @method addEventListener(): this
    // Alias to [`on()`](#evented-on)
    Events.addEventListener = Events.on;
    // @method removeEventListener(): this
    // Alias to [`off()`](#evented-off)
    // @method clearAllEventListeners(): this
    // Alias to [`off()`](#evented-off)
    Events.removeEventListener = Events.clearAllEventListeners = Events.off;
    // @method addOneTimeEventListener(): this
    // Alias to [`once()`](#evented-once)
    Events.addOneTimeEventListener = Events.once;
    // @method fireEvent(): this
    // Alias to [`fire()`](#evented-fire)
    Events.fireEvent = Events.fire;
    // @method hasEventListeners(): Boolean
    // Alias to [`listens()`](#evented-listens)
    Events.hasEventListeners = Events.listens;
    var Evented = Class.extend(Events);
    /*
   * @class Point
   * @aka L.Point
   *
   * Represents a point with `x` and `y` coordinates in pixels.
   *
   * @example
   *
   * ```js
   * var point = L.point(200, 300);
   * ```
   *
   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
   *
   * ```js
   * map.panBy([200, 300]);
   * map.panBy(L.point(200, 300));
   * ```
   *
   * Note that `Point` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */ function Point(x, y, round) {
        // @property x: Number; The `x` coordinate of the point
        this.x = round ? Math.round(x) : x;
        // @property y: Number; The `y` coordinate of the point
        this.y = round ? Math.round(y) : y;
    }
    var trunc = Math.trunc || function(v) {
        return v > 0 ? Math.floor(v) : Math.ceil(v);
    };
    Point.prototype = {
        // @method clone(): Point
        // Returns a copy of the current point.
        clone: function clone() {
            return new Point(this.x, this.y);
        },
        // @method add(otherPoint: Point): Point
        // Returns the result of addition of the current and the given points.
        add: function add(point) {
            // non-destructive, returns a new point
            return this.clone()._add(toPoint(point));
        },
        _add: function _add(point) {
            // destructive, used directly for performance in situations where it's safe to modify existing point
            this.x += point.x;
            this.y += point.y;
            return this;
        },
        // @method subtract(otherPoint: Point): Point
        // Returns the result of subtraction of the given point from the current.
        subtract: function subtract(point) {
            return this.clone()._subtract(toPoint(point));
        },
        _subtract: function _subtract(point) {
            this.x -= point.x;
            this.y -= point.y;
            return this;
        },
        // @method divideBy(num: Number): Point
        // Returns the result of division of the current point by the given number.
        divideBy: function divideBy(num) {
            return this.clone()._divideBy(num);
        },
        _divideBy: function _divideBy(num) {
            this.x /= num;
            this.y /= num;
            return this;
        },
        // @method multiplyBy(num: Number): Point
        // Returns the result of multiplication of the current point by the given number.
        multiplyBy: function multiplyBy(num) {
            return this.clone()._multiplyBy(num);
        },
        _multiplyBy: function _multiplyBy(num) {
            this.x *= num;
            this.y *= num;
            return this;
        },
        // @method scaleBy(scale: Point): Point
        // Multiply each coordinate of the current point by each coordinate of
        // `scale`. In linear algebra terms, multiply the point by the
        // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
        // defined by `scale`.
        scaleBy: function scaleBy(point) {
            return new Point(this.x * point.x, this.y * point.y);
        },
        // @method unscaleBy(scale: Point): Point
        // Inverse of `scaleBy`. Divide each coordinate of the current point by
        // each coordinate of `scale`.
        unscaleBy: function unscaleBy(point) {
            return new Point(this.x / point.x, this.y / point.y);
        },
        // @method round(): Point
        // Returns a copy of the current point with rounded coordinates.
        round: function round() {
            return this.clone()._round();
        },
        _round: function _round() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        },
        // @method floor(): Point
        // Returns a copy of the current point with floored coordinates (rounded down).
        floor: function floor() {
            return this.clone()._floor();
        },
        _floor: function _floor() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
        },
        // @method ceil(): Point
        // Returns a copy of the current point with ceiled coordinates (rounded up).
        ceil: function ceil() {
            return this.clone()._ceil();
        },
        _ceil: function _ceil() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
        },
        // @method trunc(): Point
        // Returns a copy of the current point with truncated coordinates (rounded towards zero).
        trunc: function trunc() {
            return this.clone()._trunc();
        },
        _trunc: function _trunc() {
            this.x = trunc(this.x);
            this.y = trunc(this.y);
            return this;
        },
        // @method distanceTo(otherPoint: Point): Number
        // Returns the cartesian distance between the current and the given points.
        distanceTo: function distanceTo(point) {
            point = toPoint(point);
            var x = point.x - this.x, y = point.y - this.y;
            return Math.sqrt(x * x + y * y);
        },
        // @method equals(otherPoint: Point): Boolean
        // Returns `true` if the given point has the same coordinates.
        equals: function equals(point) {
            point = toPoint(point);
            return point.x === this.x && point.y === this.y;
        },
        // @method contains(otherPoint: Point): Boolean
        // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
        contains: function contains(point) {
            point = toPoint(point);
            return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
        },
        // @method toString(): String
        // Returns a string representation of the point for debugging purposes.
        toString: function toString() {
            return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
        }
    };
    // @factory L.point(x: Number, y: Number, round?: Boolean)
    // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.
    // @alternative
    // @factory L.point(coords: Number[])
    // Expects an array of the form `[x, y]` instead.
    // @alternative
    // @factory L.point(coords: Object)
    // Expects a plain object of the form `{x: Number, y: Number}` instead.
    function toPoint(x, y, round) {
        if (x instanceof Point) return x;
        if (isArray(x)) return new Point(x[0], x[1]);
        if (x === undefined || x === null) return x;
        if (typeof x === "object" && "x" in x && "y" in x) return new Point(x.x, x.y);
        return new Point(x, y, round);
    }
    /*
   * @class Bounds
   * @aka L.Bounds
   *
   * Represents a rectangular area in pixel coordinates.
   *
   * @example
   *
   * ```js
   * var p1 = L.point(10, 10),
   * p2 = L.point(40, 60),
   * bounds = L.bounds(p1, p2);
   * ```
   *
   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * otherBounds.intersects([[10, 10], [40, 60]]);
   * ```
   *
   * Note that `Bounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */ function Bounds(a, b) {
        if (!a) return;
        var points = b ? [
            a,
            b
        ] : a;
        for(var i = 0, len = points.length; i < len; i++)this.extend(points[i]);
    }
    Bounds.prototype = {
        // @method extend(point: Point): this
        // Extends the bounds to contain the given point.
        // @alternative
        // @method extend(otherBounds: Bounds): this
        // Extend the bounds to contain the given bounds
        extend: function extend(obj) {
            var min2, max2;
            if (!obj) return this;
            if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) min2 = max2 = toPoint(obj);
            else {
                obj = toBounds(obj);
                min2 = obj.min;
                max2 = obj.max;
                if (!min2 || !max2) return this;
            }
            // @property min: Point
            // The top left corner of the rectangle.
            // @property max: Point
            // The bottom right corner of the rectangle.
            if (!this.min && !this.max) {
                this.min = min2.clone();
                this.max = max2.clone();
            } else {
                this.min.x = Math.min(min2.x, this.min.x);
                this.max.x = Math.max(max2.x, this.max.x);
                this.min.y = Math.min(min2.y, this.min.y);
                this.max.y = Math.max(max2.y, this.max.y);
            }
            return this;
        },
        // @method getCenter(round?: Boolean): Point
        // Returns the center point of the bounds.
        getCenter: function getCenter(round) {
            return toPoint((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
        },
        // @method getBottomLeft(): Point
        // Returns the bottom-left point of the bounds.
        getBottomLeft: function getBottomLeft() {
            return toPoint(this.min.x, this.max.y);
        },
        // @method getTopRight(): Point
        // Returns the top-right point of the bounds.
        getTopRight: function getTopRight() {
            return toPoint(this.max.x, this.min.y);
        },
        // @method getTopLeft(): Point
        // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
        getTopLeft: function getTopLeft() {
            return this.min; // left, top
        },
        // @method getBottomRight(): Point
        // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
        getBottomRight: function getBottomRight() {
            return this.max; // right, bottom
        },
        // @method getSize(): Point
        // Returns the size of the given bounds
        getSize: function getSize() {
            return this.max.subtract(this.min);
        },
        // @method contains(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains(point: Point): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function contains(obj) {
            var min, max;
            if (typeof obj[0] === "number" || obj instanceof Point) obj = toPoint(obj);
            else obj = toBounds(obj);
            if (obj instanceof Bounds) {
                min = obj.min;
                max = obj.max;
            } else min = max = obj;
            return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
        },
        // @method intersects(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds
        // intersect if they have at least one point in common.
        intersects: function intersects(bounds) {
            bounds = toBounds(bounds);
            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
            return xIntersects && yIntersects;
        },
        // @method overlaps(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds
        // overlap if their intersection is an area.
        overlaps: function overlaps(bounds) {
            bounds = toBounds(bounds);
            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
            return xOverlaps && yOverlaps;
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function isValid() {
            return !!(this.min && this.max);
        },
        // @method pad(bufferRatio: Number): Bounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function pad(bufferRatio) {
            var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio, widthBuffer = Math.abs(min.y - max.y) * bufferRatio;
            return toBounds(toPoint(min.x - heightBuffer, min.y - widthBuffer), toPoint(max.x + heightBuffer, max.y + widthBuffer));
        },
        // @method equals(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle is equivalent to the given bounds.
        equals: function equals(bounds) {
            if (!bounds) return false;
            bounds = toBounds(bounds);
            return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
        }
    };
    // @factory L.bounds(corner1: Point, corner2: Point)
    // Creates a Bounds object from two corners coordinate pairs.
    // @alternative
    // @factory L.bounds(points: Point[])
    // Creates a Bounds object from the given array of points.
    function toBounds(a, b) {
        if (!a || a instanceof Bounds) return a;
        return new Bounds(a, b);
    }
    /*
   * @class LatLngBounds
   * @aka L.LatLngBounds
   *
   * Represents a rectangular geographical area on a map.
   *
   * @example
   *
   * ```js
   * var corner1 = L.latLng(40.712, -74.227),
   * corner2 = L.latLng(40.774, -74.125),
   * bounds = L.latLngBounds(corner1, corner2);
   * ```
   *
   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * map.fitBounds([
   * 	[40.712, -74.227],
   * 	[40.774, -74.125]
   * ]);
   * ```
   *
   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
   *
   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */ function LatLngBounds(corner1, corner2) {
        if (!corner1) return;
        var latlngs = corner2 ? [
            corner1,
            corner2
        ] : corner1;
        for(var i = 0, len = latlngs.length; i < len; i++)this.extend(latlngs[i]);
    }
    LatLngBounds.prototype = {
        // @method extend(latlng: LatLng): this
        // Extend the bounds to contain the given point
        // @alternative
        // @method extend(otherBounds: LatLngBounds): this
        // Extend the bounds to contain the given bounds
        extend: function extend(obj) {
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof LatLng) {
                sw2 = obj;
                ne2 = obj;
            } else if (obj instanceof LatLngBounds) {
                sw2 = obj._southWest;
                ne2 = obj._northEast;
                if (!sw2 || !ne2) return this;
            } else return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
            if (!sw && !ne) {
                this._southWest = new LatLng(sw2.lat, sw2.lng);
                this._northEast = new LatLng(ne2.lat, ne2.lng);
            } else {
                sw.lat = Math.min(sw2.lat, sw.lat);
                sw.lng = Math.min(sw2.lng, sw.lng);
                ne.lat = Math.max(ne2.lat, ne.lat);
                ne.lng = Math.max(ne2.lng, ne.lng);
            }
            return this;
        },
        // @method pad(bufferRatio: Number): LatLngBounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function pad(bufferRatio) {
            var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
            return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
        },
        // @method getCenter(): LatLng
        // Returns the center point of the bounds.
        getCenter: function getCenter() {
            return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
        },
        // @method getSouthWest(): LatLng
        // Returns the south-west point of the bounds.
        getSouthWest: function getSouthWest() {
            return this._southWest;
        },
        // @method getNorthEast(): LatLng
        // Returns the north-east point of the bounds.
        getNorthEast: function getNorthEast() {
            return this._northEast;
        },
        // @method getNorthWest(): LatLng
        // Returns the north-west point of the bounds.
        getNorthWest: function getNorthWest() {
            return new LatLng(this.getNorth(), this.getWest());
        },
        // @method getSouthEast(): LatLng
        // Returns the south-east point of the bounds.
        getSouthEast: function getSouthEast() {
            return new LatLng(this.getSouth(), this.getEast());
        },
        // @method getWest(): Number
        // Returns the west longitude of the bounds
        getWest: function getWest() {
            return this._southWest.lng;
        },
        // @method getSouth(): Number
        // Returns the south latitude of the bounds
        getSouth: function getSouth() {
            return this._southWest.lat;
        },
        // @method getEast(): Number
        // Returns the east longitude of the bounds
        getEast: function getEast() {
            return this._northEast.lng;
        },
        // @method getNorth(): Number
        // Returns the north latitude of the bounds
        getNorth: function getNorth() {
            return this._northEast.lat;
        },
        // @method contains(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains (latlng: LatLng): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function contains(obj) {
            if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) obj = toLatLng(obj);
            else obj = toLatLngBounds(obj);
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof LatLngBounds) {
                sw2 = obj.getSouthWest();
                ne2 = obj.getNorthEast();
            } else sw2 = ne2 = obj;
            return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
        },
        // @method intersects(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
        intersects: function intersects(bounds) {
            bounds = toLatLngBounds(bounds);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
            return latIntersects && lngIntersects;
        },
        // @method overlaps(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
        overlaps: function overlaps(bounds) {
            bounds = toLatLngBounds(bounds);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
            return latOverlaps && lngOverlaps;
        },
        // @method toBBoxString(): String
        // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
        toBBoxString: function toBBoxString() {
            return [
                this.getWest(),
                this.getSouth(),
                this.getEast(),
                this.getNorth()
            ].join(",");
        },
        // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
        // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function equals(bounds, maxMargin) {
            if (!bounds) return false;
            bounds = toLatLngBounds(bounds);
            return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function isValid() {
            return !!(this._southWest && this._northEast);
        }
    };
    // TODO International date line?
    // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
    // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.
    // @alternative
    // @factory L.latLngBounds(latlngs: LatLng[])
    // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
    function toLatLngBounds(a, b) {
        if (a instanceof LatLngBounds) return a;
        return new LatLngBounds(a, b);
    }
    /* @class LatLng
   * @aka L.LatLng
   *
   * Represents a geographical point with a certain latitude and longitude.
   *
   * @example
   *
   * ```
   * var latlng = L.latLng(50.5, 30.5);
   * ```
   *
   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
   *
   * ```
   * map.panTo([50, 30]);
   * map.panTo({lon: 30, lat: 50});
   * map.panTo({lat: 50, lng: 30});
   * map.panTo(L.latLng(50, 30));
   * ```
   *
   * Note that `LatLng` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */ function LatLng(lat, lng, alt) {
        if (isNaN(lat) || isNaN(lng)) throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
        // @property lat: Number
        // Latitude in degrees
        this.lat = +lat;
        // @property lng: Number
        // Longitude in degrees
        this.lng = +lng;
        // @property alt: Number
        // Altitude in meters (optional)
        if (alt !== undefined) this.alt = +alt;
    }
    LatLng.prototype = {
        // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
        // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function equals(obj, maxMargin) {
            if (!obj) return false;
            obj = toLatLng(obj);
            var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));
            return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
        },
        // @method toString(): String
        // Returns a string representation of the point (for debugging purposes).
        toString: function toString(precision) {
            return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
        },
        // @method distanceTo(otherLatLng: LatLng): Number
        // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
        distanceTo: function distanceTo(other) {
            return Earth.distance(this, toLatLng(other));
        },
        // @method wrap(): LatLng
        // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
        wrap: function wrap() {
            return Earth.wrapLatLng(this);
        },
        // @method toBounds(sizeInMeters: Number): LatLngBounds
        // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
        toBounds: function toBounds(sizeInMeters) {
            var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
            return toLatLngBounds([
                this.lat - latAccuracy,
                this.lng - lngAccuracy
            ], [
                this.lat + latAccuracy,
                this.lng + lngAccuracy
            ]);
        },
        clone: function clone() {
            return new LatLng(this.lat, this.lng, this.alt);
        }
    };
    // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
    // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).
    // @alternative
    // @factory L.latLng(coords: Array): LatLng
    // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.
    // @alternative
    // @factory L.latLng(coords: Object): LatLng
    // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.
    function toLatLng(a, b, c) {
        if (a instanceof LatLng) return a;
        if (isArray(a) && typeof a[0] !== "object") {
            if (a.length === 3) return new LatLng(a[0], a[1], a[2]);
            if (a.length === 2) return new LatLng(a[0], a[1]);
            return null;
        }
        if (a === undefined || a === null) return a;
        if (typeof a === "object" && "lat" in a) return new LatLng(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
        if (b === undefined) return null;
        return new LatLng(a, b, c);
    }
    /*
   * @namespace CRS
   * @crs L.CRS.Base
   * Object that defines coordinate reference systems for projecting
   * geographical points into pixel (screen) coordinates and back (and to
   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
   * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).
   *
   * Leaflet defines the most usual CRSs by default. If you want to use a
   * CRS not defined by default, take a look at the
   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
   *
   * Note that the CRS instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.
   */ var CRS = {
        // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
        // Projects geographical coordinates into pixel coordinates for a given zoom.
        latLngToPoint: function latLngToPoint(latlng, zoom) {
            var projectedPoint = this.projection.project(latlng), scale = this.scale(zoom);
            return this.transformation._transform(projectedPoint, scale);
        },
        // @method pointToLatLng(point: Point, zoom: Number): LatLng
        // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
        // zoom into geographical coordinates.
        pointToLatLng: function pointToLatLng(point, zoom) {
            var scale = this.scale(zoom), untransformedPoint = this.transformation.untransform(point, scale);
            return this.projection.unproject(untransformedPoint);
        },
        // @method project(latlng: LatLng): Point
        // Projects geographical coordinates into coordinates in units accepted for
        // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
        project: function project(latlng) {
            return this.projection.project(latlng);
        },
        // @method unproject(point: Point): LatLng
        // Given a projected coordinate returns the corresponding LatLng.
        // The inverse of `project`.
        unproject: function unproject(point) {
            return this.projection.unproject(point);
        },
        // @method scale(zoom: Number): Number
        // Returns the scale used when transforming projected coordinates into
        // pixel coordinates for a particular zoom. For example, it returns
        // `256 * 2^zoom` for Mercator-based CRS.
        scale: function scale(zoom) {
            return 256 * Math.pow(2, zoom);
        },
        // @method zoom(scale: Number): Number
        // Inverse of `scale()`, returns the zoom level corresponding to a scale
        // factor of `scale`.
        zoom: function zoom(scale) {
            return Math.log(scale / 256) / Math.LN2;
        },
        // @method getProjectedBounds(zoom: Number): Bounds
        // Returns the projection's bounds scaled and transformed for the provided `zoom`.
        getProjectedBounds: function getProjectedBounds(zoom) {
            if (this.infinite) return null;
            var b = this.projection.bounds, s = this.scale(zoom), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);
            return new Bounds(min, max);
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates.
        // @property code: String
        // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
        //
        // @property wrapLng: Number[]
        // An array of two numbers defining whether the longitude (horizontal) coordinate
        // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
        // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
        //
        // @property wrapLat: Number[]
        // Like `wrapLng`, but for the latitude (vertical) axis.
        // wrapLng: [min, max],
        // wrapLat: [min, max],
        // @property infinite: Boolean
        // If true, the coordinate space will be unbounded (infinite in both axes)
        infinite: false,
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where lat and lng has been wrapped according to the
        // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
        wrapLatLng: function wrapLatLng(latlng) {
            var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
            return new LatLng(lat, lng, alt);
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring
        // that its center is within the CRS's bounds.
        // Only accepts actual `L.LatLngBounds` instances, not arrays.
        wrapLatLngBounds: function wrapLatLngBounds(bounds) {
            var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
            if (latShift === 0 && lngShift === 0) return bounds;
            var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
            return new LatLngBounds(newSw, newNe);
        }
    };
    /*
   * @namespace CRS
   * @crs L.CRS.Earth
   *
   * Serves as the base for CRS that are global such that they cover the earth.
   * Can only be used as the base for other CRS and cannot be used directly,
   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
   * meters.
   */ var Earth = extend({}, CRS, {
        wrapLng: [
            -180,
            180
        ],
        // Mean Earth Radius, as recommended for use by
        // the International Union of Geodesy and Geophysics,
        // see https://rosettacode.org/wiki/Haversine_formula
        R: 6371000,
        // distance between two geographical points using spherical law of cosines approximation
        distance: function distance(latlng1, latlng2) {
            var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return this.R * c;
        }
    });
    /*
   * @namespace Projection
   * @projection L.Projection.SphericalMercator
   *
   * Spherical Mercator projection  the most common projection for online maps,
   * used by almost all free and commercial tile providers. Assumes that Earth is
   * a sphere. Used by the `EPSG:3857` CRS.
   */ var earthRadius = 6378137;
    var SphericalMercator = {
        R: earthRadius,
        MAX_LATITUDE: 85.0511287798,
        project: function project(latlng) {
            var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);
            return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);
        },
        unproject: function unproject(point) {
            var d = 180 / Math.PI;
            return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);
        },
        bounds: function() {
            var d = earthRadius * Math.PI;
            return new Bounds([
                -d,
                -d
            ], [
                d,
                d
            ]);
        }()
    };
    /*
   * @class Transformation
   * @aka L.Transformation
   *
   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
   * the reverse. Used by Leaflet in its projections code.
   *
   * @example
   *
   * ```js
   * var transformation = L.transformation(2, 5, -1, 10),
   * 	p = L.point(1, 2),
   * 	p2 = transformation.transform(p), //  L.point(7, 8)
   * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
   * ```
   */ // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
    // Creates a `Transformation` object with the given coefficients.
    function Transformation(a, b, c, d) {
        if (isArray(a)) {
            // use array properties
            this._a = a[0];
            this._b = a[1];
            this._c = a[2];
            this._d = a[3];
            return;
        }
        this._a = a;
        this._b = b;
        this._c = c;
        this._d = d;
    }
    Transformation.prototype = {
        // @method transform(point: Point, scale?: Number): Point
        // Returns a transformed point, optionally multiplied by the given scale.
        // Only accepts actual `L.Point` instances, not arrays.
        transform: function transform(point, scale) {
            return this._transform(point.clone(), scale);
        },
        // destructive transform (faster)
        _transform: function _transform(point, scale) {
            scale = scale || 1;
            point.x = scale * (this._a * point.x + this._b);
            point.y = scale * (this._c * point.y + this._d);
            return point;
        },
        // @method untransform(point: Point, scale?: Number): Point
        // Returns the reverse transformation of the given point, optionally divided
        // by the given scale. Only accepts actual `L.Point` instances, not arrays.
        untransform: function untransform(point, scale) {
            scale = scale || 1;
            return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
        }
    };
    // factory L.transformation(a: Number, b: Number, c: Number, d: Number)
    // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
    // Instantiates a Transformation object with the given coefficients.
    // @alternative
    // @factory L.transformation(coefficients: Array): Transformation
    // Expects an coefficients array of the form
    // `[a: Number, b: Number, c: Number, d: Number]`.
    function toTransformation(a, b, c, d) {
        return new Transformation(a, b, c, d);
    }
    /*
   * @namespace CRS
   * @crs L.CRS.EPSG3857
   *
   * The most common CRS for online maps, used by almost all free and commercial
   * tile providers. Uses Spherical Mercator projection. Set in by default in
   * Map's `crs` option.
   */ var EPSG3857 = extend({}, Earth, {
        code: "EPSG:3857",
        projection: SphericalMercator,
        transformation: function() {
            var scale = 0.5 / (Math.PI * SphericalMercator.R);
            return toTransformation(scale, 0.5, -scale, 0.5);
        }()
    });
    var EPSG900913 = extend({}, EPSG3857, {
        code: "EPSG:900913"
    });
    // @namespace SVG; @section
    // There are several static functions which can be called without instantiating L.SVG:
    // @function create(name: String): SVGElement
    // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
    // corresponding to the class name passed. For example, using 'line' will return
    // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
    function svgCreate(name) {
        return document.createElementNS("http://www.w3.org/2000/svg", name);
    }
    // @function pointsToPath(rings: Point[], closed: Boolean): String
    // Generates a SVG path string for multiple rings, with each ring turning
    // into "M..L..L.." instructions
    function pointsToPath(rings, closed) {
        var str = "", i, j, len, len2, points, p;
        for(i = 0, len = rings.length; i < len; i++){
            points = rings[i];
            for(j = 0, len2 = points.length; j < len2; j++){
                p = points[j];
                str += (j ? "L" : "M") + p.x + " " + p.y;
            }
            // closes the ring for polygons; "x" is VML syntax
            str += closed ? Browser.svg ? "z" : "x" : "";
        }
        // SVG complains about empty path strings
        return str || "M0 0";
    }
    /*
   * @namespace Browser
   * @aka L.Browser
   *
   * A namespace with static properties for browser/feature detection used by Leaflet internally.
   *
   * @example
   *
   * ```js
   * if (L.Browser.ielt9) {
   *   alert('Upgrade your browser, dude!');
   * }
   * ```
   */ var style = document.documentElement.style;
    // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
    var ie = "ActiveXObject" in window;
    // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
    var ielt9 = ie && !document.addEventListener;
    // @property edge: Boolean; `true` for the Edge web browser.
    var edge = "msLaunchUri" in navigator && !("documentMode" in document);
    // @property webkit: Boolean;
    // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
    var webkit = userAgentContains("webkit");
    // @property android: Boolean
    // **Deprecated.** `true` for any browser running on an Android platform.
    var android = userAgentContains("android");
    // @property android23: Boolean; **Deprecated.** `true` for browsers running on Android 2 or Android 3.
    var android23 = userAgentContains("android 2") || userAgentContains("android 3");
    /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */ var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
    // @property androidStock: Boolean; **Deprecated.** `true` for the Android stock browser (i.e. not Chrome)
    var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
    // @property opera: Boolean; `true` for the Opera browser
    var opera = !!window.opera;
    // @property chrome: Boolean; `true` for the Chrome browser.
    var chrome = !edge && userAgentContains("chrome");
    // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
    var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
    // @property safari: Boolean; `true` for the Safari browser.
    var safari = !chrome && userAgentContains("safari");
    var phantom = userAgentContains("phantom");
    // @property opera12: Boolean
    // `true` for the Opera browser supporting CSS transforms (version 12 or later).
    var opera12 = "OTransition" in style;
    // @property win: Boolean; `true` when the browser is running in a Windows platform
    var win = navigator.platform.indexOf("Win") === 0;
    // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
    var ie3d = ie && "transition" in style;
    // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
    var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
    // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
    var gecko3d = "MozPerspective" in style;
    // @property any3d: Boolean
    // `true` for all browsers supporting CSS transforms.
    var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
    // @property mobile: Boolean; `true` for all browsers running in a mobile device.
    var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
    // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
    var mobileWebkit = mobile && webkit;
    // @property mobileWebkit3d: Boolean
    // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
    var mobileWebkit3d = mobile && webkit3d;
    // @property msPointer: Boolean
    // `true` for browsers implementing the Microsoft touch events model (notably IE10).
    var msPointer = !window.PointerEvent && window.MSPointerEvent;
    // @property pointer: Boolean
    // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
    var pointer = !!(window.PointerEvent || msPointer);
    // @property touchNative: Boolean
    // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
    // **This does not necessarily mean** that the browser is running in a computer with
    // a touchscreen, it only means that the browser is capable of understanding
    // touch events.
    var touchNative = "ontouchstart" in window || !!window.TouchEvent;
    // @property touch: Boolean
    // `true` for all browsers supporting either [touch](#browser-touch) or [pointer](#browser-pointer) events.
    // Note: pointer events will be preferred (if available), and processed for all `touch*` listeners.
    var touch = !window.L_NO_TOUCH && (touchNative || pointer);
    // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
    var mobileOpera = mobile && opera;
    // @property mobileGecko: Boolean
    // `true` for gecko-based browsers running in a mobile device.
    var mobileGecko = mobile && gecko;
    // @property retina: Boolean
    // `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.
    var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
    // @property passiveEvents: Boolean
    // `true` for browsers that support passive events.
    var passiveEvents = function() {
        var supportsPassiveOption = false;
        try {
            var opts = Object.defineProperty({}, "passive", {
                get: function get() {
                    supportsPassiveOption = true;
                }
            });
            window.addEventListener("testPassiveEventSupport", falseFn, opts);
            window.removeEventListener("testPassiveEventSupport", falseFn, opts);
        } catch (e) {
        // Errors can safely be ignored since this is only a browser support test.
        }
        return supportsPassiveOption;
    }();
    // @property canvas: Boolean
    // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
    var canvas$1 = function() {
        return !!document.createElement("canvas").getContext;
    }();
    // @property svg: Boolean
    // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
    var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
    var inlineSvg = !!svg$1 && function() {
        var div = document.createElement("div");
        div.innerHTML = "<svg/>";
        return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
    }();
    // @property vml: Boolean
    // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
    var vml = !svg$1 && function() {
        try {
            var div = document.createElement("div");
            div.innerHTML = '<v:shape adj="1"/>';
            var shape = div.firstChild;
            shape.style.behavior = "url(#default#VML)";
            return shape && typeof shape.adj === "object";
        } catch (e) {
            return false;
        }
    }();
    // @property mac: Boolean; `true` when the browser is running in a Mac platform
    var mac = navigator.platform.indexOf("Mac") === 0;
    // @property mac: Boolean; `true` when the browser is running in a Linux platform
    var linux = navigator.platform.indexOf("Linux") === 0;
    function userAgentContains(str) {
        return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
    }
    var Browser = {
        ie: ie,
        ielt9: ielt9,
        edge: edge,
        webkit: webkit,
        android: android,
        android23: android23,
        androidStock: androidStock,
        opera: opera,
        chrome: chrome,
        gecko: gecko,
        safari: safari,
        phantom: phantom,
        opera12: opera12,
        win: win,
        ie3d: ie3d,
        webkit3d: webkit3d,
        gecko3d: gecko3d,
        any3d: any3d,
        mobile: mobile,
        mobileWebkit: mobileWebkit,
        mobileWebkit3d: mobileWebkit3d,
        msPointer: msPointer,
        pointer: pointer,
        touch: touch,
        touchNative: touchNative,
        mobileOpera: mobileOpera,
        mobileGecko: mobileGecko,
        retina: retina,
        passiveEvents: passiveEvents,
        canvas: canvas$1,
        svg: svg$1,
        vml: vml,
        inlineSvg: inlineSvg,
        mac: mac,
        linux: linux
    };
    /*
   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
   */ var POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown";
    var POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove";
    var POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup";
    var POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel";
    var pEvent = {
        touchstart: POINTER_DOWN,
        touchmove: POINTER_MOVE,
        touchend: POINTER_UP,
        touchcancel: POINTER_CANCEL
    };
    var handle = {
        touchstart: _onPointerStart,
        touchmove: _handlePointer,
        touchend: _handlePointer,
        touchcancel: _handlePointer
    };
    var _pointers = {};
    var _pointerDocListener = false;
    // Provides a touch events wrapper for (ms)pointer events.
    // ref https://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890
    function addPointerListener(obj, type, handler) {
        if (type === "touchstart") _addPointerDocListener();
        if (!handle[type]) {
            console.warn("wrong event specified:", type);
            return falseFn;
        }
        handler = handle[type].bind(this, handler);
        obj.addEventListener(pEvent[type], handler, false);
        return handler;
    }
    function removePointerListener(obj, type, handler) {
        if (!pEvent[type]) {
            console.warn("wrong event specified:", type);
            return;
        }
        obj.removeEventListener(pEvent[type], handler, false);
    }
    function _globalPointerDown(e) {
        _pointers[e.pointerId] = e;
    }
    function _globalPointerMove(e) {
        if (_pointers[e.pointerId]) _pointers[e.pointerId] = e;
    }
    function _globalPointerUp(e) {
        delete _pointers[e.pointerId];
    }
    function _addPointerDocListener() {
        // need to keep track of what pointers and how many are active to provide e.touches emulation
        if (!_pointerDocListener) {
            // we listen document as any drags that end by moving the touch off the screen get fired there
            document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
            document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
            document.addEventListener(POINTER_UP, _globalPointerUp, true);
            document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
            _pointerDocListener = true;
        }
    }
    function _handlePointer(handler, e) {
        if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) return;
        e.touches = [];
        for(var i in _pointers)e.touches.push(_pointers[i]);
        e.changedTouches = [
            e
        ];
        handler(e);
    }
    function _onPointerStart(handler, e) {
        // IE10 specific: MsTouch needs preventDefault. See #2000
        if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) preventDefault(e);
        _handlePointer(handler, e);
    }
    /*
   * Extends the event handling code with double tap support for mobile browsers.
   *
   * Note: currently most browsers fire native dblclick, with only a few exceptions
   * (see https://github.com/Leaflet/Leaflet/issues/7012#issuecomment-595087386)
   */ function makeDblclick(event) {
        // in modern browsers `type` cannot be just overridden:
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only
        var newEvent = {}, prop, i;
        for(i in event){
            prop = event[i];
            newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
        }
        event = newEvent;
        newEvent.type = "dblclick";
        newEvent.detail = 2;
        newEvent.isTrusted = false;
        newEvent._simulated = true; // for debug purposes
        return newEvent;
    }
    var delay = 200;
    function addDoubleTapListener(obj, handler) {
        // Most browsers handle double tap natively
        obj.addEventListener("dblclick", handler);
        // On some platforms the browser doesn't fire native dblclicks for touch events.
        // It seems that in all such cases `detail` property of `click` event is always `1`.
        // So here we rely on that fact to avoid excessive 'dblclick' simulation when not needed.
        var last = 0, detail;
        function simDblclick(e) {
            if (e.detail !== 1) {
                detail = e.detail; // keep in sync to avoid false dblclick in some cases
                return;
            }
            if (e.pointerType === "mouse" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) return;
            // When clicking on an <input>, the browser generates a click on its
            // <label> (and vice versa) triggering two clicks in quick succession.
            // This ignores clicks on elements which are a label with a 'for'
            // attribute (or children of such a label), but not children of
            // a <input>.
            var path = getPropagationPath(e);
            if (path.some(function(el) {
                return el instanceof HTMLLabelElement && el.attributes.for;
            }) && !path.some(function(el) {
                return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
            })) return;
            var now = Date.now();
            if (now - last <= delay) {
                detail++;
                if (detail === 2) handler(makeDblclick(e));
            } else detail = 1;
            last = now;
        }
        obj.addEventListener("click", simDblclick);
        return {
            dblclick: handler,
            simDblclick: simDblclick
        };
    }
    function removeDoubleTapListener(obj, handlers) {
        obj.removeEventListener("dblclick", handlers.dblclick);
        obj.removeEventListener("click", handlers.simDblclick);
    }
    /*
   * @namespace DomUtil
   *
   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
   * tree, used by Leaflet internally.
   *
   * Most functions expecting or returning a `HTMLElement` also work for
   * SVG elements. The only difference is that classes refer to CSS classes
   * in HTML and SVG classes in SVG.
   */ // @property TRANSFORM: String
    // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
    var TRANSFORM = testProp([
        "transform",
        "webkitTransform",
        "OTransform",
        "MozTransform",
        "msTransform"
    ]);
    // webkitTransition comes first because some browser versions that drop vendor prefix don't do
    // the same for the transitionend event, in particular the Android 4.1 stock browser
    // @property TRANSITION: String
    // Vendor-prefixed transition style name.
    var TRANSITION = testProp([
        "webkitTransition",
        "transition",
        "OTransition",
        "MozTransition",
        "msTransition"
    ]);
    // @property TRANSITION_END: String
    // Vendor-prefixed transitionend event name.
    var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
    // @function get(id: String|HTMLElement): HTMLElement
    // Returns an element given its DOM id, or returns the element itself
    // if it was passed directly.
    function get(id) {
        return typeof id === "string" ? document.getElementById(id) : id;
    }
    // @function getStyle(el: HTMLElement, styleAttrib: String): String
    // Returns the value for a certain style attribute on an element,
    // including computed values or values set through CSS.
    function getStyle(el, style) {
        var value = el.style[style] || el.currentStyle && el.currentStyle[style];
        if ((!value || value === "auto") && document.defaultView) {
            var css = document.defaultView.getComputedStyle(el, null);
            value = css ? css[style] : null;
        }
        return value === "auto" ? null : value;
    }
    // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
    // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
    function create$1(tagName, className, container) {
        var el = document.createElement(tagName);
        el.className = className || "";
        if (container) container.appendChild(el);
        return el;
    }
    // @function remove(el: HTMLElement)
    // Removes `el` from its parent element
    function remove(el) {
        var parent = el.parentNode;
        if (parent) parent.removeChild(el);
    }
    // @function empty(el: HTMLElement)
    // Removes all of `el`'s children elements from `el`
    function empty(el) {
        while(el.firstChild)el.removeChild(el.firstChild);
    }
    // @function toFront(el: HTMLElement)
    // Makes `el` the last child of its parent, so it renders in front of the other children.
    function toFront(el) {
        var parent = el.parentNode;
        if (parent && parent.lastChild !== el) parent.appendChild(el);
    }
    // @function toBack(el: HTMLElement)
    // Makes `el` the first child of its parent, so it renders behind the other children.
    function toBack(el) {
        var parent = el.parentNode;
        if (parent && parent.firstChild !== el) parent.insertBefore(el, parent.firstChild);
    }
    // @function hasClass(el: HTMLElement, name: String): Boolean
    // Returns `true` if the element's class attribute contains `name`.
    function hasClass(el, name) {
        if (el.classList !== undefined) return el.classList.contains(name);
        var className = getClass(el);
        return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
    }
    // @function addClass(el: HTMLElement, name: String)
    // Adds `name` to the element's class attribute.
    function addClass(el, name) {
        if (el.classList !== undefined) {
            var classes = splitWords(name);
            for(var i = 0, len = classes.length; i < len; i++)el.classList.add(classes[i]);
        } else if (!hasClass(el, name)) {
            var className = getClass(el);
            setClass(el, (className ? className + " " : "") + name);
        }
    }
    // @function removeClass(el: HTMLElement, name: String)
    // Removes `name` from the element's class attribute.
    function removeClass(el, name) {
        if (el.classList !== undefined) el.classList.remove(name);
        else setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
    }
    // @function setClass(el: HTMLElement, name: String)
    // Sets the element's class.
    function setClass(el, name) {
        if (el.className.baseVal === undefined) el.className = name;
        else // in case of SVG element
        el.className.baseVal = name;
    }
    // @function getClass(el: HTMLElement): String
    // Returns the element's class.
    function getClass(el) {
        // Check if the element is an SVGElementInstance and use the correspondingElement instead
        // (Required for linked SVG elements in IE11.)
        if (el.correspondingElement) el = el.correspondingElement;
        return el.className.baseVal === undefined ? el.className : el.className.baseVal;
    }
    // @function setOpacity(el: HTMLElement, opacity: Number)
    // Set the opacity of an element (including old IE support).
    // `opacity` must be a number from `0` to `1`.
    function setOpacity(el, value) {
        if ("opacity" in el.style) el.style.opacity = value;
        else if ("filter" in el.style) _setOpacityIE(el, value);
    }
    function _setOpacityIE(el, value) {
        var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
        // filters collection throws an error if we try to retrieve a filter that doesn't exist
        try {
            filter = el.filters.item(filterName);
        } catch (e) {
            // don't set opacity to 1 if we haven't already set an opacity,
            // it isn't needed and breaks transparent pngs.
            if (value === 1) return;
        }
        value = Math.round(value * 100);
        if (filter) {
            filter.Enabled = value !== 100;
            filter.Opacity = value;
        } else el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
    }
    // @function testProp(props: String[]): String|false
    // Goes through the array of style names and returns the first name
    // that is a valid style name for an element. If no such name is found,
    // it returns false. Useful for vendor-prefixed styles like `transform`.
    function testProp(props) {
        var style = document.documentElement.style;
        for(var i = 0; i < props.length; i++){
            if (props[i] in style) return props[i];
        }
        return false;
    }
    // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
    // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
    // and optionally scaled by `scale`. Does not have an effect if the
    // browser doesn't support 3D CSS transforms.
    function setTransform(el, offset, scale) {
        var pos = offset || new Point(0, 0);
        el.style[TRANSFORM] = (Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale ? " scale(" + scale + ")" : "");
    }
    // @function setPosition(el: HTMLElement, position: Point)
    // Sets the position of `el` to coordinates specified by `position`,
    // using CSS translate or top/left positioning depending on the browser
    // (used by Leaflet internally to position its layers).
    function setPosition(el, point) {
        /*eslint-disable */ el._leaflet_pos = point;
        /* eslint-enable */ if (Browser.any3d) setTransform(el, point);
        else {
            el.style.left = point.x + "px";
            el.style.top = point.y + "px";
        }
    }
    // @function getPosition(el: HTMLElement): Point
    // Returns the coordinates of an element previously positioned with setPosition.
    function getPosition(el) {
        // this method is only used for elements previously positioned using setPosition,
        // so it's safe to cache the position for performance
        return el._leaflet_pos || new Point(0, 0);
    }
    // @function disableTextSelection()
    // Prevents the user from generating `selectstart` DOM events, usually generated
    // when the user drags the mouse through a page with text. Used internally
    // by Leaflet to override the behaviour of any click-and-drag interaction on
    // the map. Affects drag interactions on the whole document.
    // @function enableTextSelection()
    // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
    var disableTextSelection;
    var enableTextSelection;
    var _userSelect;
    if ("onselectstart" in document) {
        disableTextSelection = function disableTextSelection() {
            on(window, "selectstart", preventDefault);
        };
        enableTextSelection = function enableTextSelection() {
            off(window, "selectstart", preventDefault);
        };
    } else {
        var userSelectProperty = testProp([
            "userSelect",
            "WebkitUserSelect",
            "OUserSelect",
            "MozUserSelect",
            "msUserSelect"
        ]);
        disableTextSelection = function disableTextSelection() {
            if (userSelectProperty) {
                var style = document.documentElement.style;
                _userSelect = style[userSelectProperty];
                style[userSelectProperty] = "none";
            }
        };
        enableTextSelection = function enableTextSelection() {
            if (userSelectProperty) {
                document.documentElement.style[userSelectProperty] = _userSelect;
                _userSelect = undefined;
            }
        };
    }
    // @function disableImageDrag()
    // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
    // for `dragstart` DOM events, usually generated when the user drags an image.
    function disableImageDrag() {
        on(window, "dragstart", preventDefault);
    }
    // @function enableImageDrag()
    // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
    function enableImageDrag() {
        off(window, "dragstart", preventDefault);
    }
    var _outlineElement, _outlineStyle;
    // @function preventOutline(el: HTMLElement)
    // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
    // of the element `el` invisible. Used internally by Leaflet to prevent
    // focusable elements from displaying an outline when the user performs a
    // drag interaction on them.
    function preventOutline(element) {
        while(element.tabIndex === -1)element = element.parentNode;
        if (!element.style) return;
        restoreOutline();
        _outlineElement = element;
        _outlineStyle = element.style.outlineStyle;
        element.style.outlineStyle = "none";
        on(window, "keydown", restoreOutline);
    }
    // @function restoreOutline()
    // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
    function restoreOutline() {
        if (!_outlineElement) return;
        _outlineElement.style.outlineStyle = _outlineStyle;
        _outlineElement = undefined;
        _outlineStyle = undefined;
        off(window, "keydown", restoreOutline);
    }
    // @function getSizedParentNode(el: HTMLElement): HTMLElement
    // Finds the closest parent node which size (width and height) is not null.
    function getSizedParentNode(element) {
        do element = element.parentNode;
        while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
        return element;
    }
    // @function getScale(el: HTMLElement): Object
    // Computes the CSS scale currently applied on the element.
    // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
    // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
    function getScale(element) {
        var rect = element.getBoundingClientRect(); // Read-only in old browsers.
        return {
            x: rect.width / element.offsetWidth || 1,
            y: rect.height / element.offsetHeight || 1,
            boundingClientRect: rect
        };
    }
    var DomUtil = {
        __proto__: null,
        TRANSFORM: TRANSFORM,
        TRANSITION: TRANSITION,
        TRANSITION_END: TRANSITION_END,
        get: get,
        getStyle: getStyle,
        create: create$1,
        remove: remove,
        empty: empty,
        toFront: toFront,
        toBack: toBack,
        hasClass: hasClass,
        addClass: addClass,
        removeClass: removeClass,
        setClass: setClass,
        getClass: getClass,
        setOpacity: setOpacity,
        testProp: testProp,
        setTransform: setTransform,
        setPosition: setPosition,
        getPosition: getPosition,
        get disableTextSelection () {
            return disableTextSelection;
        },
        get enableTextSelection () {
            return enableTextSelection;
        },
        disableImageDrag: disableImageDrag,
        enableImageDrag: enableImageDrag,
        preventOutline: preventOutline,
        restoreOutline: restoreOutline,
        getSizedParentNode: getSizedParentNode,
        getScale: getScale
    };
    /*
   * @namespace DomEvent
   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
   */ // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.
    // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
    // Adds a listener function (`fn`) to a particular DOM event type of the
    // element `el`. You can optionally specify the context of the listener
    // (object the `this` keyword will point to). You can also pass several
    // space-separated types (e.g. `'click dblclick'`).
    // @alternative
    // @function on(el: HTMLElement, eventMap: Object, context?: Object): this
    // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
    function on(obj, types, fn, context) {
        if (types && typeof types === "object") for(var type in types)addOne(obj, type, types[type], fn);
        else {
            types = splitWords(types);
            for(var i = 0, len = types.length; i < len; i++)addOne(obj, types[i], fn, context);
        }
        return this;
    }
    var eventsKey = "_leaflet_events";
    // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
    // Removes a previously added listener function.
    // Note that if you passed a custom context to on, you must pass the same
    // context to `off` in order to remove the listener.
    // @alternative
    // @function off(el: HTMLElement, eventMap: Object, context?: Object): this
    // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
    // @alternative
    // @function off(el: HTMLElement, types: String): this
    // Removes all previously added listeners of given types.
    // @alternative
    // @function off(el: HTMLElement): this
    // Removes all previously added listeners from given HTMLElement
    function off(obj, types, fn, context) {
        if (arguments.length === 1) {
            batchRemove(obj);
            delete obj[eventsKey];
        } else if (types && typeof types === "object") for(var type in types)removeOne(obj, type, types[type], fn);
        else {
            types = splitWords(types);
            if (arguments.length === 2) batchRemove(obj, function(type) {
                return indexOf(types, type) !== -1;
            });
            else for(var i = 0, len = types.length; i < len; i++)removeOne(obj, types[i], fn, context);
        }
        return this;
    }
    function batchRemove(obj, filterFn) {
        for(var id in obj[eventsKey]){
            var type = id.split(/\d/)[0];
            if (!filterFn || filterFn(type)) removeOne(obj, type, null, null, id);
        }
    }
    var mouseSubst = {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        wheel: !("onwheel" in window) && "mousewheel"
    };
    function addOne(obj, type, fn, context) {
        var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
        if (obj[eventsKey] && obj[eventsKey][id]) return this;
        var handler = function handler(e) {
            return fn.call(context || obj, e || window.event);
        };
        var originalHandler = handler;
        if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) // Needs DomEvent.Pointer.js
        handler = addPointerListener(obj, type, handler);
        else if (Browser.touch && type === "dblclick") handler = addDoubleTapListener(obj, handler);
        else if ("addEventListener" in obj) {
            if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? {
                passive: false
            } : false);
            else if (type === "mouseenter" || type === "mouseleave") {
                handler = function handler(e) {
                    e = e || window.event;
                    if (isExternalTarget(obj, e)) originalHandler(e);
                };
                obj.addEventListener(mouseSubst[type], handler, false);
            } else obj.addEventListener(type, originalHandler, false);
        } else obj.attachEvent("on" + type, handler);
        obj[eventsKey] = obj[eventsKey] || {};
        obj[eventsKey][id] = handler;
    }
    function removeOne(obj, type, fn, context, id) {
        id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
        var handler = obj[eventsKey] && obj[eventsKey][id];
        if (!handler) return this;
        if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) removePointerListener(obj, type, handler);
        else if (Browser.touch && type === "dblclick") removeDoubleTapListener(obj, handler);
        else if ("removeEventListener" in obj) obj.removeEventListener(mouseSubst[type] || type, handler, false);
        else obj.detachEvent("on" + type, handler);
        obj[eventsKey][id] = null;
    }
    // @function stopPropagation(ev: DOMEvent): this
    // Stop the given event from propagation to parent elements. Used inside the listener functions:
    // ```js
    // L.DomEvent.on(div, 'click', function (ev) {
    // 	L.DomEvent.stopPropagation(ev);
    // });
    // ```
    function stopPropagation(e) {
        if (e.stopPropagation) e.stopPropagation();
        else if (e.originalEvent) e.originalEvent._stopped = true;
        else e.cancelBubble = true;
        return this;
    }
    // @function disableScrollPropagation(el: HTMLElement): this
    // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).
    function disableScrollPropagation(el) {
        addOne(el, "wheel", stopPropagation);
        return this;
    }
    // @function disableClickPropagation(el: HTMLElement): this
    // Adds `stopPropagation` to the element's `'click'`, `'dblclick'`, `'contextmenu'`,
    // `'mousedown'` and `'touchstart'` events (plus browser variants).
    function disableClickPropagation(el) {
        on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
        el["_leaflet_disable_click"] = true;
        return this;
    }
    // @function preventDefault(ev: DOMEvent): this
    // Prevents the default action of the DOM Event `ev` from happening (such as
    // following a link in the href of the a element, or doing a POST request
    // with page reload when a `<form>` is submitted).
    // Use it inside listener functions.
    function preventDefault(e) {
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
        return this;
    }
    // @function stop(ev: DOMEvent): this
    // Does `stopPropagation` and `preventDefault` at the same time.
    function stop(e) {
        preventDefault(e);
        stopPropagation(e);
        return this;
    }
    // @function getPropagationPath(ev: DOMEvent): Array
    // Compatibility polyfill for [`Event.composedPath()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath).
    // Returns an array containing the `HTMLElement`s that the given DOM event
    // should propagate to (if not stopped).
    function getPropagationPath(ev) {
        if (ev.composedPath) return ev.composedPath();
        var path = [];
        var el = ev.target;
        while(el){
            path.push(el);
            el = el.parentNode;
        }
        return path;
    }
    // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
    // Gets normalized mouse position from a DOM event relative to the
    // `container` (border excluded) or to the whole page if not specified.
    function getMousePosition(e, container) {
        if (!container) return new Point(e.clientX, e.clientY);
        var scale = getScale(container), offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)
        return new Point(// offset.left/top values are in page scale (like clientX/Y),
        // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
        (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);
    }
    //  except , Safari and
    // We need double the scroll pixels (see #7403 and #4538) for all Browsers
    // except OSX (Mac) -> 3x, Chrome running on Linux 1x
    var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
    // @function getWheelDelta(ev: DOMEvent): Number
    // Gets normalized wheel delta from a wheel DOM event, in vertical
    // pixels scrolled (negative if scrolling down).
    // Events from pointing devices without precise scrolling are mapped to
    // a best guess of 60 pixels.
    function getWheelDelta(e) {
        return Browser.edge ? e.wheelDeltaY / 2 : e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : e.deltaX || e.deltaZ ? 0 : e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : e.detail ? e.detail / -32765 * 60 : 0;
    }
    // check if element really left/entered the event target (for mouseenter/mouseleave)
    function isExternalTarget(el, e) {
        var related = e.relatedTarget;
        if (!related) return true;
        try {
            while(related && related !== el)related = related.parentNode;
        } catch (err) {
            return false;
        }
        return related !== el;
    }
    var DomEvent = {
        __proto__: null,
        on: on,
        off: off,
        stopPropagation: stopPropagation,
        disableScrollPropagation: disableScrollPropagation,
        disableClickPropagation: disableClickPropagation,
        preventDefault: preventDefault,
        stop: stop,
        getPropagationPath: getPropagationPath,
        getMousePosition: getMousePosition,
        getWheelDelta: getWheelDelta,
        isExternalTarget: isExternalTarget,
        addListener: on,
        removeListener: off
    };
    /*
   * @class PosAnimation
   * @aka L.PosAnimation
   * @inherits Evented
   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
   *
   * @example
   * ```js
   * var myPositionMarker = L.marker([48.864716, 2.294694]).addTo(map);
   *
   * myPositionMarker.on("click", function() {
   * 	var pos = map.latLngToLayerPoint(myPositionMarker.getLatLng());
   * 	pos.y -= 25;
   * 	var fx = new L.PosAnimation();
   *
   * 	fx.once('end',function() {
   * 		pos.y += 25;
   * 		fx.run(myPositionMarker._icon, pos, 0.8);
   * 	});
   *
   * 	fx.run(myPositionMarker._icon, pos, 0.3);
   * });
   *
   * ```
   *
   * @constructor L.PosAnimation()
   * Creates a `PosAnimation` object.
   *
   */ var PosAnimation = Evented.extend({
        // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
        // Run an animation of a given element to a new position, optionally setting
        // duration in seconds (`0.25` by default) and easing linearity factor (3rd
        // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
        // `0.5` by default).
        run: function run(el, newPos, duration, easeLinearity) {
            this.stop();
            this._el = el;
            this._inProgress = true;
            this._duration = duration || 0.25;
            this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
            this._startPos = getPosition(el);
            this._offset = newPos.subtract(this._startPos);
            this._startTime = +new Date();
            // @event start: Event
            // Fired when the animation starts
            this.fire("start");
            this._animate();
        },
        // @method stop()
        // Stops the animation (if currently running).
        stop: function stop() {
            if (!this._inProgress) return;
            this._step(true);
            this._complete();
        },
        _animate: function _animate() {
            // animation loop
            this._animId = requestAnimFrame(this._animate, this);
            this._step();
        },
        _step: function _step(round) {
            var elapsed = +new Date() - this._startTime, duration = this._duration * 1000;
            if (elapsed < duration) this._runFrame(this._easeOut(elapsed / duration), round);
            else {
                this._runFrame(1);
                this._complete();
            }
        },
        _runFrame: function _runFrame(progress, round) {
            var pos = this._startPos.add(this._offset.multiplyBy(progress));
            if (round) pos._round();
            setPosition(this._el, pos);
            // @event step: Event
            // Fired continuously during the animation.
            this.fire("step");
        },
        _complete: function _complete() {
            cancelAnimFrame(this._animId);
            this._inProgress = false;
            // @event end: Event
            // Fired when the animation ends.
            this.fire("end");
        },
        _easeOut: function _easeOut(t) {
            return 1 - Math.pow(1 - t, this._easeOutPower);
        }
    });
    /*
   * @class Map
   * @aka L.Map
   * @inherits Evented
   *
   * The central class of the API  it is used to create a map on a page and manipulate it.
   *
   * @example
   *
   * ```js
   * // initialize the map on the "map" div with a given center and zoom
   * var map = L.map('map', {
   * 	center: [51.505, -0.09],
   * 	zoom: 13
   * });
   * ```
   *
   */ var Map = Evented.extend({
        options: {
            // @section Map State Options
            // @option crs: CRS = L.CRS.EPSG3857
            // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
            // sure what it means.
            crs: EPSG3857,
            // @option center: LatLng = undefined
            // Initial geographic center of the map
            center: undefined,
            // @option zoom: Number = undefined
            // Initial map zoom level
            zoom: undefined,
            // @option minZoom: Number = *
            // Minimum zoom level of the map.
            // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
            // the lowest of their `minZoom` options will be used instead.
            minZoom: undefined,
            // @option maxZoom: Number = *
            // Maximum zoom level of the map.
            // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
            // the highest of their `maxZoom` options will be used instead.
            maxZoom: undefined,
            // @option layers: Layer[] = []
            // Array of layers that will be added to the map initially
            layers: [],
            // @option maxBounds: LatLngBounds = null
            // When this option is set, the map restricts the view to the given
            // geographical bounds, bouncing the user back if the user tries to pan
            // outside the view. To set the restriction dynamically, use
            // [`setMaxBounds`](#map-setmaxbounds) method.
            maxBounds: undefined,
            // @option renderer: Renderer = *
            // The default method for drawing vector layers on the map. `L.SVG`
            // or `L.Canvas` by default depending on browser support.
            renderer: undefined,
            // @section Animation Options
            // @option zoomAnimation: Boolean = true
            // Whether the map zoom animation is enabled. By default it's enabled
            // in all browsers that support CSS3 Transitions except Android.
            zoomAnimation: true,
            // @option zoomAnimationThreshold: Number = 4
            // Won't animate zoom if the zoom difference exceeds this value.
            zoomAnimationThreshold: 4,
            // @option fadeAnimation: Boolean = true
            // Whether the tile fade animation is enabled. By default it's enabled
            // in all browsers that support CSS3 Transitions except Android.
            fadeAnimation: true,
            // @option markerZoomAnimation: Boolean = true
            // Whether markers animate their zoom with the zoom animation, if disabled
            // they will disappear for the length of the animation. By default it's
            // enabled in all browsers that support CSS3 Transitions except Android.
            markerZoomAnimation: true,
            // @option transform3DLimit: Number = 2^23
            // Defines the maximum size of a CSS translation transform. The default
            // value should not be changed unless a web browser positions layers in
            // the wrong place after doing a large `panBy`.
            transform3DLimit: 8388608,
            // @section Interaction Options
            // @option zoomSnap: Number = 1
            // Forces the map's zoom level to always be a multiple of this, particularly
            // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
            // By default, the zoom level snaps to the nearest integer; lower values
            // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
            // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
            zoomSnap: 1,
            // @option zoomDelta: Number = 1
            // Controls how much the map's zoom level will change after a
            // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
            // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
            // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
            zoomDelta: 1,
            // @option trackResize: Boolean = true
            // Whether the map automatically handles browser window resize to update itself.
            trackResize: true
        },
        initialize: function initialize(id, options) {
            options = setOptions(this, options);
            // Make sure to assign internal flags at the beginning,
            // to avoid inconsistent state in some edge cases.
            this._handlers = [];
            this._layers = {};
            this._zoomBoundLayers = {};
            this._sizeChanged = true;
            this._initContainer(id);
            this._initLayout();
            // hack for https://github.com/Leaflet/Leaflet/issues/1980
            this._onResize = bind(this._onResize, this);
            this._initEvents();
            if (options.maxBounds) this.setMaxBounds(options.maxBounds);
            if (options.zoom !== undefined) this._zoom = this._limitZoom(options.zoom);
            if (options.center && options.zoom !== undefined) this.setView(toLatLng(options.center), options.zoom, {
                reset: true
            });
            this.callInitHooks();
            // don't animate on browsers without hardware-accelerated transitions or old Android/Opera
            this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;
            // zoom transitions run with the same duration for all layers, so if one of transitionend events
            // happens after starting zoom animation (propagating to the map pane), we know that it ended globally
            if (this._zoomAnimated) {
                this._createAnimProxy();
                on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
            }
            this._addLayers(this.options.layers);
        },
        // @section Methods for modifying map state
        // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) with the given
        // animation options.
        setView: function setView(center, zoom, options) {
            zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
            center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
            options = options || {};
            this._stop();
            if (this._loaded && !options.reset && options !== true) {
                if (options.animate !== undefined) {
                    options.zoom = extend({
                        animate: options.animate
                    }, options.zoom);
                    options.pan = extend({
                        animate: options.animate,
                        duration: options.duration
                    }, options.pan);
                }
                // try animating pan or zoom
                var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);
                if (moved) {
                    // prevent resize handler call, the view will refresh after animation anyway
                    clearTimeout(this._sizeTimer);
                    return this;
                }
            }
            // animation didn't start, just reset the map view
            this._resetView(center, zoom, options.pan && options.pan.noMoveStart);
            return this;
        },
        // @method setZoom(zoom: Number, options?: Zoom/pan options): this
        // Sets the zoom of the map.
        setZoom: function setZoom(zoom, options) {
            if (!this._loaded) {
                this._zoom = zoom;
                return this;
            }
            return this.setView(this.getCenter(), zoom, {
                zoom: options
            });
        },
        // @method zoomIn(delta?: Number, options?: Zoom options): this
        // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomIn: function zoomIn(delta, options) {
            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom + delta, options);
        },
        // @method zoomOut(delta?: Number, options?: Zoom options): this
        // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomOut: function zoomOut(delta, options) {
            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom - delta, options);
        },
        // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified geographical point on the map
        // stationary (e.g. used internally for scroll zoom and double-click zoom).
        // @alternative
        // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
        setZoomAround: function setZoomAround(latlng, zoom, options) {
            var scale = this.getZoomScale(zoom), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
            return this.setView(newCenter, zoom, {
                zoom: options
            });
        },
        _getBoundsCenterZoom: function _getBoundsCenterZoom(bounds, options) {
            options = options || {};
            bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [
                0,
                0
            ]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [
                0,
                0
            ]), zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
            zoom = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom) : zoom;
            if (zoom === Infinity) return {
                center: bounds.getCenter(),
                zoom: zoom
            };
            var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom), nePoint = this.project(bounds.getNorthEast(), zoom), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);
            return {
                center: center,
                zoom: zoom
            };
        },
        // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets a map view that contains the given geographical bounds with the
        // maximum zoom level possible.
        fitBounds: function fitBounds(bounds, options) {
            bounds = toLatLngBounds(bounds);
            if (!bounds.isValid()) throw new Error("Bounds are not valid.");
            var target = this._getBoundsCenterZoom(bounds, options);
            return this.setView(target.center, target.zoom, options);
        },
        // @method fitWorld(options?: fitBounds options): this
        // Sets a map view that mostly contains the whole world with the maximum
        // zoom level possible.
        fitWorld: function fitWorld(options) {
            return this.fitBounds([
                [
                    -90,
                    -180
                ],
                [
                    90,
                    180
                ]
            ], options);
        },
        // @method panTo(latlng: LatLng, options?: Pan options): this
        // Pans the map to a given center.
        panTo: function panTo(center, options) {
            return this.setView(center, this._zoom, {
                pan: options
            });
        },
        // @method panBy(offset: Point, options?: Pan options): this
        // Pans the map by a given number of pixels (animated).
        panBy: function panBy(offset, options) {
            offset = toPoint(offset).round();
            options = options || {};
            if (!offset.x && !offset.y) return this.fire("moveend");
            // If we pan too far, Chrome gets issues with tiles
            // and makes them disappear or appear in the wrong place (slightly offset) #2602
            if (options.animate !== true && !this.getSize().contains(offset)) {
                this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
                return this;
            }
            if (!this._panAnim) {
                this._panAnim = new PosAnimation();
                this._panAnim.on({
                    "step": this._onPanTransitionStep,
                    "end": this._onPanTransitionEnd
                }, this);
            }
            // don't fire movestart if animating inertia
            if (!options.noMoveStart) this.fire("movestart");
            // animate pan unless animate: false specified
            if (options.animate !== false) {
                addClass(this._mapPane, "leaflet-pan-anim");
                var newPos = this._getMapPanePos().subtract(offset).round();
                this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
            } else {
                this._rawPanBy(offset);
                this.fire("move").fire("moveend");
            }
            return this;
        },
        // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) performing a smooth
        // pan-zoom animation.
        flyTo: function flyTo(targetCenter, targetZoom, options) {
            options = options || {};
            if (options.animate === false || !Browser.any3d) return this.setView(targetCenter, targetZoom, options);
            this._stop();
            var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
            targetCenter = toLatLng(targetCenter);
            targetZoom = targetZoom === undefined ? startZoom : targetZoom;
            var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
            function r(i) {
                var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
                // workaround for floating point precision bug when sq = 0, log = -Infinite,
                // thus triggering an infinite loop in flyTo
                var log = sq < 0.000000001 ? -18 : Math.log(sq);
                return log;
            }
            function sinh(n) {
                return (Math.exp(n) - Math.exp(-n)) / 2;
            }
            function cosh(n) {
                return (Math.exp(n) + Math.exp(-n)) / 2;
            }
            function tanh(n) {
                return sinh(n) / cosh(n);
            }
            var r0 = r(0);
            function w(s) {
                return w0 * (cosh(r0) / cosh(r0 + rho * s));
            }
            function u(s) {
                return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
            }
            function easeOut(t) {
                return 1 - Math.pow(1 - t, 1.5);
            }
            var start = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;
            function frame() {
                var t = (Date.now() - start) / duration, s = easeOut(t) * S;
                if (t <= 1) {
                    this._flyToFrame = requestAnimFrame(frame, this);
                    this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {
                        flyTo: true
                    });
                } else this._move(targetCenter, targetZoom)._moveEnd(true);
            }
            this._moveStart(true, options.noMoveStart);
            frame.call(this);
            return this;
        },
        // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
        // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
        flyToBounds: function flyToBounds(bounds, options) {
            var target = this._getBoundsCenterZoom(bounds, options);
            return this.flyTo(target.center, target.zoom, options);
        },
        // @method setMaxBounds(bounds: LatLngBounds): this
        // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
        setMaxBounds: function setMaxBounds(bounds) {
            bounds = toLatLngBounds(bounds);
            if (this.listens("moveend", this._panInsideMaxBounds)) this.off("moveend", this._panInsideMaxBounds);
            if (!bounds.isValid()) {
                this.options.maxBounds = null;
                return this;
            }
            this.options.maxBounds = bounds;
            if (this._loaded) this._panInsideMaxBounds();
            return this.on("moveend", this._panInsideMaxBounds);
        },
        // @method setMinZoom(zoom: Number): this
        // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
        setMinZoom: function setMinZoom(zoom) {
            var oldZoom = this.options.minZoom;
            this.options.minZoom = zoom;
            if (this._loaded && oldZoom !== zoom) {
                this.fire("zoomlevelschange");
                if (this.getZoom() < this.options.minZoom) return this.setZoom(zoom);
            }
            return this;
        },
        // @method setMaxZoom(zoom: Number): this
        // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
        setMaxZoom: function setMaxZoom(zoom) {
            var oldZoom = this.options.maxZoom;
            this.options.maxZoom = zoom;
            if (this._loaded && oldZoom !== zoom) {
                this.fire("zoomlevelschange");
                if (this.getZoom() > this.options.maxZoom) return this.setZoom(zoom);
            }
            return this;
        },
        // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
        // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
        panInsideBounds: function panInsideBounds(bounds, options) {
            this._enforcingBounds = true;
            var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
            if (!center.equals(newCenter)) this.panTo(newCenter, options);
            this._enforcingBounds = false;
            return this;
        },
        // @method panInside(latlng: LatLng, options?: padding options): this
        // Pans the map the minimum amount to make the `latlng` visible. Use
        // padding options to fit the display to more restricted bounds.
        // If `latlng` is already within the (optionally padded) display bounds,
        // the map will not be panned.
        panInside: function panInside(latlng, options) {
            options = options || {};
            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [
                0,
                0
            ]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [
                0,
                0
            ]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([
                pixelBounds.min.add(paddingTL),
                pixelBounds.max.subtract(paddingBR)
            ]), paddedSize = paddedBounds.getSize();
            if (!paddedBounds.contains(pixelPoint)) {
                this._enforcingBounds = true;
                var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
                var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
                pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
                pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
                this.panTo(this.unproject(pixelCenter), options);
                this._enforcingBounds = false;
            }
            return this;
        },
        // @method invalidateSize(options: Zoom/pan options): this
        // Checks if the map container size changed and updates the map if so 
        // call it after you've changed the map size dynamically, also animating
        // pan by default. If `options.pan` is `false`, panning will not occur.
        // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
        // that it doesn't happen often even if the method is called many
        // times in a row.
        // @alternative
        // @method invalidateSize(animate: Boolean): this
        // Checks if the map container size changed and updates the map if so 
        // call it after you've changed the map size dynamically, also animating
        // pan by default.
        invalidateSize: function invalidateSize(options) {
            if (!this._loaded) return this;
            options = extend({
                animate: false,
                pan: true
            }, options === true ? {
                animate: true
            } : options);
            var oldSize = this.getSize();
            this._sizeChanged = true;
            this._lastCenter = null;
            var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
            if (!offset.x && !offset.y) return this;
            if (options.animate && options.pan) this.panBy(offset);
            else {
                if (options.pan) this._rawPanBy(offset);
                this.fire("move");
                if (options.debounceMoveend) {
                    clearTimeout(this._sizeTimer);
                    this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
                } else this.fire("moveend");
            }
            // @section Map state change events
            // @event resize: ResizeEvent
            // Fired when the map is resized.
            return this.fire("resize", {
                oldSize: oldSize,
                newSize: newSize
            });
        },
        // @section Methods for modifying map state
        // @method stop(): this
        // Stops the currently running `panTo` or `flyTo` animation, if any.
        stop: function stop() {
            this.setZoom(this._limitZoom(this._zoom));
            if (!this.options.zoomSnap) this.fire("viewreset");
            return this._stop();
        },
        // @section Geolocation methods
        // @method locate(options?: Locate options): this
        // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
        // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
        // and optionally sets the map view to the user's location with respect to
        // detection accuracy (or to the world view if geolocation failed).
        // Note that, if your page doesn't use HTTPS, this method will fail in
        // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
        // See `Locate options` for more details.
        locate: function locate(options) {
            options = this._locateOptions = extend({
                timeout: 10000,
                watch: false
            }, options);
            if (!("geolocation" in navigator)) {
                this._handleGeolocationError({
                    code: 0,
                    message: "Geolocation not supported."
                });
                return this;
            }
            var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
            if (options.watch) this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
            else navigator.geolocation.getCurrentPosition(onResponse, onError, options);
            return this;
        },
        // @method stopLocate(): this
        // Stops watching location previously initiated by `map.locate({watch: true})`
        // and aborts resetting the map view if map.locate was called with
        // `{setView: true}`.
        stopLocate: function stopLocate() {
            if (navigator.geolocation && navigator.geolocation.clearWatch) navigator.geolocation.clearWatch(this._locationWatchId);
            if (this._locateOptions) this._locateOptions.setView = false;
            return this;
        },
        _handleGeolocationError: function _handleGeolocationError(error) {
            if (!this._container._leaflet_id) return;
            var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
            if (this._locateOptions.setView && !this._loaded) this.fitWorld();
            // @section Location events
            // @event locationerror: ErrorEvent
            // Fired when geolocation (using the [`locate`](#map-locate) method) failed.
            this.fire("locationerror", {
                code: c,
                message: "Geolocation error: " + message + "."
            });
        },
        _handleGeolocationResponse: function _handleGeolocationResponse(pos) {
            if (!this._container._leaflet_id) return;
            var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
            if (options.setView) {
                var zoom = this.getBoundsZoom(bounds);
                this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
            }
            var data = {
                latlng: latlng,
                bounds: bounds,
                timestamp: pos.timestamp
            };
            for(var i in pos.coords)if (typeof pos.coords[i] === "number") data[i] = pos.coords[i];
            // @event locationfound: LocationEvent
            // Fired when geolocation (using the [`locate`](#map-locate) method)
            // went successfully.
            this.fire("locationfound", data);
        },
        // TODO Appropriate docs section?
        // @section Other Methods
        // @method addHandler(name: String, HandlerClass: Function): this
        // Adds a new `Handler` to the map, given its name and constructor function.
        addHandler: function addHandler(name, HandlerClass) {
            if (!HandlerClass) return this;
            var handler = this[name] = new HandlerClass(this);
            this._handlers.push(handler);
            if (this.options[name]) handler.enable();
            return this;
        },
        // @method remove(): this
        // Destroys the map and clears all related event listeners.
        remove: function remove1() {
            this._initEvents(true);
            if (this.options.maxBounds) this.off("moveend", this._panInsideMaxBounds);
            if (this._containerId !== this._container._leaflet_id) throw new Error("Map container is being reused by another instance");
            try {
                // throws error in IE6-8
                delete this._container._leaflet_id;
                delete this._containerId;
            } catch (e) {
                /*eslint-disable */ this._container._leaflet_id = undefined;
                /* eslint-enable */ this._containerId = undefined;
            }
            if (this._locationWatchId !== undefined) this.stopLocate();
            this._stop();
            remove(this._mapPane);
            if (this._clearControlPos) this._clearControlPos();
            if (this._resizeRequest) {
                cancelAnimFrame(this._resizeRequest);
                this._resizeRequest = null;
            }
            this._clearHandlers();
            if (this._loaded) // @section Map state change events
            // @event unload: Event
            // Fired when the map is destroyed with [remove](#map-remove) method.
            this.fire("unload");
            var i;
            for(i in this._layers)this._layers[i].remove();
            for(i in this._panes)remove(this._panes[i]);
            this._layers = [];
            this._panes = [];
            delete this._mapPane;
            delete this._renderer;
            return this;
        },
        // @section Other Methods
        // @method createPane(name: String, container?: HTMLElement): HTMLElement
        // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
        // then returns it. The pane is created as a child of `container`, or
        // as a child of the main map pane if not set.
        createPane: function createPane(name, container) {
            var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
            if (name) this._panes[name] = pane;
            return pane;
        },
        // @section Methods for Getting Map State
        // @method getCenter(): LatLng
        // Returns the geographical center of the map view
        getCenter: function getCenter() {
            this._checkIfLoaded();
            if (this._lastCenter && !this._moved()) return this._lastCenter.clone();
            return this.layerPointToLatLng(this._getCenterLayerPoint());
        },
        // @method getZoom(): Number
        // Returns the current zoom level of the map view
        getZoom: function getZoom() {
            return this._zoom;
        },
        // @method getBounds(): LatLngBounds
        // Returns the geographical bounds visible in the current map view
        getBounds: function getBounds() {
            var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
            return new LatLngBounds(sw, ne);
        },
        // @method getMinZoom(): Number
        // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
        getMinZoom: function getMinZoom() {
            return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
        },
        // @method getMaxZoom(): Number
        // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
        getMaxZoom: function getMaxZoom() {
            return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;
        },
        // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
        // Returns the maximum zoom level on which the given bounds fit to the map
        // view in its entirety. If `inside` (optional) is set to `true`, the method
        // instead returns the minimum zoom level on which the map view fits into
        // the given bounds in its entirety.
        getBoundsZoom: function getBoundsZoom(bounds, inside, padding) {
            bounds = toLatLngBounds(bounds);
            padding = toPoint(padding || [
                0,
                0
            ]);
            var zoom = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
            zoom = this.getScaleZoom(scale, zoom);
            if (snap) {
                zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
                zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
            }
            return Math.max(min, Math.min(max, zoom));
        },
        // @method getSize(): Point
        // Returns the current size of the map container (in pixels).
        getSize: function getSize() {
            if (!this._size || this._sizeChanged) {
                this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);
                this._sizeChanged = false;
            }
            return this._size.clone();
        },
        // @method getPixelBounds(): Bounds
        // Returns the bounds of the current map view in projected pixel
        // coordinates (sometimes useful in layer and overlay implementations).
        getPixelBounds: function getPixelBounds(center, zoom) {
            var topLeftPoint = this._getTopLeftPoint(center, zoom);
            return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
        },
        // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
        // the map pane? "left point of the map layer" can be confusing, specially
        // since there can be negative offsets.
        // @method getPixelOrigin(): Point
        // Returns the projected pixel coordinates of the top left point of
        // the map layer (useful in custom layer and overlay implementations).
        getPixelOrigin: function getPixelOrigin() {
            this._checkIfLoaded();
            return this._pixelOrigin;
        },
        // @method getPixelWorldBounds(zoom?: Number): Bounds
        // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
        // If `zoom` is omitted, the map's current zoom level is used.
        getPixelWorldBounds: function getPixelWorldBounds(zoom) {
            return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
        },
        // @section Other Methods
        // @method getPane(pane: String|HTMLElement): HTMLElement
        // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
        getPane: function getPane(pane) {
            return typeof pane === "string" ? this._panes[pane] : pane;
        },
        // @method getPanes(): Object
        // Returns a plain object containing the names of all [panes](#map-pane) as keys and
        // the panes as values.
        getPanes: function getPanes() {
            return this._panes;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the map.
        getContainer: function getContainer() {
            return this._container;
        },
        // @section Conversion Methods
        // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
        // Returns the scale factor to be applied to a map transition from zoom level
        // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
        getZoomScale: function getZoomScale(toZoom, fromZoom) {
            // TODO replace with universal implementation after refactoring projections
            var crs = this.options.crs;
            fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
            return crs.scale(toZoom) / crs.scale(fromZoom);
        },
        // @method getScaleZoom(scale: Number, fromZoom: Number): Number
        // Returns the zoom level that the map would end up at, if it is at `fromZoom`
        // level and everything is scaled by a factor of `scale`. Inverse of
        // [`getZoomScale`](#map-getZoomScale).
        getScaleZoom: function getScaleZoom(scale, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
            var zoom = crs.zoom(scale * crs.scale(fromZoom));
            return isNaN(zoom) ? Infinity : zoom;
        },
        // @method project(latlng: LatLng, zoom: Number): Point
        // Projects a geographical coordinate `LatLng` according to the projection
        // of the map's CRS, then scales it according to `zoom` and the CRS's
        // `Transformation`. The result is pixel coordinate relative to
        // the CRS origin.
        project: function project(latlng, zoom) {
            zoom = zoom === undefined ? this._zoom : zoom;
            return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
        },
        // @method unproject(point: Point, zoom: Number): LatLng
        // Inverse of [`project`](#map-project).
        unproject: function unproject(point, zoom) {
            zoom = zoom === undefined ? this._zoom : zoom;
            return this.options.crs.pointToLatLng(toPoint(point), zoom);
        },
        // @method layerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding geographical coordinate (for the current zoom level).
        layerPointToLatLng: function layerPointToLatLng(point) {
            var projectedPoint = toPoint(point).add(this.getPixelOrigin());
            return this.unproject(projectedPoint);
        },
        // @method latLngToLayerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the [origin pixel](#map-getpixelorigin).
        latLngToLayerPoint: function latLngToLayerPoint(latlng) {
            var projectedPoint = this.project(toLatLng(latlng))._round();
            return projectedPoint._subtract(this.getPixelOrigin());
        },
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
        // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
        // CRS's bounds.
        // By default this means longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees.
        wrapLatLng: function wrapLatLng(latlng) {
            return this.options.crs.wrapLatLng(toLatLng(latlng));
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring that
        // its center is within the CRS's bounds.
        // By default this means the center longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees, and the majority of the bounds
        // overlaps the CRS's bounds.
        wrapLatLngBounds: function wrapLatLngBounds(latlng) {
            return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates according to
        // the map's CRS. By default this measures distance in meters.
        distance: function distance(latlng1, latlng2) {
            return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
        },
        // @method containerPointToLayerPoint(point: Point): Point
        // Given a pixel coordinate relative to the map container, returns the corresponding
        // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
        containerPointToLayerPoint: function containerPointToLayerPoint(point) {
            return toPoint(point).subtract(this._getMapPanePos());
        },
        // @method layerPointToContainerPoint(point: Point): Point
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding pixel coordinate relative to the map container.
        layerPointToContainerPoint: function layerPointToContainerPoint(point) {
            return toPoint(point).add(this._getMapPanePos());
        },
        // @method containerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the map container, returns
        // the corresponding geographical coordinate (for the current zoom level).
        containerPointToLatLng: function containerPointToLatLng(point) {
            var layerPoint = this.containerPointToLayerPoint(toPoint(point));
            return this.layerPointToLatLng(layerPoint);
        },
        // @method latLngToContainerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the map container.
        latLngToContainerPoint: function latLngToContainerPoint(latlng) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
        },
        // @method mouseEventToContainerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to the
        // map container where the event took place.
        mouseEventToContainerPoint: function mouseEventToContainerPoint(e) {
            return getMousePosition(e, this._container);
        },
        // @method mouseEventToLayerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to
        // the [origin pixel](#map-getpixelorigin) where the event took place.
        mouseEventToLayerPoint: function mouseEventToLayerPoint(e) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
        },
        // @method mouseEventToLatLng(ev: MouseEvent): LatLng
        // Given a MouseEvent object, returns geographical coordinate where the
        // event took place.
        mouseEventToLatLng: function mouseEventToLatLng(e) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
        },
        // map initialization methods
        _initContainer: function _initContainer(id) {
            var container = this._container = get(id);
            if (!container) throw new Error("Map container not found.");
            else if (container._leaflet_id) throw new Error("Map container is already initialized.");
            on(container, "scroll", this._onScroll, this);
            this._containerId = stamp(container);
        },
        _initLayout: function _initLayout() {
            var container = this._container;
            this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;
            addClass(container, "leaflet-container" + (Browser.touch ? " leaflet-touch" : "") + (Browser.retina ? " leaflet-retina" : "") + (Browser.ielt9 ? " leaflet-oldie" : "") + (Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
            var position = getStyle(container, "position");
            if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") container.style.position = "relative";
            this._initPanes();
            if (this._initControlPos) this._initControlPos();
        },
        _initPanes: function _initPanes() {
            var panes = this._panes = {};
            this._paneRenderers = {};
            // @section
            //
            // Panes are DOM elements used to control the ordering of layers on the map. You
            // can access panes with [`map.getPane`](#map-getpane) or
            // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
            // [`map.createPane`](#map-createpane) method.
            //
            // Every map has the following default panes that differ only in zIndex.
            //
            // @pane mapPane: HTMLElement = 'auto'
            // Pane that contains all other map panes
            this._mapPane = this.createPane("mapPane", this._container);
            setPosition(this._mapPane, new Point(0, 0));
            // @pane tilePane: HTMLElement = 200
            // Pane for `GridLayer`s and `TileLayer`s
            this.createPane("tilePane");
            // @pane overlayPane: HTMLElement = 400
            // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
            this.createPane("overlayPane");
            // @pane shadowPane: HTMLElement = 500
            // Pane for overlay shadows (e.g. `Marker` shadows)
            this.createPane("shadowPane");
            // @pane markerPane: HTMLElement = 600
            // Pane for `Icon`s of `Marker`s
            this.createPane("markerPane");
            // @pane tooltipPane: HTMLElement = 650
            // Pane for `Tooltip`s.
            this.createPane("tooltipPane");
            // @pane popupPane: HTMLElement = 700
            // Pane for `Popup`s.
            this.createPane("popupPane");
            if (!this.options.markerZoomAnimation) {
                addClass(panes.markerPane, "leaflet-zoom-hide");
                addClass(panes.shadowPane, "leaflet-zoom-hide");
            }
        },
        // private methods that modify map state
        // @section Map state change events
        _resetView: function _resetView(center, zoom, noMoveStart) {
            setPosition(this._mapPane, new Point(0, 0));
            var loading = !this._loaded;
            this._loaded = true;
            zoom = this._limitZoom(zoom);
            this.fire("viewprereset");
            var zoomChanged = this._zoom !== zoom;
            this._moveStart(zoomChanged, noMoveStart)._move(center, zoom)._moveEnd(zoomChanged);
            // @event viewreset: Event
            // Fired when the map needs to redraw its content (this usually happens
            // on map zoom or load). Very useful for creating custom overlays.
            this.fire("viewreset");
            // @event load: Event
            // Fired when the map is initialized (when its center and zoom are set
            // for the first time).
            if (loading) this.fire("load");
        },
        _moveStart: function _moveStart(zoomChanged, noMoveStart) {
            // @event zoomstart: Event
            // Fired when the map zoom is about to change (e.g. before zoom animation).
            // @event movestart: Event
            // Fired when the view of the map starts changing (e.g. user starts dragging the map).
            if (zoomChanged) this.fire("zoomstart");
            if (!noMoveStart) this.fire("movestart");
            return this;
        },
        _move: function _move(center, zoom, data, supressEvent) {
            if (zoom === undefined) zoom = this._zoom;
            var zoomChanged = this._zoom !== zoom;
            this._zoom = zoom;
            this._lastCenter = center;
            this._pixelOrigin = this._getNewPixelOrigin(center);
            if (!supressEvent) {
                // @event zoom: Event
                // Fired repeatedly during any change in zoom level,
                // including zoom and fly animations.
                if (zoomChanged || data && data.pinch) this.fire("zoom", data);
                // @event move: Event
                // Fired repeatedly during any movement of the map,
                // including pan and fly animations.
                this.fire("move", data);
            } else if (data && data.pinch) this.fire("zoom", data);
            return this;
        },
        _moveEnd: function _moveEnd(zoomChanged) {
            // @event zoomend: Event
            // Fired when the map zoom changed, after any animations.
            if (zoomChanged) this.fire("zoomend");
            // @event moveend: Event
            // Fired when the center of the map stops changing
            // (e.g. user stopped dragging the map or after non-centered zoom).
            return this.fire("moveend");
        },
        _stop: function _stop() {
            cancelAnimFrame(this._flyToFrame);
            if (this._panAnim) this._panAnim.stop();
            return this;
        },
        _rawPanBy: function _rawPanBy(offset) {
            setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
        },
        _getZoomSpan: function _getZoomSpan() {
            return this.getMaxZoom() - this.getMinZoom();
        },
        _panInsideMaxBounds: function _panInsideMaxBounds() {
            if (!this._enforcingBounds) this.panInsideBounds(this.options.maxBounds);
        },
        _checkIfLoaded: function _checkIfLoaded() {
            if (!this._loaded) throw new Error("Set map center and zoom first.");
        },
        // DOM event handling
        // @section Interaction events
        _initEvents: function _initEvents(remove) {
            this._targets = {};
            this._targets[stamp(this._container)] = this;
            var onOff = remove ? off : on;
            // @event click: MouseEvent
            // Fired when the user clicks (or taps) the map.
            // @event dblclick: MouseEvent
            // Fired when the user double-clicks (or double-taps) the map.
            // @event mousedown: MouseEvent
            // Fired when the user pushes the mouse button on the map.
            // @event mouseup: MouseEvent
            // Fired when the user releases the mouse button on the map.
            // @event mouseover: MouseEvent
            // Fired when the mouse enters the map.
            // @event mouseout: MouseEvent
            // Fired when the mouse leaves the map.
            // @event mousemove: MouseEvent
            // Fired while the mouse moves over the map.
            // @event contextmenu: MouseEvent
            // Fired when the user pushes the right mouse button on the map, prevents
            // default browser context menu from showing if there are listeners on
            // this event. Also fired on mobile when the user holds a single touch
            // for a second (also called long press).
            // @event keypress: KeyboardEvent
            // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.
            // @event keydown: KeyboardEvent
            // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,
            // the `keydown` event is fired for keys that produce a character value and for keys
            // that do not produce a character value.
            // @event keyup: KeyboardEvent
            // Fired when the user releases a key from the keyboard while the map is focused.
            onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
            if (this.options.trackResize) onOff(window, "resize", this._onResize, this);
            if (Browser.any3d && this.options.transform3DLimit) (remove ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
        },
        _onResize: function _onResize() {
            cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = requestAnimFrame(function() {
                this.invalidateSize({
                    debounceMoveend: true
                });
            }, this);
        },
        _onScroll: function _onScroll() {
            this._container.scrollTop = 0;
            this._container.scrollLeft = 0;
        },
        _onMoveEnd: function _onMoveEnd() {
            var pos = this._getMapPanePos();
            if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
            // a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/
            this._resetView(this.getCenter(), this.getZoom());
        },
        _findEventTargets: function _findEventTargets(e, type) {
            var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = false;
            while(src){
                target = this._targets[stamp(src)];
                if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
                    // Prevent firing click after you just dragged an object.
                    dragging = true;
                    break;
                }
                if (target && target.listens(type, true)) {
                    if (isHover && !isExternalTarget(src, e)) break;
                    targets.push(target);
                    if (isHover) break;
                }
                if (src === this._container) break;
                src = src.parentNode;
            }
            if (!targets.length && !dragging && !isHover && this.listens(type, true)) targets = [
                this
            ];
            return targets;
        },
        _isClickDisabled: function _isClickDisabled(el) {
            while(el && el !== this._container){
                if (el["_leaflet_disable_click"]) return true;
                el = el.parentNode;
            }
        },
        _handleDOMEvent: function _handleDOMEvent(e) {
            var el = e.target || e.srcElement;
            if (!this._loaded || el["_leaflet_disable_events"] || e.type === "click" && this._isClickDisabled(el)) return;
            var type = e.type;
            if (type === "mousedown") // prevents outline when clicking on keyboard-focusable element
            preventOutline(el);
            this._fireDOMEvent(e, type);
        },
        _mouseEvents: [
            "click",
            "dblclick",
            "mouseover",
            "mouseout",
            "contextmenu"
        ],
        _fireDOMEvent: function _fireDOMEvent(e, type, canvasTargets) {
            if (e.type === "click") {
                // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
                // @event preclick: MouseEvent
                // Fired before mouse click on the map (sometimes useful when you
                // want something to happen on click before any existing click
                // handlers start running).
                var synth = extend({}, e);
                synth.type = "preclick";
                this._fireDOMEvent(synth, synth.type, canvasTargets);
            }
            // Find the layer the event is propagating from and its parents.
            var targets = this._findEventTargets(e, type);
            if (canvasTargets) {
                var filtered = []; // pick only targets with listeners
                for(var i = 0; i < canvasTargets.length; i++)if (canvasTargets[i].listens(type, true)) filtered.push(canvasTargets[i]);
                targets = filtered.concat(targets);
            }
            if (!targets.length) return;
            if (type === "contextmenu") preventDefault(e);
            var target = targets[0];
            var data = {
                originalEvent: e
            };
            if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
                var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
                data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
                data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
                data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
            }
            for(i = 0; i < targets.length; i++){
                targets[i].fire(type, data, true);
                if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) return;
            }
        },
        _draggableMoved: function _draggableMoved(obj) {
            obj = obj.dragging && obj.dragging.enabled() ? obj : this;
            return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
        },
        _clearHandlers: function _clearHandlers() {
            for(var i = 0, len = this._handlers.length; i < len; i++)this._handlers[i].disable();
        },
        // @section Other Methods
        // @method whenReady(fn: Function, context?: Object): this
        // Runs the given function `fn` when the map gets initialized with
        // a view (center and zoom) and at least one layer, or immediately
        // if it's already initialized, optionally passing a function context.
        whenReady: function whenReady(callback, context) {
            if (this._loaded) callback.call(context || this, {
                target: this
            });
            else this.on("load", callback, context);
            return this;
        },
        // private methods for getting map state
        _getMapPanePos: function _getMapPanePos() {
            return getPosition(this._mapPane) || new Point(0, 0);
        },
        _moved: function _moved() {
            var pos = this._getMapPanePos();
            return pos && !pos.equals([
                0,
                0
            ]);
        },
        _getTopLeftPoint: function _getTopLeftPoint(center, zoom) {
            var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();
            return pixelOrigin.subtract(this._getMapPanePos());
        },
        _getNewPixelOrigin: function _getNewPixelOrigin(center, zoom) {
            var viewHalf = this.getSize()._divideBy(2);
            return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
        },
        _latLngToNewLayerPoint: function _latLngToNewLayerPoint(latlng, zoom, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom);
            return this.project(latlng, zoom)._subtract(topLeft);
        },
        _latLngBoundsToNewLayerBounds: function _latLngBoundsToNewLayerBounds(latLngBounds, zoom, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom);
            return toBounds([
                this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
                this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
                this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
                this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
            ]);
        },
        // layer point of the current center
        _getCenterLayerPoint: function _getCenterLayerPoint() {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },
        // offset of the specified place to the current center in pixels
        _getCenterOffset: function _getCenterOffset(latlng) {
            return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
        },
        // adjust center for view to get inside bounds
        _limitCenter: function _limitCenter(center, zoom, bounds) {
            if (!bounds) return center;
            var centerPoint = this.project(center, zoom), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom);
            // If offset is less than a pixel, ignore.
            // This prevents unstable projections from getting into
            // an infinite loop of tiny offsets.
            if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) return center;
            return this.unproject(centerPoint.add(offset), zoom);
        },
        // adjust offset for view to get inside bounds
        _limitOffset: function _limitOffset(offset, bounds) {
            if (!bounds) return offset;
            var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
            return offset.add(this._getBoundsOffset(newBounds, bounds));
        },
        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
        _getBoundsOffset: function _getBoundsOffset(pxBounds, maxBounds, zoom) {
            var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
            return new Point(dx, dy);
        },
        _rebound: function _rebound(left, right) {
            return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
        },
        _limitZoom: function _limitZoom(zoom) {
            var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;
            if (snap) zoom = Math.round(zoom / snap) * snap;
            return Math.max(min, Math.min(max, zoom));
        },
        _onPanTransitionStep: function _onPanTransitionStep() {
            this.fire("move");
        },
        _onPanTransitionEnd: function _onPanTransitionEnd() {
            removeClass(this._mapPane, "leaflet-pan-anim");
            this.fire("moveend");
        },
        _tryAnimatedPan: function _tryAnimatedPan(center, options) {
            // difference between the new and current centers in pixels
            var offset = this._getCenterOffset(center)._trunc();
            // don't animate too far unless animate: true specified in options
            if ((options && options.animate) !== true && !this.getSize().contains(offset)) return false;
            this.panBy(offset, options);
            return true;
        },
        _createAnimProxy: function _createAnimProxy() {
            var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
            this._panes.mapPane.appendChild(proxy);
            this.on("zoomanim", function(e) {
                var prop = TRANSFORM, transform = this._proxy.style[prop];
                setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
                // workaround for case when transform is the same and so transitionend event is not fired
                if (transform === this._proxy.style[prop] && this._animatingZoom) this._onZoomTransitionEnd();
            }, this);
            this.on("load moveend", this._animMoveEnd, this);
            this._on("unload", this._destroyAnimProxy, this);
        },
        _destroyAnimProxy: function _destroyAnimProxy() {
            remove(this._proxy);
            this.off("load moveend", this._animMoveEnd, this);
            delete this._proxy;
        },
        _animMoveEnd: function _animMoveEnd() {
            var c = this.getCenter(), z = this.getZoom();
            setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
        },
        _catchTransitionEnd: function _catchTransitionEnd(e) {
            if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) this._onZoomTransitionEnd();
        },
        _nothingToAnimate: function _nothingToAnimate() {
            return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
        },
        _tryAnimatedZoom: function _tryAnimatedZoom(center, zoom, options) {
            if (this._animatingZoom) return true;
            options = options || {};
            // don't animate if disabled, not supported or zoom difference is too large
            if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) return false;
            // offset is the pixel coords of the zoom origin relative to the current center
            var scale = this.getZoomScale(zoom), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);
            // don't animate if the zoom origin isn't within one screen from the current center, unless forced
            if (options.animate !== true && !this.getSize().contains(offset)) return false;
            requestAnimFrame(function() {
                this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom, true);
            }, this);
            return true;
        },
        _animateZoom: function _animateZoom(center, zoom, startAnim, noUpdate) {
            if (!this._mapPane) return;
            if (startAnim) {
                this._animatingZoom = true;
                // remember what center/zoom to set after animation
                this._animateToCenter = center;
                this._animateToZoom = zoom;
                addClass(this._mapPane, "leaflet-zoom-anim");
            }
            // @section Other Events
            // @event zoomanim: ZoomAnimEvent
            // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.
            this.fire("zoomanim", {
                center: center,
                zoom: zoom,
                noUpdate: noUpdate
            });
            if (!this._tempFireZoomEvent) this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
            this._move(this._animateToCenter, this._animateToZoom, undefined, true);
            // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
            setTimeout(bind(this._onZoomTransitionEnd, this), 250);
        },
        _onZoomTransitionEnd: function _onZoomTransitionEnd() {
            if (!this._animatingZoom) return;
            if (this._mapPane) removeClass(this._mapPane, "leaflet-zoom-anim");
            this._animatingZoom = false;
            this._move(this._animateToCenter, this._animateToZoom, undefined, true);
            if (this._tempFireZoomEvent) this.fire("zoom");
            delete this._tempFireZoomEvent;
            this.fire("move");
            this._moveEnd(true);
        }
    });
    // @section
    // @factory L.map(id: String, options?: Map options)
    // Instantiates a map object given the DOM ID of a `<div>` element
    // and optionally an object literal with `Map options`.
    //
    // @alternative
    // @factory L.map(el: HTMLElement, options?: Map options)
    // Instantiates a map object given an instance of a `<div>` HTML element
    // and optionally an object literal with `Map options`.
    function createMap(id, options) {
        return new Map(id, options);
    }
    /*
   * @class Control
   * @aka L.Control
   * @inherits Class
   *
   * L.Control is a base class for implementing map controls. Handles positioning.
   * All other controls extend from this class.
   */ var Control = Class.extend({
        // @section
        // @aka Control Options
        options: {
            // @option position: String = 'topright'
            // The position of the control (one of the map corners). Possible values are `'topleft'`,
            // `'topright'`, `'bottomleft'` or `'bottomright'`
            position: "topright"
        },
        initialize: function initialize(options) {
            setOptions(this, options);
        },
        /* @section
  	 * Classes extending L.Control will inherit the following methods:
  	 *
  	 * @method getPosition: string
  	 * Returns the position of the control.
  	 */ getPosition: function getPosition() {
            return this.options.position;
        },
        // @method setPosition(position: string): this
        // Sets the position of the control.
        setPosition: function setPosition(position) {
            var map = this._map;
            if (map) map.removeControl(this);
            this.options.position = position;
            if (map) map.addControl(this);
            return this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTMLElement that contains the control.
        getContainer: function getContainer() {
            return this._container;
        },
        // @method addTo(map: Map): this
        // Adds the control to the given map.
        addTo: function addTo(map) {
            this.remove();
            this._map = map;
            var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];
            addClass(container, "leaflet-control");
            if (pos.indexOf("bottom") !== -1) corner.insertBefore(container, corner.firstChild);
            else corner.appendChild(container);
            this._map.on("unload", this.remove, this);
            return this;
        },
        // @method remove: this
        // Removes the control from the map it is currently active on.
        remove: function remove1() {
            if (!this._map) return this;
            remove(this._container);
            if (this.onRemove) this.onRemove(this._map);
            this._map.off("unload", this.remove, this);
            this._map = null;
            return this;
        },
        _refocusOnMap: function _refocusOnMap(e) {
            // if map exists and event is not a keyboard event
            if (this._map && e && e.screenX > 0 && e.screenY > 0) this._map.getContainer().focus();
        }
    });
    var control = function control(options) {
        return new Control(options);
    };
    /* @section Extension methods
   * @uninheritable
   *
   * Every control should extend from `L.Control` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): HTMLElement
   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
   *
   * @method onRemove(map: Map)
   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
   */ /* @namespace Map
   * @section Methods for Layers and Controls
   */ Map.include({
        // @method addControl(control: Control): this
        // Adds the given control to the map
        addControl: function addControl(control) {
            control.addTo(this);
            return this;
        },
        // @method removeControl(control: Control): this
        // Removes the given control from the map
        removeControl: function removeControl(control) {
            control.remove();
            return this;
        },
        _initControlPos: function _initControlPos() {
            var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create$1("div", l + "control-container", this._container);
            function createCorner(vSide, hSide) {
                var className = l + vSide + " " + l + hSide;
                corners[vSide + hSide] = create$1("div", className, container);
            }
            createCorner("top", "left");
            createCorner("top", "right");
            createCorner("bottom", "left");
            createCorner("bottom", "right");
        },
        _clearControlPos: function _clearControlPos() {
            for(var i in this._controlCorners)remove(this._controlCorners[i]);
            remove(this._controlContainer);
            delete this._controlCorners;
            delete this._controlContainer;
        }
    });
    /*
   * @class Control.Layers
   * @aka L.Control.Layers
   * @inherits Control
   *
   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](https://leafletjs.com/examples/layers-control/)). Extends `Control`.
   *
   * @example
   *
   * ```js
   * var baseLayers = {
   * 	"Mapbox": mapbox,
   * 	"OpenStreetMap": osm
   * };
   *
   * var overlays = {
   * 	"Marker": marker,
   * 	"Roads": roadsLayer
   * };
   *
   * L.control.layers(baseLayers, overlays).addTo(map);
   * ```
   *
   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
   *
   * ```js
   * {
   *     "<someName1>": layer1,
   *     "<someName2>": layer2
   * }
   * ```
   *
   * The layer names can contain HTML, which allows you to add additional styling to the items:
   *
   * ```js
   * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
   * ```
   */ var Layers = Control.extend({
        // @section
        // @aka Control.Layers options
        options: {
            // @option collapsed: Boolean = true
            // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
            collapsed: true,
            position: "topright",
            // @option autoZIndex: Boolean = true
            // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
            autoZIndex: true,
            // @option hideSingleBase: Boolean = false
            // If `true`, the base layers in the control will be hidden when there is only one.
            hideSingleBase: false,
            // @option sortLayers: Boolean = false
            // Whether to sort the layers. When `false`, layers will keep the order
            // in which they were added to the control.
            sortLayers: false,
            // @option sortFunction: Function = *
            // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
            // that will be used for sorting the layers, when `sortLayers` is `true`.
            // The function receives both the `L.Layer` instances and their names, as in
            // `sortFunction(layerA, layerB, nameA, nameB)`.
            // By default, it sorts layers alphabetically by their name.
            sortFunction: function sortFunction(layerA, layerB, nameA, nameB) {
                return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
            }
        },
        initialize: function initialize(baseLayers, overlays, options) {
            setOptions(this, options);
            this._layerControlInputs = [];
            this._layers = [];
            this._lastZIndex = 0;
            this._handlingClick = false;
            this._preventClick = false;
            for(var i in baseLayers)this._addLayer(baseLayers[i], i);
            for(i in overlays)this._addLayer(overlays[i], i, true);
        },
        onAdd: function onAdd(map) {
            this._initLayout();
            this._update();
            this._map = map;
            map.on("zoomend", this._checkDisabledLayers, this);
            for(var i = 0; i < this._layers.length; i++)this._layers[i].layer.on("add remove", this._onLayerChange, this);
            return this._container;
        },
        addTo: function addTo(map) {
            Control.prototype.addTo.call(this, map);
            // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
            return this._expandIfNotCollapsed();
        },
        onRemove: function onRemove() {
            this._map.off("zoomend", this._checkDisabledLayers, this);
            for(var i = 0; i < this._layers.length; i++)this._layers[i].layer.off("add remove", this._onLayerChange, this);
        },
        // @method addBaseLayer(layer: Layer, name: String): this
        // Adds a base layer (radio button entry) with the given name to the control.
        addBaseLayer: function addBaseLayer(layer, name) {
            this._addLayer(layer, name);
            return this._map ? this._update() : this;
        },
        // @method addOverlay(layer: Layer, name: String): this
        // Adds an overlay (checkbox entry) with the given name to the control.
        addOverlay: function addOverlay(layer, name) {
            this._addLayer(layer, name, true);
            return this._map ? this._update() : this;
        },
        // @method removeLayer(layer: Layer): this
        // Remove the given layer from the control.
        removeLayer: function removeLayer(layer) {
            layer.off("add remove", this._onLayerChange, this);
            var obj = this._getLayer(stamp(layer));
            if (obj) this._layers.splice(this._layers.indexOf(obj), 1);
            return this._map ? this._update() : this;
        },
        // @method expand(): this
        // Expand the control container if collapsed.
        expand: function expand() {
            addClass(this._container, "leaflet-control-layers-expanded");
            this._section.style.height = null;
            var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
            if (acceptableHeight < this._section.clientHeight) {
                addClass(this._section, "leaflet-control-layers-scrollbar");
                this._section.style.height = acceptableHeight + "px";
            } else removeClass(this._section, "leaflet-control-layers-scrollbar");
            this._checkDisabledLayers();
            return this;
        },
        // @method collapse(): this
        // Collapse the control container if expanded.
        collapse: function collapse() {
            removeClass(this._container, "leaflet-control-layers-expanded");
            return this;
        },
        _initLayout: function _initLayout() {
            var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
            // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
            container.setAttribute("aria-haspopup", true);
            disableClickPropagation(container);
            disableScrollPropagation(container);
            var section = this._section = create$1("section", className + "-list");
            if (collapsed) {
                this._map.on("click", this.collapse, this);
                on(container, {
                    mouseenter: this._expandSafely,
                    mouseleave: this.collapse
                }, this);
            }
            var link = this._layersLink = create$1("a", className + "-toggle", container);
            link.href = "#";
            link.title = "Layers";
            link.setAttribute("role", "button");
            on(link, {
                keydown: function keydown(e) {
                    if (e.keyCode === 13) this._expandSafely();
                },
                // Certain screen readers intercept the key event and instead send a click event
                click: function click(e) {
                    preventDefault(e);
                    this._expandSafely();
                }
            }, this);
            if (!collapsed) this.expand();
            this._baseLayersList = create$1("div", className + "-base", section);
            this._separator = create$1("div", className + "-separator", section);
            this._overlaysList = create$1("div", className + "-overlays", section);
            container.appendChild(section);
        },
        _getLayer: function _getLayer(id) {
            for(var i = 0; i < this._layers.length; i++){
                if (this._layers[i] && stamp(this._layers[i].layer) === id) return this._layers[i];
            }
        },
        _addLayer: function _addLayer(layer, name, overlay) {
            if (this._map) layer.on("add remove", this._onLayerChange, this);
            this._layers.push({
                layer: layer,
                name: name,
                overlay: overlay
            });
            if (this.options.sortLayers) this._layers.sort(bind(function(a, b) {
                return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
            }, this));
            if (this.options.autoZIndex && layer.setZIndex) {
                this._lastZIndex++;
                layer.setZIndex(this._lastZIndex);
            }
            this._expandIfNotCollapsed();
        },
        _update: function _update() {
            if (!this._container) return this;
            empty(this._baseLayersList);
            empty(this._overlaysList);
            this._layerControlInputs = [];
            var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;
            for(i = 0; i < this._layers.length; i++){
                obj = this._layers[i];
                this._addItem(obj);
                overlaysPresent = overlaysPresent || obj.overlay;
                baseLayersPresent = baseLayersPresent || !obj.overlay;
                baseLayersCount += !obj.overlay ? 1 : 0;
            }
            // Hide base layers section if there's only one layer.
            if (this.options.hideSingleBase) {
                baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
                this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
            }
            this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
            return this;
        },
        _onLayerChange: function _onLayerChange(e) {
            if (!this._handlingClick) this._update();
            var obj = this._getLayer(stamp(e.target));
            // @namespace Map
            // @section Layer events
            // @event baselayerchange: LayersControlEvent
            // Fired when the base layer is changed through the [layers control](#control-layers).
            // @event overlayadd: LayersControlEvent
            // Fired when an overlay is selected through the [layers control](#control-layers).
            // @event overlayremove: LayersControlEvent
            // Fired when an overlay is deselected through the [layers control](#control-layers).
            // @namespace Control.Layers
            var type = obj.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
            if (type) this._map.fire(type, obj);
        },
        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
        _createRadioElement: function _createRadioElement(name, checked) {
            var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
            var radioFragment = document.createElement("div");
            radioFragment.innerHTML = radioHtml;
            return radioFragment.firstChild;
        },
        _addItem: function _addItem(obj) {
            var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
            if (obj.overlay) {
                input = document.createElement("input");
                input.type = "checkbox";
                input.className = "leaflet-control-layers-selector";
                input.defaultChecked = checked;
            } else input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
            this._layerControlInputs.push(input);
            input.layerId = stamp(obj.layer);
            on(input, "click", this._onInputClick, this);
            var name = document.createElement("span");
            name.innerHTML = " " + obj.name;
            // Helps from preventing layer control flicker when checkboxes are disabled
            // https://github.com/Leaflet/Leaflet/issues/2771
            var holder = document.createElement("span");
            label.appendChild(holder);
            holder.appendChild(input);
            holder.appendChild(name);
            var container = obj.overlay ? this._overlaysList : this._baseLayersList;
            container.appendChild(label);
            this._checkDisabledLayers();
            return label;
        },
        _onInputClick: function _onInputClick() {
            // expanding the control on mobile with a click can cause adding a layer - we don't want this
            if (this._preventClick) return;
            var inputs = this._layerControlInputs, input, layer;
            var addedLayers = [], removedLayers = [];
            this._handlingClick = true;
            for(var i = inputs.length - 1; i >= 0; i--){
                input = inputs[i];
                layer = this._getLayer(input.layerId).layer;
                if (input.checked) addedLayers.push(layer);
                else if (!input.checked) removedLayers.push(layer);
            }
            // Bugfix issue 2318: Should remove all old layers before readding new ones
            for(i = 0; i < removedLayers.length; i++)if (this._map.hasLayer(removedLayers[i])) this._map.removeLayer(removedLayers[i]);
            for(i = 0; i < addedLayers.length; i++)if (!this._map.hasLayer(addedLayers[i])) this._map.addLayer(addedLayers[i]);
            this._handlingClick = false;
            this._refocusOnMap();
        },
        _checkDisabledLayers: function _checkDisabledLayers() {
            var inputs = this._layerControlInputs, input, layer, zoom = this._map.getZoom();
            for(var i = inputs.length - 1; i >= 0; i--){
                input = inputs[i];
                layer = this._getLayer(input.layerId).layer;
                input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;
            }
        },
        _expandIfNotCollapsed: function _expandIfNotCollapsed() {
            if (this._map && !this.options.collapsed) this.expand();
            return this;
        },
        _expandSafely: function _expandSafely() {
            var section = this._section;
            this._preventClick = true;
            on(section, "click", preventDefault);
            this.expand();
            var that = this;
            setTimeout(function() {
                off(section, "click", preventDefault);
                that._preventClick = false;
            });
        }
    });
    // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
    // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
    var layers = function layers(baseLayers, overlays, options) {
        return new Layers(baseLayers, overlays, options);
    };
    /*
   * @class Control.Zoom
   * @aka L.Control.Zoom
   * @inherits Control
   *
   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
   */ var Zoom = Control.extend({
        // @section
        // @aka Control.Zoom options
        options: {
            position: "topleft",
            // @option zoomInText: String = '<span aria-hidden="true">+</span>'
            // The text set on the 'zoom in' button.
            zoomInText: '<span aria-hidden="true">+</span>',
            // @option zoomInTitle: String = 'Zoom in'
            // The title set on the 'zoom in' button.
            zoomInTitle: "Zoom in",
            // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
            // The text set on the 'zoom out' button.
            zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
            // @option zoomOutTitle: String = 'Zoom out'
            // The title set on the 'zoom out' button.
            zoomOutTitle: "Zoom out"
        },
        onAdd: function onAdd(map) {
            var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
            this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + "-in", container, this._zoomIn);
            this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + "-out", container, this._zoomOut);
            this._updateDisabled();
            map.on("zoomend zoomlevelschange", this._updateDisabled, this);
            return container;
        },
        onRemove: function onRemove(map) {
            map.off("zoomend zoomlevelschange", this._updateDisabled, this);
        },
        disable: function disable() {
            this._disabled = true;
            this._updateDisabled();
            return this;
        },
        enable: function enable() {
            this._disabled = false;
            this._updateDisabled();
            return this;
        },
        _zoomIn: function _zoomIn(e) {
            if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
        },
        _zoomOut: function _zoomOut(e) {
            if (!this._disabled && this._map._zoom > this._map.getMinZoom()) this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
        },
        _createButton: function _createButton(html, title, className, container, fn) {
            var link = create$1("a", className, container);
            link.innerHTML = html;
            link.href = "#";
            link.title = title;
            /*
  		 * Will force screen readers like VoiceOver to read this as "Zoom in - button"
  		 */ link.setAttribute("role", "button");
            link.setAttribute("aria-label", title);
            disableClickPropagation(link);
            on(link, "click", stop);
            on(link, "click", fn, this);
            on(link, "click", this._refocusOnMap, this);
            return link;
        },
        _updateDisabled: function _updateDisabled() {
            var map = this._map, className = "leaflet-disabled";
            removeClass(this._zoomInButton, className);
            removeClass(this._zoomOutButton, className);
            this._zoomInButton.setAttribute("aria-disabled", "false");
            this._zoomOutButton.setAttribute("aria-disabled", "false");
            if (this._disabled || map._zoom === map.getMinZoom()) {
                addClass(this._zoomOutButton, className);
                this._zoomOutButton.setAttribute("aria-disabled", "true");
            }
            if (this._disabled || map._zoom === map.getMaxZoom()) {
                addClass(this._zoomInButton, className);
                this._zoomInButton.setAttribute("aria-disabled", "true");
            }
        }
    });
    // @namespace Map
    // @section Control options
    // @option zoomControl: Boolean = true
    // Whether a [zoom control](#control-zoom) is added to the map by default.
    Map.mergeOptions({
        zoomControl: true
    });
    Map.addInitHook(function() {
        if (this.options.zoomControl) {
            // @section Controls
            // @property zoomControl: Control.Zoom
            // The default zoom control (only available if the
            // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).
            this.zoomControl = new Zoom();
            this.addControl(this.zoomControl);
        }
    });
    // @namespace Control.Zoom
    // @factory L.control.zoom(options: Control.Zoom options)
    // Creates a zoom control
    var zoom = function zoom(options) {
        return new Zoom(options);
    };
    /*
   * @class Control.Scale
   * @aka L.Control.Scale
   * @inherits Control
   *
   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
   *
   * @example
   *
   * ```js
   * L.control.scale().addTo(map);
   * ```
   */ var Scale = Control.extend({
        // @section
        // @aka Control.Scale options
        options: {
            position: "bottomleft",
            // @option maxWidth: Number = 100
            // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
            maxWidth: 100,
            // @option metric: Boolean = True
            // Whether to show the metric scale line (m/km).
            metric: true,
            // @option imperial: Boolean = True
            // Whether to show the imperial scale line (mi/ft).
            imperial: true
        },
        onAdd: function onAdd(map) {
            var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
            this._addScales(options, className + "-line", container);
            map.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
            map.whenReady(this._update, this);
            return container;
        },
        onRemove: function onRemove(map) {
            map.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
        },
        _addScales: function _addScales(options, className, container) {
            if (options.metric) this._mScale = create$1("div", className, container);
            if (options.imperial) this._iScale = create$1("div", className, container);
        },
        _update: function _update() {
            var map = this._map, y = map.getSize().y / 2;
            var maxMeters = map.distance(map.containerPointToLatLng([
                0,
                y
            ]), map.containerPointToLatLng([
                this.options.maxWidth,
                y
            ]));
            this._updateScales(maxMeters);
        },
        _updateScales: function _updateScales(maxMeters) {
            if (this.options.metric && maxMeters) this._updateMetric(maxMeters);
            if (this.options.imperial && maxMeters) this._updateImperial(maxMeters);
        },
        _updateMetric: function _updateMetric(maxMeters) {
            var meters = this._getRoundNum(maxMeters), label = meters < 1000 ? meters + " m" : meters / 1000 + " km";
            this._updateScale(this._mScale, label, meters / maxMeters);
        },
        _updateImperial: function _updateImperial(maxMeters) {
            var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
            if (maxFeet > 5280) {
                maxMiles = maxFeet / 5280;
                miles = this._getRoundNum(maxMiles);
                this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
            } else {
                feet = this._getRoundNum(maxFeet);
                this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
            }
        },
        _updateScale: function _updateScale(scale, text, ratio) {
            scale.style.width = Math.round(this.options.maxWidth * ratio) + "px";
            scale.innerHTML = text;
        },
        _getRoundNum: function _getRoundNum(num) {
            var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
            d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
            return pow10 * d;
        }
    });
    // @factory L.control.scale(options?: Control.Scale options)
    // Creates an scale control with the given options.
    var scale = function scale(options) {
        return new Scale(options);
    };
    var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
    /*
   * @class Control.Attribution
   * @aka L.Control.Attribution
   * @inherits Control
   *
   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
   */ var Attribution = Control.extend({
        // @section
        // @aka Control.Attribution options
        options: {
            position: "bottomright",
            // @option prefix: String|false = 'Leaflet'
            // The HTML text shown before the attributions. Pass `false` to disable.
            prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
        },
        initialize: function initialize(options) {
            setOptions(this, options);
            this._attributions = {};
        },
        onAdd: function onAdd(map) {
            map.attributionControl = this;
            this._container = create$1("div", "leaflet-control-attribution");
            disableClickPropagation(this._container);
            // TODO ugly, refactor
            for(var i in map._layers)if (map._layers[i].getAttribution) this.addAttribution(map._layers[i].getAttribution());
            this._update();
            map.on("layeradd", this._addAttribution, this);
            return this._container;
        },
        onRemove: function onRemove(map) {
            map.off("layeradd", this._addAttribution, this);
        },
        _addAttribution: function _addAttribution(ev) {
            if (ev.layer.getAttribution) {
                this.addAttribution(ev.layer.getAttribution());
                ev.layer.once("remove", function() {
                    this.removeAttribution(ev.layer.getAttribution());
                }, this);
            }
        },
        // @method setPrefix(prefix: String|false): this
        // The HTML text shown before the attributions. Pass `false` to disable.
        setPrefix: function setPrefix(prefix) {
            this.options.prefix = prefix;
            this._update();
            return this;
        },
        // @method addAttribution(text: String): this
        // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
        addAttribution: function addAttribution(text) {
            if (!text) return this;
            if (!this._attributions[text]) this._attributions[text] = 0;
            this._attributions[text]++;
            this._update();
            return this;
        },
        // @method removeAttribution(text: String): this
        // Removes an attribution text.
        removeAttribution: function removeAttribution(text) {
            if (!text) return this;
            if (this._attributions[text]) {
                this._attributions[text]--;
                this._update();
            }
            return this;
        },
        _update: function _update() {
            if (!this._map) return;
            var attribs = [];
            for(var i in this._attributions)if (this._attributions[i]) attribs.push(i);
            var prefixAndAttribs = [];
            if (this.options.prefix) prefixAndAttribs.push(this.options.prefix);
            if (attribs.length) prefixAndAttribs.push(attribs.join(", "));
            this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
        }
    });
    // @namespace Map
    // @section Control options
    // @option attributionControl: Boolean = true
    // Whether a [attribution control](#control-attribution) is added to the map by default.
    Map.mergeOptions({
        attributionControl: true
    });
    Map.addInitHook(function() {
        if (this.options.attributionControl) new Attribution().addTo(this);
    });
    // @namespace Control.Attribution
    // @factory L.control.attribution(options: Control.Attribution options)
    // Creates an attribution control.
    var attribution = function attribution(options) {
        return new Attribution(options);
    };
    Control.Layers = Layers;
    Control.Zoom = Zoom;
    Control.Scale = Scale;
    Control.Attribution = Attribution;
    control.layers = layers;
    control.zoom = zoom;
    control.scale = scale;
    control.attribution = attribution;
    /*
  	L.Handler is a base class for handler classes that are used internally to inject
  	interaction features like dragging to classes like Map and Marker.
  */ // @class Handler
    // @aka L.Handler
    // Abstract class for map interaction handlers
    var Handler = Class.extend({
        initialize: function initialize(map) {
            this._map = map;
        },
        // @method enable(): this
        // Enables the handler
        enable: function enable() {
            if (this._enabled) return this;
            this._enabled = true;
            this.addHooks();
            return this;
        },
        // @method disable(): this
        // Disables the handler
        disable: function disable() {
            if (!this._enabled) return this;
            this._enabled = false;
            this.removeHooks();
            return this;
        },
        // @method enabled(): Boolean
        // Returns `true` if the handler is enabled
        enabled: function enabled() {
            return !!this._enabled;
        }
    });
    // @section There is static function which can be called without instantiating L.Handler:
    // @function addTo(map: Map, name: String): this
    // Adds a new Handler to the given map with the given name.
    Handler.addTo = function(map, name) {
        map.addHandler(name, this);
        return this;
    };
    var Mixin = {
        Events: Events
    };
    /*
   * @class Draggable
   * @aka L.Draggable
   * @inherits Evented
   *
   * A class for making DOM elements draggable (including touch support).
   * Used internally for map and marker dragging. Only works for elements
   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
   *
   * @example
   * ```js
   * var draggable = new L.Draggable(elementToDrag);
   * draggable.enable();
   * ```
   */ var START = Browser.touch ? "touchstart mousedown" : "mousedown";
    var Draggable = Evented.extend({
        options: {
            // @section
            // @aka Draggable options
            // @option clickTolerance: Number = 3
            // The max number of pixels a user can shift the mouse pointer during a click
            // for it to be considered a valid click (as opposed to a mouse drag).
            clickTolerance: 3
        },
        // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
        // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
        initialize: function initialize(element, dragStartTarget, preventOutline, options) {
            setOptions(this, options);
            this._element = element;
            this._dragStartTarget = dragStartTarget || element;
            this._preventOutline = preventOutline;
        },
        // @method enable()
        // Enables the dragging ability
        enable: function enable() {
            if (this._enabled) return;
            on(this._dragStartTarget, START, this._onDown, this);
            this._enabled = true;
        },
        // @method disable()
        // Disables the dragging ability
        disable: function disable() {
            if (!this._enabled) return;
            // If we're currently dragging this draggable,
            // disabling it counts as first ending the drag.
            if (Draggable._dragging === this) this.finishDrag(true);
            off(this._dragStartTarget, START, this._onDown, this);
            this._enabled = false;
            this._moved = false;
        },
        _onDown: function _onDown(e) {
            // Ignore the event if disabled; this happens in IE11
            // under some circumstances, see #3666.
            if (!this._enabled) return;
            this._moved = false;
            if (hasClass(this._element, "leaflet-zoom-anim")) return;
            if (e.touches && e.touches.length !== 1) {
                // Finish dragging to avoid conflict with touchZoom
                if (Draggable._dragging === this) this.finishDrag();
                return;
            }
            if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) return;
            Draggable._dragging = this; // Prevent dragging multiple objects at once.
            if (this._preventOutline) preventOutline(this._element);
            disableImageDrag();
            disableTextSelection();
            if (this._moving) return;
            // @event down: Event
            // Fired when a drag is about to start.
            this.fire("down");
            var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
            this._startPoint = new Point(first.clientX, first.clientY);
            this._startPos = getPosition(this._element);
            // Cache the scale, so that we can continuously compensate for it during drag (_onMove).
            this._parentScale = getScale(sizedParent);
            var mouseevent = e.type === "mousedown";
            on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
            on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
        },
        _onMove: function _onMove(e) {
            // Ignore the event if disabled; this happens in IE11
            // under some circumstances, see #3666.
            if (!this._enabled) return;
            if (e.touches && e.touches.length > 1) {
                this._moved = true;
                return;
            }
            var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
            if (!offset.x && !offset.y) return;
            if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) return;
            // We assume that the parent container's position, border and scale do not change for the duration of the drag.
            // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
            // and we can use the cached value for the scale.
            offset.x /= this._parentScale.x;
            offset.y /= this._parentScale.y;
            preventDefault(e);
            if (!this._moved) {
                // @event dragstart: Event
                // Fired when a drag starts
                this.fire("dragstart");
                this._moved = true;
                addClass(document.body, "leaflet-dragging");
                this._lastTarget = e.target || e.srcElement;
                // IE and Edge do not give the <use> element, so fetch it
                // if necessary
                if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) this._lastTarget = this._lastTarget.correspondingUseElement;
                addClass(this._lastTarget, "leaflet-drag-target");
            }
            this._newPos = this._startPos.add(offset);
            this._moving = true;
            this._lastEvent = e;
            this._updatePosition();
        },
        _updatePosition: function _updatePosition() {
            var e = {
                originalEvent: this._lastEvent
            };
            // @event predrag: Event
            // Fired continuously during dragging *before* each corresponding
            // update of the element's position.
            this.fire("predrag", e);
            setPosition(this._element, this._newPos);
            // @event drag: Event
            // Fired continuously during dragging.
            this.fire("drag", e);
        },
        _onUp: function _onUp() {
            // Ignore the event if disabled; this happens in IE11
            // under some circumstances, see #3666.
            if (!this._enabled) return;
            this.finishDrag();
        },
        finishDrag: function finishDrag(noInertia) {
            removeClass(document.body, "leaflet-dragging");
            if (this._lastTarget) {
                removeClass(this._lastTarget, "leaflet-drag-target");
                this._lastTarget = null;
            }
            off(document, "mousemove touchmove", this._onMove, this);
            off(document, "mouseup touchend touchcancel", this._onUp, this);
            enableImageDrag();
            enableTextSelection();
            var fireDragend = this._moved && this._moving;
            this._moving = false;
            Draggable._dragging = false;
            if (fireDragend) // @event dragend: DragEndEvent
            // Fired when the drag ends.
            this.fire("dragend", {
                noInertia: noInertia,
                distance: this._newPos.distanceTo(this._startPos)
            });
        }
    });
    /*
   * @namespace PolyUtil
   * Various utility functions for polygon geometries.
   */ /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
   * Used by Leaflet to only show polygon points that are on the screen or near, increasing
   * performance. Note that polygon points needs different algorithm for clipping
   * than polyline, so there's a separate method for it.
   */ function clipPolygon(points, bounds, round) {
        var clippedPoints, edges = [
            1,
            4,
            2,
            8
        ], i, j, k, a, b, len, edge, p;
        for(i = 0, len = points.length; i < len; i++)points[i]._code = _getBitCode(points[i], bounds);
        // for each edge (left, bottom, right, top)
        for(k = 0; k < 4; k++){
            edge = edges[k];
            clippedPoints = [];
            for(i = 0, len = points.length, j = len - 1; i < len; j = i++){
                a = points[i];
                b = points[j];
                // if a is inside the clip window
                if (!(a._code & edge)) {
                    // if b is outside the clip window (a->b goes out of screen)
                    if (b._code & edge) {
                        p = _getEdgeIntersection(b, a, edge, bounds, round);
                        p._code = _getBitCode(p, bounds);
                        clippedPoints.push(p);
                    }
                    clippedPoints.push(a);
                // else if b is inside the clip window (a->b enters the screen)
                } else if (!(b._code & edge)) {
                    p = _getEdgeIntersection(b, a, edge, bounds, round);
                    p._code = _getBitCode(p, bounds);
                    clippedPoints.push(p);
                }
            }
            points = clippedPoints;
        }
        return points;
    }
    /* @function polygonCenter(latlngs: LatLng[], crs: CRS): LatLng
   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polygon.
   */ function polygonCenter(latlngs, crs) {
        var i, j, p1, p2, f, area, x, y, center;
        if (!latlngs || latlngs.length === 0) throw new Error("latlngs not passed");
        if (!isFlat(latlngs)) {
            console.warn("latlngs are not flat! Only the first ring will be used");
            latlngs = latlngs[0];
        }
        var centroidLatLng = toLatLng([
            0,
            0
        ]);
        var bounds = toLatLngBounds(latlngs);
        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
        // tests showed that below 1700 rounding errors are happening
        if (areaBounds < 1700) // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors
        centroidLatLng = centroid(latlngs);
        var len = latlngs.length;
        var points = [];
        for(i = 0; i < len; i++){
            var latlng = toLatLng(latlngs[i]);
            points.push(crs.project(toLatLng([
                latlng.lat - centroidLatLng.lat,
                latlng.lng - centroidLatLng.lng
            ])));
        }
        area = x = y = 0;
        // polygon centroid algorithm;
        for(i = 0, j = len - 1; i < len; j = i++){
            p1 = points[i];
            p2 = points[j];
            f = p1.y * p2.x - p2.y * p1.x;
            x += (p1.x + p2.x) * f;
            y += (p1.y + p2.y) * f;
            area += f * 3;
        }
        if (area === 0) // Polygon is so small that all points are on same pixel.
        center = points[0];
        else center = [
            x / area,
            y / area
        ];
        var latlngCenter = crs.unproject(toPoint(center));
        return toLatLng([
            latlngCenter.lat + centroidLatLng.lat,
            latlngCenter.lng + centroidLatLng.lng
        ]);
    }
    /* @function centroid(latlngs: LatLng[]): LatLng
   * Returns the 'center of mass' of the passed LatLngs.
   */ function centroid(coords) {
        var latSum = 0;
        var lngSum = 0;
        var len = 0;
        for(var i = 0; i < coords.length; i++){
            var latlng = toLatLng(coords[i]);
            latSum += latlng.lat;
            lngSum += latlng.lng;
            len++;
        }
        return toLatLng([
            latSum / len,
            lngSum / len
        ]);
    }
    var PolyUtil = {
        __proto__: null,
        clipPolygon: clipPolygon,
        polygonCenter: polygonCenter,
        centroid: centroid
    };
    /*
   * @namespace LineUtil
   *
   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
   */ // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
    // Improves rendering performance dramatically by lessening the number of points to draw.
    // @function simplify(points: Point[], tolerance: Number): Point[]
    // Dramatically reduces the number of points in a polyline while retaining
    // its shape and returns a new array of simplified points, using the
    // [Ramer-Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm).
    // Used for a huge performance boost when processing/displaying Leaflet polylines for
    // each zoom level and also reducing visual noise. tolerance affects the amount of
    // simplification (lesser value means higher quality but slower and with more points).
    // Also released as a separated micro-library [Simplify.js](https://mourner.github.io/simplify-js/).
    function simplify(points, tolerance) {
        if (!tolerance || !points.length) return points.slice();
        var sqTolerance = tolerance * tolerance;
        // stage 1: vertex reduction
        points = _reducePoints(points, sqTolerance);
        // stage 2: Douglas-Peucker simplification
        points = _simplifyDP(points, sqTolerance);
        return points;
    }
    // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
    // Returns the distance between point `p` and segment `p1` to `p2`.
    function pointToSegmentDistance(p, p1, p2) {
        return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
    }
    // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
    // Returns the closest point from a point `p` on a segment `p1` to `p2`.
    function closestPointOnSegment(p, p1, p2) {
        return _sqClosestPointOnSegment(p, p1, p2);
    }
    // Ramer-Douglas-Peucker simplification, see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
    function _simplifyDP(points, sqTolerance) {
        var len = points.length, ArrayConstructor = typeof Uint8Array !== "undefined" ? Uint8Array : Array, markers = new ArrayConstructor(len);
        markers[0] = markers[len - 1] = 1;
        _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
        var i, newPoints = [];
        for(i = 0; i < len; i++)if (markers[i]) newPoints.push(points[i]);
        return newPoints;
    }
    function _simplifyDPStep(points, markers, sqTolerance, first, last) {
        var maxSqDist = 0, index, i, sqDist;
        for(i = first + 1; i <= last - 1; i++){
            sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);
            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }
        if (maxSqDist > sqTolerance) {
            markers[index] = 1;
            _simplifyDPStep(points, markers, sqTolerance, first, index);
            _simplifyDPStep(points, markers, sqTolerance, index, last);
        }
    }
    // reduce points that are too close to each other to a single point
    function _reducePoints(points, sqTolerance) {
        var reducedPoints = [
            points[0]
        ];
        for(var i = 1, prev = 0, len = points.length; i < len; i++)if (_sqDist(points[i], points[prev]) > sqTolerance) {
            reducedPoints.push(points[i]);
            prev = i;
        }
        if (prev < len - 1) reducedPoints.push(points[len - 1]);
        return reducedPoints;
    }
    var _lastCode;
    // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
    // Clips the segment a to b by rectangular bounds with the
    // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
    // (modifying the segment points directly!). Used by Leaflet to only show polyline
    // points that are on the screen or near, increasing performance.
    function clipSegment(a, b, bounds, useLastCode, round) {
        var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p, newCode;
        // save 2nd code to avoid calculating it on the next segment
        _lastCode = codeB;
        while(true){
            // if a,b is inside the clip window (trivial accept)
            if (!(codeA | codeB)) return [
                a,
                b
            ];
            // if a,b is outside the clip window (trivial reject)
            if (codeA & codeB) return false;
            // other cases
            codeOut = codeA || codeB;
            p = _getEdgeIntersection(a, b, codeOut, bounds, round);
            newCode = _getBitCode(p, bounds);
            if (codeOut === codeA) {
                a = p;
                codeA = newCode;
            } else {
                b = p;
                codeB = newCode;
            }
        }
    }
    function _getEdgeIntersection(a, b, code, bounds, round) {
        var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max, x, y;
        if (code & 8) {
            x = a.x + dx * (max.y - a.y) / dy;
            y = max.y;
        } else if (code & 4) {
            x = a.x + dx * (min.y - a.y) / dy;
            y = min.y;
        } else if (code & 2) {
            x = max.x;
            y = a.y + dy * (max.x - a.x) / dx;
        } else if (code & 1) {
            x = min.x;
            y = a.y + dy * (min.x - a.x) / dx;
        }
        return new Point(x, y, round);
    }
    function _getBitCode(p, bounds) {
        var code = 0;
        if (p.x < bounds.min.x) code |= 1;
        else if (p.x > bounds.max.x) code |= 2;
        if (p.y < bounds.min.y) code |= 4;
        else if (p.y > bounds.max.y) code |= 8;
        return code;
    }
    // square distance (to avoid unnecessary Math.sqrt calls)
    function _sqDist(p1, p2) {
        var dx = p2.x - p1.x, dy = p2.y - p1.y;
        return dx * dx + dy * dy;
    }
    // return closest point on segment or distance to that point
    function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
        var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;
        if (dot > 0) {
            t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
            if (t > 1) {
                x = p2.x;
                y = p2.y;
            } else if (t > 0) {
                x += dx * t;
                y += dy * t;
            }
        }
        dx = p.x - x;
        dy = p.y - y;
        return sqDist ? dx * dx + dy * dy : new Point(x, y);
    }
    // @function isFlat(latlngs: LatLng[]): Boolean
    // Returns true if `latlngs` is a flat array, false is nested.
    function isFlat(latlngs) {
        return !isArray(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
    }
    function _flat(latlngs) {
        console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
        return isFlat(latlngs);
    }
    /* @function polylineCenter(latlngs: LatLng[], crs: CRS): LatLng
   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polyline.
   */ function polylineCenter(latlngs, crs) {
        var i, halfDist, segDist, dist, p1, p2, ratio, center;
        if (!latlngs || latlngs.length === 0) throw new Error("latlngs not passed");
        if (!isFlat(latlngs)) {
            console.warn("latlngs are not flat! Only the first ring will be used");
            latlngs = latlngs[0];
        }
        var centroidLatLng = toLatLng([
            0,
            0
        ]);
        var bounds = toLatLngBounds(latlngs);
        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
        // tests showed that below 1700 rounding errors are happening
        if (areaBounds < 1700) // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors
        centroidLatLng = centroid(latlngs);
        var len = latlngs.length;
        var points = [];
        for(i = 0; i < len; i++){
            var latlng = toLatLng(latlngs[i]);
            points.push(crs.project(toLatLng([
                latlng.lat - centroidLatLng.lat,
                latlng.lng - centroidLatLng.lng
            ])));
        }
        for(i = 0, halfDist = 0; i < len - 1; i++)halfDist += points[i].distanceTo(points[i + 1]) / 2;
        // The line is so small in the current view that all points are on the same pixel.
        if (halfDist === 0) center = points[0];
        else for(i = 0, dist = 0; i < len - 1; i++){
            p1 = points[i];
            p2 = points[i + 1];
            segDist = p1.distanceTo(p2);
            dist += segDist;
            if (dist > halfDist) {
                ratio = (dist - halfDist) / segDist;
                center = [
                    p2.x - ratio * (p2.x - p1.x),
                    p2.y - ratio * (p2.y - p1.y)
                ];
                break;
            }
        }
        var latlngCenter = crs.unproject(toPoint(center));
        return toLatLng([
            latlngCenter.lat + centroidLatLng.lat,
            latlngCenter.lng + centroidLatLng.lng
        ]);
    }
    var LineUtil = {
        __proto__: null,
        simplify: simplify,
        pointToSegmentDistance: pointToSegmentDistance,
        closestPointOnSegment: closestPointOnSegment,
        clipSegment: clipSegment,
        _getEdgeIntersection: _getEdgeIntersection,
        _getBitCode: _getBitCode,
        _sqClosestPointOnSegment: _sqClosestPointOnSegment,
        isFlat: isFlat,
        _flat: _flat,
        polylineCenter: polylineCenter
    };
    /*
   * @namespace Projection
   * @section
   * Leaflet comes with a set of already defined Projections out of the box:
   *
   * @projection L.Projection.LonLat
   *
   * Equirectangular, or Plate Carree projection  the most simple projection,
   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
   * `EPSG:4326` and `Simple` CRS.
   */ var LonLat = {
        project: function project(latlng) {
            return new Point(latlng.lng, latlng.lat);
        },
        unproject: function unproject(point) {
            return new LatLng(point.y, point.x);
        },
        bounds: new Bounds([
            -180,
            -90
        ], [
            180,
            90
        ])
    };
    /*
   * @namespace Projection
   * @projection L.Projection.Mercator
   *
   * Elliptical Mercator projection  more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.
   */ var Mercator = {
        R: 6378137,
        R_MINOR: 6356752.314245179,
        bounds: new Bounds([
            -20037508.34279,
            -15496570.73972
        ], [
            20037508.34279,
            18764656.23138
        ]),
        project: function project(latlng) {
            var d = Math.PI / 180, r = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);
            var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
            y = -r * Math.log(Math.max(ts, 1E-10));
            return new Point(latlng.lng * d * r, y);
        },
        unproject: function unproject(point) {
            var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);
            for(var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++){
                con = e * Math.sin(phi);
                con = Math.pow((1 - con) / (1 + con), e / 2);
                dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
                phi += dphi;
            }
            return new LatLng(phi * d, point.x * d / r);
        }
    };
    /*
   * @class Projection

   * An object with methods for projecting geographical coordinates of the world onto
   * a flat surface (and back). See [Map projection](https://en.wikipedia.org/wiki/Map_projection).

   * @property bounds: Bounds
   * The bounds (specified in CRS units) where the projection is valid

   * @method project(latlng: LatLng): Point
   * Projects geographical coordinates into a 2D point.
   * Only accepts actual `L.LatLng` instances, not arrays.

   * @method unproject(point: Point): LatLng
   * The inverse of `project`. Projects a 2D point into a geographical location.
   * Only accepts actual `L.Point` instances, not arrays.

   * Note that the projection instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.

   */ var index = {
        __proto__: null,
        LonLat: LonLat,
        Mercator: Mercator,
        SphericalMercator: SphericalMercator
    };
    /*
   * @namespace CRS
   * @crs L.CRS.EPSG3395
   *
   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
   */ var EPSG3395 = extend({}, Earth, {
        code: "EPSG:3395",
        projection: Mercator,
        transformation: function() {
            var scale = 0.5 / (Math.PI * Mercator.R);
            return toTransformation(scale, 0.5, -scale, 0.5);
        }()
    });
    /*
   * @namespace CRS
   * @crs L.CRS.EPSG4326
   *
   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
   *
   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
   * with this CRS, ensure that there are two 256x256 pixel tiles covering the
   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
   */ var EPSG4326 = extend({}, Earth, {
        code: "EPSG:4326",
        projection: LonLat,
        transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
    });
    /*
   * @namespace CRS
   * @crs L.CRS.Simple
   *
   * A simple CRS that maps longitude and latitude into `x` and `y` directly.
   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
   * axis should still be inverted (going from bottom to top). `distance()` returns
   * simple euclidean distance.
   */ var Simple = extend({}, CRS, {
        projection: LonLat,
        transformation: toTransformation(1, 0, -1, 0),
        scale: function scale(zoom) {
            return Math.pow(2, zoom);
        },
        zoom: function zoom(scale) {
            return Math.log(scale) / Math.LN2;
        },
        distance: function distance(latlng1, latlng2) {
            var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
            return Math.sqrt(dx * dx + dy * dy);
        },
        infinite: true
    });
    CRS.Earth = Earth;
    CRS.EPSG3395 = EPSG3395;
    CRS.EPSG3857 = EPSG3857;
    CRS.EPSG900913 = EPSG900913;
    CRS.EPSG4326 = EPSG4326;
    CRS.Simple = Simple;
    /*
   * @class Layer
   * @inherits Evented
   * @aka L.Layer
   * @aka ILayer
   *
   * A set of methods from the Layer base class that all Leaflet layers use.
   * Inherits all methods, options and events from `L.Evented`.
   *
   * @example
   *
   * ```js
   * var layer = L.marker(latlng).addTo(map);
   * layer.addTo(map);
   * layer.remove();
   * ```
   *
   * @event add: Event
   * Fired after the layer is added to a map
   *
   * @event remove: Event
   * Fired after the layer is removed from a map
   */ var Layer = Evented.extend({
        // Classes extending `L.Layer` will inherit the following options:
        options: {
            // @option pane: String = 'overlayPane'
            // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
            pane: "overlayPane",
            // @option attribution: String = null
            // String to be shown in the attribution control, e.g. " OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
            attribution: null,
            bubblingMouseEvents: true
        },
        /* @section
  	 * Classes extending `L.Layer` will inherit the following methods:
  	 *
  	 * @method addTo(map: Map|LayerGroup): this
  	 * Adds the layer to the given map or layer group.
  	 */ addTo: function addTo(map) {
            map.addLayer(this);
            return this;
        },
        // @method remove: this
        // Removes the layer from the map it is currently active on.
        remove: function remove() {
            return this.removeFrom(this._map || this._mapToAdd);
        },
        // @method removeFrom(map: Map): this
        // Removes the layer from the given map
        //
        // @alternative
        // @method removeFrom(group: LayerGroup): this
        // Removes the layer from the given `LayerGroup`
        removeFrom: function removeFrom(obj) {
            if (obj) obj.removeLayer(this);
            return this;
        },
        // @method getPane(name? : String): HTMLElement
        // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
        getPane: function getPane(name) {
            return this._map.getPane(name ? this.options[name] || name : this.options.pane);
        },
        addInteractiveTarget: function addInteractiveTarget(targetEl) {
            this._map._targets[stamp(targetEl)] = this;
            return this;
        },
        removeInteractiveTarget: function removeInteractiveTarget(targetEl) {
            delete this._map._targets[stamp(targetEl)];
            return this;
        },
        // @method getAttribution: String
        // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
        getAttribution: function getAttribution() {
            return this.options.attribution;
        },
        _layerAdd: function _layerAdd(e) {
            var map = e.target;
            // check in case layer gets added and then removed before the map is ready
            if (!map.hasLayer(this)) return;
            this._map = map;
            this._zoomAnimated = map._zoomAnimated;
            if (this.getEvents) {
                var events = this.getEvents();
                map.on(events, this);
                this.once("remove", function() {
                    map.off(events, this);
                }, this);
            }
            this.onAdd(map);
            this.fire("add");
            map.fire("layeradd", {
                layer: this
            });
        }
    });
    /* @section Extension methods
   * @uninheritable
   *
   * Every layer should extend from `L.Layer` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): this
   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
   *
   * @method onRemove(map: Map): this
   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
   *
   * @method getEvents(): Object
   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
   *
   * @method getAttribution(): String
   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
   *
   * @method beforeAdd(map: Map): this
   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
   */ /* @namespace Map
   * @section Layer events
   *
   * @event layeradd: LayerEvent
   * Fired when a new layer is added to the map.
   *
   * @event layerremove: LayerEvent
   * Fired when some layer is removed from the map
   *
   * @section Methods for Layers and Controls
   */ Map.include({
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the map
        addLayer: function addLayer(layer) {
            if (!layer._layerAdd) throw new Error("The provided object is not a Layer.");
            var id = stamp(layer);
            if (this._layers[id]) return this;
            this._layers[id] = layer;
            layer._mapToAdd = this;
            if (layer.beforeAdd) layer.beforeAdd(this);
            this.whenReady(layer._layerAdd, layer);
            return this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the map.
        removeLayer: function removeLayer(layer) {
            var id = stamp(layer);
            if (!this._layers[id]) return this;
            if (this._loaded) layer.onRemove(this);
            delete this._layers[id];
            if (this._loaded) {
                this.fire("layerremove", {
                    layer: layer
                });
                layer.fire("remove");
            }
            layer._map = layer._mapToAdd = null;
            return this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the map
        hasLayer: function hasLayer(layer) {
            return stamp(layer) in this._layers;
        },
        /* @method eachLayer(fn: Function, context?: Object): this
  	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
  	 * ```
  	 * map.eachLayer(function(layer){
  	 *     layer.bindPopup('Hello');
  	 * });
  	 * ```
  	 */ eachLayer: function eachLayer(method, context) {
            for(var i in this._layers)method.call(context, this._layers[i]);
            return this;
        },
        _addLayers: function _addLayers(layers) {
            layers = layers ? isArray(layers) ? layers : [
                layers
            ] : [];
            for(var i = 0, len = layers.length; i < len; i++)this.addLayer(layers[i]);
        },
        _addZoomLimit: function _addZoomLimit(layer) {
            if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
                this._zoomBoundLayers[stamp(layer)] = layer;
                this._updateZoomLevels();
            }
        },
        _removeZoomLimit: function _removeZoomLimit(layer) {
            var id = stamp(layer);
            if (this._zoomBoundLayers[id]) {
                delete this._zoomBoundLayers[id];
                this._updateZoomLevels();
            }
        },
        _updateZoomLevels: function _updateZoomLevels() {
            var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
            for(var i in this._zoomBoundLayers){
                var options = this._zoomBoundLayers[i].options;
                minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
                maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
            }
            this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
            this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;
            // @section Map state change events
            // @event zoomlevelschange: Event
            // Fired when the number of zoomlevels on the map is changed due
            // to adding or removing a layer.
            if (oldZoomSpan !== this._getZoomSpan()) this.fire("zoomlevelschange");
            if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) this.setZoom(this._layersMaxZoom);
            if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) this.setZoom(this._layersMinZoom);
        }
    });
    /*
   * @class LayerGroup
   * @aka L.LayerGroup
   * @inherits Interactive layer
   *
   * Used to group several layers and handle them as one. If you add it to the map,
   * any layers added or removed from the group will be added/removed on the map as
   * well. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.layerGroup([marker1, marker2])
   * 	.addLayer(polyline)
   * 	.addTo(map);
   * ```
   */ var LayerGroup = Layer.extend({
        initialize: function initialize(layers, options) {
            setOptions(this, options);
            this._layers = {};
            var i, len;
            if (layers) for(i = 0, len = layers.length; i < len; i++)this.addLayer(layers[i]);
        },
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the group.
        addLayer: function addLayer(layer) {
            var id = this.getLayerId(layer);
            this._layers[id] = layer;
            if (this._map) this._map.addLayer(layer);
            return this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the group.
        // @alternative
        // @method removeLayer(id: Number): this
        // Removes the layer with the given internal ID from the group.
        removeLayer: function removeLayer(layer) {
            var id = layer in this._layers ? layer : this.getLayerId(layer);
            if (this._map && this._layers[id]) this._map.removeLayer(this._layers[id]);
            delete this._layers[id];
            return this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the group.
        // @alternative
        // @method hasLayer(id: Number): Boolean
        // Returns `true` if the given internal ID is currently added to the group.
        hasLayer: function hasLayer(layer) {
            var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
            return layerId in this._layers;
        },
        // @method clearLayers(): this
        // Removes all the layers from the group.
        clearLayers: function clearLayers() {
            return this.eachLayer(this.removeLayer, this);
        },
        // @method invoke(methodName: String, ): this
        // Calls `methodName` on every layer contained in this group, passing any
        // additional parameters. Has no effect if the layers contained do not
        // implement `methodName`.
        invoke: function invoke(methodName) {
            var args = Array.prototype.slice.call(arguments, 1), i, layer;
            for(i in this._layers){
                layer = this._layers[i];
                if (layer[methodName]) layer[methodName].apply(layer, args);
            }
            return this;
        },
        onAdd: function onAdd(map) {
            this.eachLayer(map.addLayer, map);
        },
        onRemove: function onRemove(map) {
            this.eachLayer(map.removeLayer, map);
        },
        // @method eachLayer(fn: Function, context?: Object): this
        // Iterates over the layers of the group, optionally specifying context of the iterator function.
        // ```js
        // group.eachLayer(function (layer) {
        // 	layer.bindPopup('Hello');
        // });
        // ```
        eachLayer: function eachLayer(method, context) {
            for(var i in this._layers)method.call(context, this._layers[i]);
            return this;
        },
        // @method getLayer(id: Number): Layer
        // Returns the layer with the given internal ID.
        getLayer: function getLayer(id) {
            return this._layers[id];
        },
        // @method getLayers(): Layer[]
        // Returns an array of all the layers added to the group.
        getLayers: function getLayers() {
            var layers = [];
            this.eachLayer(layers.push, layers);
            return layers;
        },
        // @method setZIndex(zIndex: Number): this
        // Calls `setZIndex` on every layer contained in this group, passing the z-index.
        setZIndex: function setZIndex(zIndex) {
            return this.invoke("setZIndex", zIndex);
        },
        // @method getLayerId(layer: Layer): Number
        // Returns the internal ID for a layer
        getLayerId: function getLayerId(layer) {
            return stamp(layer);
        }
    });
    // @factory L.layerGroup(layers?: Layer[], options?: Object)
    // Create a layer group, optionally given an initial set of layers and an `options` object.
    var layerGroup = function layerGroup(layers, options) {
        return new LayerGroup(layers, options);
    };
    /*
   * @class FeatureGroup
   * @aka L.FeatureGroup
   * @inherits LayerGroup
   *
   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
   *  * Events are propagated to the `FeatureGroup`, so if the group has an event
   * handler, it will handle events from any of the layers. This includes mouse events
   * and custom events.
   *  * Has `layeradd` and `layerremove` events
   *
   * @example
   *
   * ```js
   * L.featureGroup([marker1, marker2, polyline])
   * 	.bindPopup('Hello world!')
   * 	.on('click', function() { alert('Clicked on a member of the group!'); })
   * 	.addTo(map);
   * ```
   */ var FeatureGroup = LayerGroup.extend({
        addLayer: function addLayer(layer) {
            if (this.hasLayer(layer)) return this;
            layer.addEventParent(this);
            LayerGroup.prototype.addLayer.call(this, layer);
            // @event layeradd: LayerEvent
            // Fired when a layer is added to this `FeatureGroup`
            return this.fire("layeradd", {
                layer: layer
            });
        },
        removeLayer: function removeLayer(layer) {
            if (!this.hasLayer(layer)) return this;
            if (layer in this._layers) layer = this._layers[layer];
            layer.removeEventParent(this);
            LayerGroup.prototype.removeLayer.call(this, layer);
            // @event layerremove: LayerEvent
            // Fired when a layer is removed from this `FeatureGroup`
            return this.fire("layerremove", {
                layer: layer
            });
        },
        // @method setStyle(style: Path options): this
        // Sets the given path options to each layer of the group that has a `setStyle` method.
        setStyle: function setStyle(style) {
            return this.invoke("setStyle", style);
        },
        // @method bringToFront(): this
        // Brings the layer group to the top of all other layers
        bringToFront: function bringToFront() {
            return this.invoke("bringToFront");
        },
        // @method bringToBack(): this
        // Brings the layer group to the back of all other layers
        bringToBack: function bringToBack() {
            return this.invoke("bringToBack");
        },
        // @method getBounds(): LatLngBounds
        // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
        getBounds: function getBounds() {
            var bounds = new LatLngBounds();
            for(var id in this._layers){
                var layer = this._layers[id];
                bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
            }
            return bounds;
        }
    });
    // @factory L.featureGroup(layers?: Layer[], options?: Object)
    // Create a feature group, optionally given an initial set of layers and an `options` object.
    var featureGroup = function featureGroup(layers, options) {
        return new FeatureGroup(layers, options);
    };
    /*
   * @class Icon
   * @aka L.Icon
   *
   * Represents an icon to provide when creating a marker.
   *
   * @example
   *
   * ```js
   * var myIcon = L.icon({
   *     iconUrl: 'my-icon.png',
   *     iconRetinaUrl: 'my-icon@2x.png',
   *     iconSize: [38, 95],
   *     iconAnchor: [22, 94],
   *     popupAnchor: [-3, -76],
   *     shadowUrl: 'my-icon-shadow.png',
   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
   *     shadowSize: [68, 95],
   *     shadowAnchor: [22, 94]
   * });
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
   *
   */ var Icon = Class.extend({
        /* @section
  	 * @aka Icon options
  	 *
  	 * @option iconUrl: String = null
  	 * **(required)** The URL to the icon image (absolute or relative to your script path).
  	 *
  	 * @option iconRetinaUrl: String = null
  	 * The URL to a retina sized version of the icon image (absolute or relative to your
  	 * script path). Used for Retina screen devices.
  	 *
  	 * @option iconSize: Point = null
  	 * Size of the icon image in pixels.
  	 *
  	 * @option iconAnchor: Point = null
  	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
  	 * will be aligned so that this point is at the marker's geographical location. Centered
  	 * by default if size is specified, also can be set in CSS with negative margins.
  	 *
  	 * @option popupAnchor: Point = [0, 0]
  	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
  	 *
  	 * @option tooltipAnchor: Point = [0, 0]
  	 * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
  	 *
  	 * @option shadowUrl: String = null
  	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
  	 *
  	 * @option shadowRetinaUrl: String = null
  	 *
  	 * @option shadowSize: Point = null
  	 * Size of the shadow image in pixels.
  	 *
  	 * @option shadowAnchor: Point = null
  	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
  	 * as iconAnchor if not specified).
  	 *
  	 * @option className: String = ''
  	 * A custom class name to assign to both icon and shadow images. Empty by default.
  	 */ options: {
            popupAnchor: [
                0,
                0
            ],
            tooltipAnchor: [
                0,
                0
            ],
            // @option crossOrigin: Boolean|String = false
            // Whether the crossOrigin attribute will be added to the tiles.
            // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
            crossOrigin: false
        },
        initialize: function initialize(options) {
            setOptions(this, options);
        },
        // @method createIcon(oldIcon?: HTMLElement): HTMLElement
        // Called internally when the icon has to be shown, returns a `<img>` HTML element
        // styled according to the options.
        createIcon: function createIcon(oldIcon) {
            return this._createIcon("icon", oldIcon);
        },
        // @method createShadow(oldIcon?: HTMLElement): HTMLElement
        // As `createIcon`, but for the shadow beneath it.
        createShadow: function createShadow(oldIcon) {
            return this._createIcon("shadow", oldIcon);
        },
        _createIcon: function _createIcon(name, oldIcon) {
            var src = this._getIconUrl(name);
            if (!src) {
                if (name === "icon") throw new Error("iconUrl not set in Icon options (see the docs).");
                return null;
            }
            var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
            this._setIconStyles(img, name);
            if (this.options.crossOrigin || this.options.crossOrigin === "") img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            return img;
        },
        _setIconStyles: function _setIconStyles(img, name) {
            var options = this.options;
            var sizeOption = options[name + "Size"];
            if (typeof sizeOption === "number") sizeOption = [
                sizeOption,
                sizeOption
            ];
            var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
            img.className = "leaflet-marker-" + name + " " + (options.className || "");
            if (anchor) {
                img.style.marginLeft = -anchor.x + "px";
                img.style.marginTop = -anchor.y + "px";
            }
            if (size) {
                img.style.width = size.x + "px";
                img.style.height = size.y + "px";
            }
        },
        _createImg: function _createImg(src, el) {
            el = el || document.createElement("img");
            el.src = src;
            return el;
        },
        _getIconUrl: function _getIconUrl(name) {
            return Browser.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
        }
    });
    // @factory L.icon(options: Icon options)
    // Creates an icon instance with the given options.
    function icon(options) {
        return new Icon(options);
    }
    /*
   * @miniclass Icon.Default (Icon)
   * @aka L.Icon.Default
   * @section
   *
   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
   * no icon is specified. Points to the blue marker image distributed with Leaflet
   * releases.
   *
   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
   * (which is a set of `Icon options`).
   *
   * If you want to _completely_ replace the default icon, override the
   * `L.Marker.prototype.options.icon` with your own icon instead.
   */ var IconDefault = Icon.extend({
        options: {
            iconUrl: "marker-icon.png",
            iconRetinaUrl: "marker-icon-2x.png",
            shadowUrl: "marker-shadow.png",
            iconSize: [
                25,
                41
            ],
            iconAnchor: [
                12,
                41
            ],
            popupAnchor: [
                1,
                -34
            ],
            tooltipAnchor: [
                16,
                -28
            ],
            shadowSize: [
                41,
                41
            ]
        },
        _getIconUrl: function _getIconUrl(name) {
            if (typeof IconDefault.imagePath !== "string") IconDefault.imagePath = this._detectIconPath();
            // @option imagePath: String
            // `Icon.Default` will try to auto-detect the location of the
            // blue icon images. If you are placing these images in a non-standard
            // way, set this option to point to the right path.
            return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
        },
        _stripUrl: function _stripUrl(path) {
            var strip = function strip(str, re, idx) {
                var match = re.exec(str);
                return match && match[idx];
            };
            path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
            return path && strip(path, /^(.*)marker-icon\.png$/, 1);
        },
        _detectIconPath: function _detectIconPath() {
            var el = create$1("div", "leaflet-default-icon-path", document.body);
            var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage"); // IE8
            document.body.removeChild(el);
            path = this._stripUrl(path);
            if (path) return path;
            var link = document.querySelector('link[href$="leaflet.css"]');
            if (!link) return "";
            return link.href.substring(0, link.href.length - 11 - 1);
        }
    });
    /*
   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
   */ /* @namespace Marker
   * @section Interaction handlers
   *
   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
   *
   * ```js
   * marker.dragging.disable();
   * ```
   *
   * @property dragging: Handler
   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
   */ var MarkerDrag = Handler.extend({
        initialize: function initialize(marker) {
            this._marker = marker;
        },
        addHooks: function addHooks() {
            var _$icon = this._marker._icon;
            if (!this._draggable) this._draggable = new Draggable(_$icon, _$icon, true);
            this._draggable.on({
                dragstart: this._onDragStart,
                predrag: this._onPreDrag,
                drag: this._onDrag,
                dragend: this._onDragEnd
            }, this).enable();
            addClass(_$icon, "leaflet-marker-draggable");
        },
        removeHooks: function removeHooks() {
            this._draggable.off({
                dragstart: this._onDragStart,
                predrag: this._onPreDrag,
                drag: this._onDrag,
                dragend: this._onDragEnd
            }, this).disable();
            if (this._marker._icon) removeClass(this._marker._icon, "leaflet-marker-draggable");
        },
        moved: function moved() {
            return this._draggable && this._draggable._moved;
        },
        _adjustPan: function _adjustPan(e) {
            var _$marker = this._marker, map = _$marker._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(_$marker._icon), bounds = map.getPixelBounds(), origin = map.getPixelOrigin();
            var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));
            if (!panBounds.contains(iconPos)) {
                // Compute incremental movement
                var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);
                map.panBy(movement, {
                    animate: false
                });
                this._draggable._newPos._add(movement);
                this._draggable._startPos._add(movement);
                setPosition(_$marker._icon, this._draggable._newPos);
                this._onDrag(e);
                this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
            }
        },
        _onDragStart: function _onDragStart() {
            // @section Dragging events
            // @event dragstart: Event
            // Fired when the user starts dragging the marker.
            // @event movestart: Event
            // Fired when the marker starts moving (because of dragging).
            this._oldLatLng = this._marker.getLatLng();
            // When using ES6 imports it could not be set when `Popup` was not imported as well
            this._marker.closePopup && this._marker.closePopup();
            this._marker.fire("movestart").fire("dragstart");
        },
        _onPreDrag: function _onPreDrag(e) {
            if (this._marker.options.autoPan) {
                cancelAnimFrame(this._panRequest);
                this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
            }
        },
        _onDrag: function _onDrag(e) {
            var _$marker = this._marker, shadow = _$marker._shadow, iconPos = getPosition(_$marker._icon), latlng = _$marker._map.layerPointToLatLng(iconPos);
            // update shadow position
            if (shadow) setPosition(shadow, iconPos);
            _$marker._latlng = latlng;
            e.latlng = latlng;
            e.oldLatLng = this._oldLatLng;
            // @event drag: Event
            // Fired repeatedly while the user drags the marker.
            _$marker.fire("move", e).fire("drag", e);
        },
        _onDragEnd: function _onDragEnd(e) {
            // @event dragend: DragEndEvent
            // Fired when the user stops dragging the marker.
            cancelAnimFrame(this._panRequest);
            // @event moveend: Event
            // Fired when the marker stops moving (because of dragging).
            delete this._oldLatLng;
            this._marker.fire("moveend").fire("dragend", e);
        }
    });
    /*
   * @class Marker
   * @inherits Interactive layer
   * @aka L.Marker
   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.marker([50.5, 30.5]).addTo(map);
   * ```
   */ var Marker = Layer.extend({
        // @section
        // @aka Marker options
        options: {
            // @option icon: Icon = *
            // Icon instance to use for rendering the marker.
            // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
            // If not specified, a common instance of `L.Icon.Default` is used.
            icon: new IconDefault(),
            // Option inherited from "Interactive layer" abstract class
            interactive: true,
            // @option keyboard: Boolean = true
            // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
            keyboard: true,
            // @option title: String = ''
            // Text for the browser tooltip that appear on marker hover (no tooltip by default).
            // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
            title: "",
            // @option alt: String = 'Marker'
            // Text for the `alt` attribute of the icon image.
            // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
            alt: "Marker",
            // @option zIndexOffset: Number = 0
            // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
            zIndexOffset: 0,
            // @option opacity: Number = 1.0
            // The opacity of the marker.
            opacity: 1,
            // @option riseOnHover: Boolean = false
            // If `true`, the marker will get on top of others when you hover the mouse over it.
            riseOnHover: false,
            // @option riseOffset: Number = 250
            // The z-index offset used for the `riseOnHover` feature.
            riseOffset: 250,
            // @option pane: String = 'markerPane'
            // `Map pane` where the markers icon will be added.
            pane: "markerPane",
            // @option shadowPane: String = 'shadowPane'
            // `Map pane` where the markers shadow will be added.
            shadowPane: "shadowPane",
            // @option bubblingMouseEvents: Boolean = false
            // When `true`, a mouse event on this marker will trigger the same event on the map
            // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
            bubblingMouseEvents: false,
            // @option autoPanOnFocus: Boolean = true
            // When `true`, the map will pan whenever the marker is focused (via
            // e.g. pressing `tab` on the keyboard) to ensure the marker is
            // visible within the map's bounds
            autoPanOnFocus: true,
            // @section Draggable marker options
            // @option draggable: Boolean = false
            // Whether the marker is draggable with mouse/touch or not.
            draggable: false,
            // @option autoPan: Boolean = false
            // Whether to pan the map when dragging this marker near its edge or not.
            autoPan: false,
            // @option autoPanPadding: Point = Point(50, 50)
            // Distance (in pixels to the left/right and to the top/bottom) of the
            // map edge to start panning the map.
            autoPanPadding: [
                50,
                50
            ],
            // @option autoPanSpeed: Number = 10
            // Number of pixels the map should pan by.
            autoPanSpeed: 10
        },
        /* @section
  	 *
  	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
  	 */ initialize: function initialize(latlng, options) {
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
        },
        onAdd: function onAdd(map) {
            this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;
            if (this._zoomAnimated) map.on("zoomanim", this._animateZoom, this);
            this._initIcon();
            this.update();
        },
        onRemove: function onRemove(map) {
            if (this.dragging && this.dragging.enabled()) {
                this.options.draggable = true;
                this.dragging.removeHooks();
            }
            delete this.dragging;
            if (this._zoomAnimated) map.off("zoomanim", this._animateZoom, this);
            this._removeIcon();
            this._removeShadow();
        },
        getEvents: function getEvents() {
            return {
                zoom: this.update,
                viewreset: this.update
            };
        },
        // @method getLatLng: LatLng
        // Returns the current geographical position of the marker.
        getLatLng: function getLatLng() {
            return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Changes the marker position to the given point.
        setLatLng: function setLatLng(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.update();
            // @event move: Event
            // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
            return this.fire("move", {
                oldLatLng: oldLatLng,
                latlng: this._latlng
            });
        },
        // @method setZIndexOffset(offset: Number): this
        // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
        setZIndexOffset: function setZIndexOffset(offset) {
            this.options.zIndexOffset = offset;
            return this.update();
        },
        // @method getIcon: Icon
        // Returns the current icon used by the marker
        getIcon: function getIcon() {
            return this.options.icon;
        },
        // @method setIcon(icon: Icon): this
        // Changes the marker icon.
        setIcon: function setIcon(icon) {
            this.options.icon = icon;
            if (this._map) {
                this._initIcon();
                this.update();
            }
            if (this._popup) this.bindPopup(this._popup, this._popup.options);
            return this;
        },
        getElement: function getElement() {
            return this._icon;
        },
        update: function update() {
            if (this._icon && this._map) {
                var pos = this._map.latLngToLayerPoint(this._latlng).round();
                this._setPos(pos);
            }
            return this;
        },
        _initIcon: function _initIcon() {
            var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            var _$icon = options.icon.createIcon(this._icon), addIcon = false;
            // if we're not reusing the icon, remove the old one and init new one
            if (_$icon !== this._icon) {
                if (this._icon) this._removeIcon();
                addIcon = true;
                if (options.title) _$icon.title = options.title;
                if (_$icon.tagName === "IMG") _$icon.alt = options.alt || "";
            }
            addClass(_$icon, classToAdd);
            if (options.keyboard) {
                _$icon.tabIndex = "0";
                _$icon.setAttribute("role", "button");
            }
            this._icon = _$icon;
            if (options.riseOnHover) this.on({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
            });
            if (this.options.autoPanOnFocus) on(_$icon, "focus", this._panOnFocus, this);
            var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
            if (newShadow !== this._shadow) {
                this._removeShadow();
                addShadow = true;
            }
            if (newShadow) {
                addClass(newShadow, classToAdd);
                newShadow.alt = "";
            }
            this._shadow = newShadow;
            if (options.opacity < 1) this._updateOpacity();
            if (addIcon) this.getPane().appendChild(this._icon);
            this._initInteraction();
            if (newShadow && addShadow) this.getPane(options.shadowPane).appendChild(this._shadow);
        },
        _removeIcon: function _removeIcon() {
            if (this.options.riseOnHover) this.off({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
            });
            if (this.options.autoPanOnFocus) off(this._icon, "focus", this._panOnFocus, this);
            remove(this._icon);
            this.removeInteractiveTarget(this._icon);
            this._icon = null;
        },
        _removeShadow: function _removeShadow() {
            if (this._shadow) remove(this._shadow);
            this._shadow = null;
        },
        _setPos: function _setPos(pos) {
            if (this._icon) setPosition(this._icon, pos);
            if (this._shadow) setPosition(this._shadow, pos);
            this._zIndex = pos.y + this.options.zIndexOffset;
            this._resetZIndex();
        },
        _updateZIndex: function _updateZIndex(offset) {
            if (this._icon) this._icon.style.zIndex = this._zIndex + offset;
        },
        _animateZoom: function _animateZoom(opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
            this._setPos(pos);
        },
        _initInteraction: function _initInteraction() {
            if (!this.options.interactive) return;
            addClass(this._icon, "leaflet-interactive");
            this.addInteractiveTarget(this._icon);
            if (MarkerDrag) {
                var draggable = this.options.draggable;
                if (this.dragging) {
                    draggable = this.dragging.enabled();
                    this.dragging.disable();
                }
                this.dragging = new MarkerDrag(this);
                if (draggable) this.dragging.enable();
            }
        },
        // @method setOpacity(opacity: Number): this
        // Changes the opacity of the marker.
        setOpacity: function setOpacity(opacity) {
            this.options.opacity = opacity;
            if (this._map) this._updateOpacity();
            return this;
        },
        _updateOpacity: function _updateOpacity() {
            var opacity = this.options.opacity;
            if (this._icon) setOpacity(this._icon, opacity);
            if (this._shadow) setOpacity(this._shadow, opacity);
        },
        _bringToFront: function _bringToFront() {
            this._updateZIndex(this.options.riseOffset);
        },
        _resetZIndex: function _resetZIndex() {
            this._updateZIndex(0);
        },
        _panOnFocus: function _panOnFocus() {
            var map = this._map;
            if (!map) return;
            var iconOpts = this.options.icon.options;
            var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
            var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
            map.panInside(this._latlng, {
                paddingTopLeft: anchor,
                paddingBottomRight: size.subtract(anchor)
            });
        },
        _getPopupAnchor: function _getPopupAnchor() {
            return this.options.icon.options.popupAnchor;
        },
        _getTooltipAnchor: function _getTooltipAnchor() {
            return this.options.icon.options.tooltipAnchor;
        }
    });
    // factory L.marker(latlng: LatLng, options? : Marker options)
    // @factory L.marker(latlng: LatLng, options? : Marker options)
    // Instantiates a Marker object given a geographical point and optionally an options object.
    function marker(latlng, options) {
        return new Marker(latlng, options);
    }
    /*
   * @class Path
   * @aka L.Path
   * @inherits Interactive layer
   *
   * An abstract class that contains options and constants shared between vector
   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
   */ var Path = Layer.extend({
        // @section
        // @aka Path options
        options: {
            // @option stroke: Boolean = true
            // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
            stroke: true,
            // @option color: String = '#3388ff'
            // Stroke color
            color: "#3388ff",
            // @option weight: Number = 3
            // Stroke width in pixels
            weight: 3,
            // @option opacity: Number = 1.0
            // Stroke opacity
            opacity: 1,
            // @option lineCap: String= 'round'
            // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
            lineCap: "round",
            // @option lineJoin: String = 'round'
            // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
            lineJoin: "round",
            // @option dashArray: String = null
            // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
            dashArray: null,
            // @option dashOffset: String = null
            // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
            dashOffset: null,
            // @option fill: Boolean = depends
            // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
            fill: false,
            // @option fillColor: String = *
            // Fill color. Defaults to the value of the [`color`](#path-color) option
            fillColor: null,
            // @option fillOpacity: Number = 0.2
            // Fill opacity.
            fillOpacity: 0.2,
            // @option fillRule: String = 'evenodd'
            // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
            fillRule: "evenodd",
            // className: '',
            // Option inherited from "Interactive layer" abstract class
            interactive: true,
            // @option bubblingMouseEvents: Boolean = true
            // When `true`, a mouse event on this path will trigger the same event on the map
            // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
            bubblingMouseEvents: true
        },
        beforeAdd: function beforeAdd(map) {
            // Renderer is set here because we need to call renderer.getEvents
            // before this.getEvents.
            this._renderer = map.getRenderer(this);
        },
        onAdd: function onAdd() {
            this._renderer._initPath(this);
            this._reset();
            this._renderer._addPath(this);
        },
        onRemove: function onRemove() {
            this._renderer._removePath(this);
        },
        // @method redraw(): this
        // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
        redraw: function redraw() {
            if (this._map) this._renderer._updatePath(this);
            return this;
        },
        // @method setStyle(style: Path options): this
        // Changes the appearance of a Path based on the options in the `Path options` object.
        setStyle: function setStyle(style) {
            setOptions(this, style);
            if (this._renderer) {
                this._renderer._updateStyle(this);
                if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, "weight")) this._updateBounds();
            }
            return this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all path layers.
        bringToFront: function bringToFront() {
            if (this._renderer) this._renderer._bringToFront(this);
            return this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all path layers.
        bringToBack: function bringToBack() {
            if (this._renderer) this._renderer._bringToBack(this);
            return this;
        },
        getElement: function getElement() {
            return this._path;
        },
        _reset: function _reset() {
            // defined in child classes
            this._project();
            this._update();
        },
        _clickTolerance: function _clickTolerance() {
            // used when doing hit detection for Canvas layers
            return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
        }
    });
    /*
   * @class CircleMarker
   * @aka L.CircleMarker
   * @inherits Path
   *
   * A circle of a fixed size with radius specified in pixels. Extends `Path`.
   */ var CircleMarker = Path.extend({
        // @section
        // @aka CircleMarker options
        options: {
            fill: true,
            // @option radius: Number = 10
            // Radius of the circle marker, in pixels
            radius: 10
        },
        initialize: function initialize(latlng, options) {
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
            this._radius = this.options.radius;
        },
        // @method setLatLng(latLng: LatLng): this
        // Sets the position of a circle marker to a new location.
        setLatLng: function setLatLng(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.redraw();
            // @event move: Event
            // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
            return this.fire("move", {
                oldLatLng: oldLatLng,
                latlng: this._latlng
            });
        },
        // @method getLatLng(): LatLng
        // Returns the current geographical position of the circle marker
        getLatLng: function getLatLng() {
            return this._latlng;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle marker. Units are in pixels.
        setRadius: function setRadius(radius) {
            this.options.radius = this._radius = radius;
            return this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of the circle
        getRadius: function getRadius() {
            return this._radius;
        },
        setStyle: function setStyle(options) {
            var radius = options && options.radius || this._radius;
            Path.prototype.setStyle.call(this, options);
            this.setRadius(radius);
            return this;
        },
        _project: function _project() {
            this._point = this._map.latLngToLayerPoint(this._latlng);
            this._updateBounds();
        },
        _updateBounds: function _updateBounds() {
            var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [
                r + w,
                r2 + w
            ];
            this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
        },
        _update: function _update() {
            if (this._map) this._updatePath();
        },
        _updatePath: function _updatePath() {
            this._renderer._updateCircle(this);
        },
        _empty: function _empty() {
            return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function _containsPoint(p) {
            return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
        }
    });
    // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
    // Instantiates a circle marker object given a geographical point, and an optional options object.
    function circleMarker(latlng, options) {
        return new CircleMarker(latlng, options);
    }
    /*
   * @class Circle
   * @aka L.Circle
   * @inherits CircleMarker
   *
   * A class for drawing circle overlays on a map. Extends `CircleMarker`.
   *
   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
   *
   * @example
   *
   * ```js
   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
   * ```
   */ var Circle = CircleMarker.extend({
        initialize: function initialize(latlng, options, legacyOptions) {
            if (typeof options === "number") // Backwards compatibility with 0.7.x factory (latlng, radius, options?)
            options = extend({}, legacyOptions, {
                radius: options
            });
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
            if (isNaN(this.options.radius)) throw new Error("Circle radius cannot be NaN");
            // @section
            // @aka Circle options
            // @option radius: Number; Radius of the circle, in meters.
            this._mRadius = this.options.radius;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle. Units are in meters.
        setRadius: function setRadius(radius) {
            this._mRadius = radius;
            return this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of a circle. Units are in meters.
        getRadius: function getRadius() {
            return this._mRadius;
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function getBounds() {
            var half = [
                this._radius,
                this._radiusY || this._radius
            ];
            return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
        },
        setStyle: Path.prototype.setStyle,
        _project: function _project() {
            var lng = this._latlng.lng, lat = this._latlng.lat, map = this._map, crs = map.options.crs;
            if (crs.distance === Earth.distance) {
                var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map.project([
                    lat + latR,
                    lng
                ]), bottom = map.project([
                    lat - latR,
                    lng
                ]), p = top.add(bottom).divideBy(2), lat2 = map.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
                if (isNaN(lngR) || lngR === 0) lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
                this._point = p.subtract(map.getPixelOrigin());
                this._radius = isNaN(lngR) ? 0 : p.x - map.project([
                    lat2,
                    lng - lngR
                ]).x;
                this._radiusY = p.y - top.y;
            } else {
                var latlng2 = crs.unproject(crs.project(this._latlng).subtract([
                    this._mRadius,
                    0
                ]));
                this._point = map.latLngToLayerPoint(this._latlng);
                this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
            }
            this._updateBounds();
        }
    });
    // @factory L.circle(latlng: LatLng, options?: Circle options)
    // Instantiates a circle object given a geographical point, and an options object
    // which contains the circle radius.
    // @alternative
    // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
    // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
    // Do not use in new applications or plugins.
    function circle(latlng, options, legacyOptions) {
        return new Circle(latlng, options, legacyOptions);
    }
    /*
   * @class Polyline
   * @aka L.Polyline
   * @inherits Path
   *
   * A class for drawing polyline overlays on a map. Extends `Path`.
   *
   * @example
   *
   * ```js
   * // create a red polyline from an array of LatLng points
   * var latlngs = [
   * 	[45.51, -122.68],
   * 	[37.77, -122.43],
   * 	[34.04, -118.2]
   * ];
   *
   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polyline
   * map.fitBounds(polyline.getBounds());
   * ```
   *
   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
   *
   * ```js
   * // create a red polyline from an array of arrays of LatLng points
   * var latlngs = [
   * 	[[45.51, -122.68],
   * 	 [37.77, -122.43],
   * 	 [34.04, -118.2]],
   * 	[[40.78, -73.91],
   * 	 [41.83, -87.62],
   * 	 [32.76, -96.72]]
   * ];
   * ```
   */ var Polyline = Path.extend({
        // @section
        // @aka Polyline options
        options: {
            // @option smoothFactor: Number = 1.0
            // How much to simplify the polyline on each zoom level. More means
            // better performance and smoother look, and less means more accurate representation.
            smoothFactor: 1.0,
            // @option noClip: Boolean = false
            // Disable polyline clipping.
            noClip: false
        },
        initialize: function initialize(latlngs, options) {
            setOptions(this, options);
            this._setLatLngs(latlngs);
        },
        // @method getLatLngs(): LatLng[]
        // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
        getLatLngs: function getLatLngs() {
            return this._latlngs;
        },
        // @method setLatLngs(latlngs: LatLng[]): this
        // Replaces all the points in the polyline with the given array of geographical points.
        setLatLngs: function setLatLngs(latlngs) {
            this._setLatLngs(latlngs);
            return this.redraw();
        },
        // @method isEmpty(): Boolean
        // Returns `true` if the Polyline has no LatLngs.
        isEmpty: function isEmpty() {
            return !this._latlngs.length;
        },
        // @method closestLayerPoint(p: Point): Point
        // Returns the point closest to `p` on the Polyline.
        closestLayerPoint: function closestLayerPoint(p) {
            var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2;
            for(var j = 0, jLen = this._parts.length; j < jLen; j++){
                var points = this._parts[j];
                for(var i = 1, len = points.length; i < len; i++){
                    p1 = points[i - 1];
                    p2 = points[i];
                    var sqDist = closest(p, p1, p2, true);
                    if (sqDist < minDistance) {
                        minDistance = sqDist;
                        minPoint = closest(p, p1, p2);
                    }
                }
            }
            if (minPoint) minPoint.distance = Math.sqrt(minDistance);
            return minPoint;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
        getCenter: function getCenter() {
            // throws error when not yet added to map as this center calculation requires projected coordinates
            if (!this._map) throw new Error("Must add layer to map before using getCenter()");
            return polylineCenter(this._defaultShape(), this._map.options.crs);
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function getBounds() {
            return this._bounds;
        },
        // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
        // Adds a given point to the polyline. By default, adds to the first ring of
        // the polyline in case of a multi-polyline, but can be overridden by passing
        // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
        addLatLng: function addLatLng(latlng, latlngs) {
            latlngs = latlngs || this._defaultShape();
            latlng = toLatLng(latlng);
            latlngs.push(latlng);
            this._bounds.extend(latlng);
            return this.redraw();
        },
        _setLatLngs: function _setLatLngs(latlngs) {
            this._bounds = new LatLngBounds();
            this._latlngs = this._convertLatLngs(latlngs);
        },
        _defaultShape: function _defaultShape() {
            return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
        },
        // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
        _convertLatLngs: function _convertLatLngs(latlngs) {
            var result = [], flat = isFlat(latlngs);
            for(var i = 0, len = latlngs.length; i < len; i++)if (flat) {
                result[i] = toLatLng(latlngs[i]);
                this._bounds.extend(result[i]);
            } else result[i] = this._convertLatLngs(latlngs[i]);
            return result;
        },
        _project: function _project() {
            var pxBounds = new Bounds();
            this._rings = [];
            this._projectLatlngs(this._latlngs, this._rings, pxBounds);
            if (this._bounds.isValid() && pxBounds.isValid()) {
                this._rawPxBounds = pxBounds;
                this._updateBounds();
            }
        },
        _updateBounds: function _updateBounds() {
            var w = this._clickTolerance(), p = new Point(w, w);
            if (!this._rawPxBounds) return;
            this._pxBounds = new Bounds([
                this._rawPxBounds.min.subtract(p),
                this._rawPxBounds.max.add(p)
            ]);
        },
        // recursively turns latlngs into a set of rings with projected coordinates
        _projectLatlngs: function _projectLatlngs(latlngs, result, projectedBounds) {
            var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i, ring;
            if (flat) {
                ring = [];
                for(i = 0; i < len; i++){
                    ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
                    projectedBounds.extend(ring[i]);
                }
                result.push(ring);
            } else for(i = 0; i < len; i++)this._projectLatlngs(latlngs[i], result, projectedBounds);
        },
        // clip polyline by renderer bounds so that we have less to render for performance
        _clipPoints: function _clipPoints() {
            var bounds = this._renderer._bounds;
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) return;
            if (this.options.noClip) {
                this._parts = this._rings;
                return;
            }
            var parts = this._parts, i, j, k, len, len2, segment, points;
            for(i = 0, k = 0, len = this._rings.length; i < len; i++){
                points = this._rings[i];
                for(j = 0, len2 = points.length; j < len2 - 1; j++){
                    segment = clipSegment(points[j], points[j + 1], bounds, j, true);
                    if (!segment) continue;
                    parts[k] = parts[k] || [];
                    parts[k].push(segment[0]);
                    // if segment goes out of screen, or it's the last one, it's the end of the line part
                    if (segment[1] !== points[j + 1] || j === len2 - 2) {
                        parts[k].push(segment[1]);
                        k++;
                    }
                }
            }
        },
        // simplify each clipped part of the polyline for performance
        _simplifyPoints: function _simplifyPoints() {
            var parts = this._parts, tolerance = this.options.smoothFactor;
            for(var i = 0, len = parts.length; i < len; i++)parts[i] = simplify(parts[i], tolerance);
        },
        _update: function _update() {
            if (!this._map) return;
            this._clipPoints();
            this._simplifyPoints();
            this._updatePath();
        },
        _updatePath: function _updatePath() {
            this._renderer._updatePoly(this);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function _containsPoint(p, closed) {
            var i, j, k, len, len2, part, w = this._clickTolerance();
            if (!this._pxBounds || !this._pxBounds.contains(p)) return false;
            // hit detection for polylines
            for(i = 0, len = this._parts.length; i < len; i++){
                part = this._parts[i];
                for(j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++){
                    if (!closed && j === 0) continue;
                    if (pointToSegmentDistance(p, part[k], part[j]) <= w) return true;
                }
            }
            return false;
        }
    });
    // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
    // Instantiates a polyline object given an array of geographical points and
    // optionally an options object. You can create a `Polyline` object with
    // multiple separate lines (`MultiPolyline`) by passing an array of arrays
    // of geographic points.
    function polyline(latlngs, options) {
        return new Polyline(latlngs, options);
    }
    // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
    Polyline._flat = _flat;
    /*
   * @class Polygon
   * @aka L.Polygon
   * @inherits Polyline
   *
   * A class for drawing polygon overlays on a map. Extends `Polyline`.
   *
   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one  it's better to filter out such points.
   *
   *
   * @example
   *
   * ```js
   * // create a red polygon from an array of LatLng points
   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
   *
   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polygon
   * map.fitBounds(polygon.getBounds());
   * ```
   *
   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
   *
   * ```js
   * var latlngs = [
   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   * ];
   * ```
   *
   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
   *
   * ```js
   * var latlngs = [
   *   [ // first polygon
   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   *   ],
   *   [ // second polygon
   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
   *   ]
   * ];
   * ```
   */ var Polygon = Polyline.extend({
        options: {
            fill: true
        },
        isEmpty: function isEmpty() {
            return !this._latlngs.length || !this._latlngs[0].length;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
        getCenter: function getCenter() {
            // throws error when not yet added to map as this center calculation requires projected coordinates
            if (!this._map) throw new Error("Must add layer to map before using getCenter()");
            return polygonCenter(this._defaultShape(), this._map.options.crs);
        },
        _convertLatLngs: function _convertLatLngs(latlngs) {
            var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
            // remove last point if it equals first one
            if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) result.pop();
            return result;
        },
        _setLatLngs: function _setLatLngs(latlngs) {
            Polyline.prototype._setLatLngs.call(this, latlngs);
            if (isFlat(this._latlngs)) this._latlngs = [
                this._latlngs
            ];
        },
        _defaultShape: function _defaultShape() {
            return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
        },
        _clipPoints: function _clipPoints() {
            // polygons need a different clipping algorithm so we redefine that
            var bounds = this._renderer._bounds, w = this.options.weight, p = new Point(w, w);
            // increase clip padding by stroke width to avoid stroke on clip edges
            bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) return;
            if (this.options.noClip) {
                this._parts = this._rings;
                return;
            }
            for(var i = 0, len = this._rings.length, clipped; i < len; i++){
                clipped = clipPolygon(this._rings[i], bounds, true);
                if (clipped.length) this._parts.push(clipped);
            }
        },
        _updatePath: function _updatePath() {
            this._renderer._updatePoly(this, true);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function _containsPoint(p) {
            var inside = false, part, p1, p2, i, j, k, len, len2;
            if (!this._pxBounds || !this._pxBounds.contains(p)) return false;
            // ray casting algorithm for detecting if point is in polygon
            for(i = 0, len = this._parts.length; i < len; i++){
                part = this._parts[i];
                for(j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++){
                    p1 = part[j];
                    p2 = part[k];
                    if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) inside = !inside;
                }
            }
            // also check if it's on polygon stroke
            return inside || Polyline.prototype._containsPoint.call(this, p, true);
        }
    });
    // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
    function polygon(latlngs, options) {
        return new Polygon(latlngs, options);
    }
    /*
   * @class GeoJSON
   * @aka L.GeoJSON
   * @inherits FeatureGroup
   *
   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
   * GeoJSON data and display it on the map. Extends `FeatureGroup`.
   *
   * @example
   *
   * ```js
   * L.geoJSON(data, {
   * 	style: function (feature) {
   * 		return {color: feature.properties.color};
   * 	}
   * }).bindPopup(function (layer) {
   * 	return layer.feature.properties.description;
   * }).addTo(map);
   * ```
   */ var GeoJSON = FeatureGroup.extend({
        /* @section
  	 * @aka GeoJSON options
  	 *
  	 * @option pointToLayer: Function = *
  	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
  	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
  	 * The default is to spawn a default `Marker`:
  	 * ```js
  	 * function(geoJsonPoint, latlng) {
  	 * 	return L.marker(latlng);
  	 * }
  	 * ```
  	 *
  	 * @option style: Function = *
  	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
  	 * called internally when data is added.
  	 * The default value is to not override any defaults:
  	 * ```js
  	 * function (geoJsonFeature) {
  	 * 	return {}
  	 * }
  	 * ```
  	 *
  	 * @option onEachFeature: Function = *
  	 * A `Function` that will be called once for each created `Feature`, after it has
  	 * been created and styled. Useful for attaching events and popups to features.
  	 * The default is to do nothing with the newly created layers:
  	 * ```js
  	 * function (feature, layer) {}
  	 * ```
  	 *
  	 * @option filter: Function = *
  	 * A `Function` that will be used to decide whether to include a feature or not.
  	 * The default is to include all features:
  	 * ```js
  	 * function (geoJsonFeature) {
  	 * 	return true;
  	 * }
  	 * ```
  	 * Note: dynamically changing the `filter` option will have effect only on newly
  	 * added data. It will _not_ re-evaluate already included features.
  	 *
  	 * @option coordsToLatLng: Function = *
  	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
  	 * The default is the `coordsToLatLng` static method.
  	 *
  	 * @option markersInheritOptions: Boolean = false
  	 * Whether default Markers for "Point" type Features inherit from group options.
  	 */ initialize: function initialize(geojson, options) {
            setOptions(this, options);
            this._layers = {};
            if (geojson) this.addData(geojson);
        },
        // @method addData( <GeoJSON> data ): this
        // Adds a GeoJSON object to the layer.
        addData: function addData(geojson) {
            var features = isArray(geojson) ? geojson : geojson.features, i, len, feature;
            if (features) {
                for(i = 0, len = features.length; i < len; i++){
                    // only add this if geometry or geometries are set and not null
                    feature = features[i];
                    if (feature.geometries || feature.geometry || feature.features || feature.coordinates) this.addData(feature);
                }
                return this;
            }
            var options = this.options;
            if (options.filter && !options.filter(geojson)) return this;
            var layer = geometryToLayer(geojson, options);
            if (!layer) return this;
            layer.feature = asFeature(geojson);
            layer.defaultOptions = layer.options;
            this.resetStyle(layer);
            if (options.onEachFeature) options.onEachFeature(geojson, layer);
            return this.addLayer(layer);
        },
        // @method resetStyle( <Path> layer? ): this
        // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
        // If `layer` is omitted, the style of all features in the current layer is reset.
        resetStyle: function resetStyle(layer) {
            if (layer === undefined) return this.eachLayer(this.resetStyle, this);
            // reset any custom styles
            layer.options = extend({}, layer.defaultOptions);
            this._setLayerStyle(layer, this.options.style);
            return this;
        },
        // @method setStyle( <Function> style ): this
        // Changes styles of GeoJSON vector layers with the given style function.
        setStyle: function setStyle(style) {
            return this.eachLayer(function(layer) {
                this._setLayerStyle(layer, style);
            }, this);
        },
        _setLayerStyle: function _setLayerStyle(layer, style) {
            if (layer.setStyle) {
                if (typeof style === "function") style = style(layer.feature);
                layer.setStyle(style);
            }
        }
    });
    // @section
    // There are several static functions which can be called without instantiating L.GeoJSON:
    // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
    // Creates a `Layer` from a given GeoJSON feature. Can use a custom
    // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
    // functions if provided as options.
    function geometryToLayer(geojson, options) {
        var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;
        if (!coords && !geometry) return null;
        switch(geometry.type){
            case "Point":
                latlng = _coordsToLatLng(coords);
                return _pointToLayer(pointToLayer, geojson, latlng, options);
            case "MultiPoint":
                for(i = 0, len = coords.length; i < len; i++){
                    latlng = _coordsToLatLng(coords[i]);
                    layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));
                }
                return new FeatureGroup(layers);
            case "LineString":
            case "MultiLineString":
                latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
                return new Polyline(latlngs, options);
            case "Polygon":
            case "MultiPolygon":
                latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
                return new Polygon(latlngs, options);
            case "GeometryCollection":
                for(i = 0, len = geometry.geometries.length; i < len; i++){
                    var geoLayer = geometryToLayer({
                        geometry: geometry.geometries[i],
                        type: "Feature",
                        properties: geojson.properties
                    }, options);
                    if (geoLayer) layers.push(geoLayer);
                }
                return new FeatureGroup(layers);
            case "FeatureCollection":
                for(i = 0, len = geometry.features.length; i < len; i++){
                    var featureLayer = geometryToLayer(geometry.features[i], options);
                    if (featureLayer) layers.push(featureLayer);
                }
                return new FeatureGroup(layers);
            default:
                throw new Error("Invalid GeoJSON object.");
        }
    }
    function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
        return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
    }
    // @function coordsToLatLng(coords: Array): LatLng
    // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
    // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
    function coordsToLatLng(coords) {
        return new LatLng(coords[1], coords[0], coords[2]);
    }
    // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
    // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
    // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
    // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
    function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
        var latlngs = [];
        for(var i = 0, len = coords.length, latlng; i < len; i++){
            latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
            latlngs.push(latlng);
        }
        return latlngs;
    }
    // @function latLngToCoords(latlng: LatLng, precision?: Number|false): Array
    // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.
    function latLngToCoords(latlng, precision) {
        latlng = toLatLng(latlng);
        return latlng.alt !== undefined ? [
            formatNum(latlng.lng, precision),
            formatNum(latlng.lat, precision),
            formatNum(latlng.alt, precision)
        ] : [
            formatNum(latlng.lng, precision),
            formatNum(latlng.lat, precision)
        ];
    }
    // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean, precision?: Number|false): Array
    // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
    // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.
    function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
        var coords = [];
        for(var i = 0, len = latlngs.length; i < len; i++)// Check for flat arrays required to ensure unbalanced arrays are correctly converted in recursion
        coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
        if (!levelsDeep && closed && coords.length > 0) coords.push(coords[0].slice());
        return coords;
    }
    function getFeature(layer, newGeometry) {
        return layer.feature ? extend({}, layer.feature, {
            geometry: newGeometry
        }) : asFeature(newGeometry);
    }
    // @function asFeature(geojson: Object): Object
    // Normalize GeoJSON geometries/features into GeoJSON features.
    function asFeature(geojson) {
        if (geojson.type === "Feature" || geojson.type === "FeatureCollection") return geojson;
        return {
            type: "Feature",
            properties: {},
            geometry: geojson
        };
    }
    var PointToGeoJSON = {
        toGeoJSON: function toGeoJSON(precision) {
            return getFeature(this, {
                type: "Point",
                coordinates: latLngToCoords(this.getLatLng(), precision)
            });
        }
    };
    // @namespace Marker
    // @section Other methods
    // @method toGeoJSON(precision?: Number|false): Object
    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
    Marker.include(PointToGeoJSON);
    // @namespace CircleMarker
    // @method toGeoJSON(precision?: Number|false): Object
    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
    Circle.include(PointToGeoJSON);
    CircleMarker.include(PointToGeoJSON);
    // @namespace Polyline
    // @method toGeoJSON(precision?: Number|false): Object
    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
    Polyline.include({
        toGeoJSON: function toGeoJSON(precision) {
            var multi = !isFlat(this._latlngs);
            var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
            return getFeature(this, {
                type: (multi ? "Multi" : "") + "LineString",
                coordinates: coords
            });
        }
    });
    // @namespace Polygon
    // @method toGeoJSON(precision?: Number|false): Object
    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
    Polygon.include({
        toGeoJSON: function toGeoJSON(precision) {
            var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
            var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
            if (!holes) coords = [
                coords
            ];
            return getFeature(this, {
                type: (multi ? "Multi" : "") + "Polygon",
                coordinates: coords
            });
        }
    });
    // @namespace LayerGroup
    LayerGroup.include({
        toMultiPoint: function toMultiPoint(precision) {
            var coords = [];
            this.eachLayer(function(layer) {
                coords.push(layer.toGeoJSON(precision).geometry.coordinates);
            });
            return getFeature(this, {
                type: "MultiPoint",
                coordinates: coords
            });
        },
        // @method toGeoJSON(precision?: Number|false): Object
        // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
        // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
        toGeoJSON: function toGeoJSON(precision) {
            var type = this.feature && this.feature.geometry && this.feature.geometry.type;
            if (type === "MultiPoint") return this.toMultiPoint(precision);
            var isGeometryCollection = type === "GeometryCollection", jsons = [];
            this.eachLayer(function(layer) {
                if (layer.toGeoJSON) {
                    var json = layer.toGeoJSON(precision);
                    if (isGeometryCollection) jsons.push(json.geometry);
                    else {
                        var feature = asFeature(json);
                        // Squash nested feature collections
                        if (feature.type === "FeatureCollection") jsons.push.apply(jsons, feature.features);
                        else jsons.push(feature);
                    }
                }
            });
            if (isGeometryCollection) return getFeature(this, {
                geometries: jsons,
                type: "GeometryCollection"
            });
            return {
                type: "FeatureCollection",
                features: jsons
            };
        }
    });
    // @namespace GeoJSON
    // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
    // Creates a GeoJSON layer. Optionally accepts an object in
    // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
    // (you can alternatively add it later with `addData` method) and an `options` object.
    function geoJSON(geojson, options) {
        return new GeoJSON(geojson, options);
    }
    // Backward compatibility.
    var geoJson = geoJSON;
    /*
   * @class ImageOverlay
   * @aka L.ImageOverlay
   * @inherits Interactive layer
   *
   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * var imageUrl = 'https://maps.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
   * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
   * L.imageOverlay(imageUrl, imageBounds).addTo(map);
   * ```
   */ var ImageOverlay = Layer.extend({
        // @section
        // @aka ImageOverlay options
        options: {
            // @option opacity: Number = 1.0
            // The opacity of the image overlay.
            opacity: 1,
            // @option alt: String = ''
            // Text for the `alt` attribute of the image (useful for accessibility).
            alt: "",
            // @option interactive: Boolean = false
            // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
            interactive: false,
            // @option crossOrigin: Boolean|String = false
            // Whether the crossOrigin attribute will be added to the image.
            // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
            crossOrigin: false,
            // @option errorOverlayUrl: String = ''
            // URL to the overlay image to show in place of the overlay that failed to load.
            errorOverlayUrl: "",
            // @option zIndex: Number = 1
            // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
            zIndex: 1,
            // @option className: String = ''
            // A custom class name to assign to the image. Empty by default.
            className: ""
        },
        initialize: function initialize(url, bounds, options) {
            this._url = url;
            this._bounds = toLatLngBounds(bounds);
            setOptions(this, options);
        },
        onAdd: function onAdd() {
            if (!this._image) {
                this._initImage();
                if (this.options.opacity < 1) this._updateOpacity();
            }
            if (this.options.interactive) {
                addClass(this._image, "leaflet-interactive");
                this.addInteractiveTarget(this._image);
            }
            this.getPane().appendChild(this._image);
            this._reset();
        },
        onRemove: function onRemove() {
            remove(this._image);
            if (this.options.interactive) this.removeInteractiveTarget(this._image);
        },
        // @method setOpacity(opacity: Number): this
        // Sets the opacity of the overlay.
        setOpacity: function setOpacity(opacity) {
            this.options.opacity = opacity;
            if (this._image) this._updateOpacity();
            return this;
        },
        setStyle: function setStyle(styleOpts) {
            if (styleOpts.opacity) this.setOpacity(styleOpts.opacity);
            return this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all overlays.
        bringToFront: function bringToFront() {
            if (this._map) toFront(this._image);
            return this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all overlays.
        bringToBack: function bringToBack() {
            if (this._map) toBack(this._image);
            return this;
        },
        // @method setUrl(url: String): this
        // Changes the URL of the image.
        setUrl: function setUrl(url) {
            this._url = url;
            if (this._image) this._image.src = url;
            return this;
        },
        // @method setBounds(bounds: LatLngBounds): this
        // Update the bounds that this ImageOverlay covers
        setBounds: function setBounds(bounds) {
            this._bounds = toLatLngBounds(bounds);
            if (this._map) this._reset();
            return this;
        },
        getEvents: function getEvents() {
            var events = {
                zoom: this._reset,
                viewreset: this._reset
            };
            if (this._zoomAnimated) events.zoomanim = this._animateZoom;
            return events;
        },
        // @method setZIndex(value: Number): this
        // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
        setZIndex: function setZIndex(value) {
            this.options.zIndex = value;
            this._updateZIndex();
            return this;
        },
        // @method getBounds(): LatLngBounds
        // Get the bounds that this ImageOverlay covers
        getBounds: function getBounds() {
            return this._bounds;
        },
        // @method getElement(): HTMLElement
        // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
        // used by this overlay.
        getElement: function getElement() {
            return this._image;
        },
        _initImage: function _initImage() {
            var wasElementSupplied = this._url.tagName === "IMG";
            var img = this._image = wasElementSupplied ? this._url : create$1("img");
            addClass(img, "leaflet-image-layer");
            if (this._zoomAnimated) addClass(img, "leaflet-zoom-animated");
            if (this.options.className) addClass(img, this.options.className);
            img.onselectstart = falseFn;
            img.onmousemove = falseFn;
            // @event load: Event
            // Fired when the ImageOverlay layer has loaded its image
            img.onload = bind(this.fire, this, "load");
            img.onerror = bind(this._overlayOnError, this, "error");
            if (this.options.crossOrigin || this.options.crossOrigin === "") img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            if (this.options.zIndex) this._updateZIndex();
            if (wasElementSupplied) {
                this._url = img.src;
                return;
            }
            img.src = this._url;
            img.alt = this.options.alt;
        },
        _animateZoom: function _animateZoom(e) {
            var scale = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
            setTransform(this._image, offset, scale);
        },
        _reset: function _reset() {
            var image = this._image, bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())), size = bounds.getSize();
            setPosition(image, bounds.min);
            image.style.width = size.x + "px";
            image.style.height = size.y + "px";
        },
        _updateOpacity: function _updateOpacity() {
            setOpacity(this._image, this.options.opacity);
        },
        _updateZIndex: function _updateZIndex() {
            if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) this._image.style.zIndex = this.options.zIndex;
        },
        _overlayOnError: function _overlayOnError() {
            // @event error: Event
            // Fired when the ImageOverlay layer fails to load its image
            this.fire("error");
            var errorUrl = this.options.errorOverlayUrl;
            if (errorUrl && this._url !== errorUrl) {
                this._url = errorUrl;
                this._image.src = errorUrl;
            }
        },
        // @method getCenter(): LatLng
        // Returns the center of the ImageOverlay.
        getCenter: function getCenter() {
            return this._bounds.getCenter();
        }
    });
    // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
    // Instantiates an image overlay object given the URL of the image and the
    // geographical bounds it is tied to.
    var imageOverlay = function imageOverlay(url, bounds, options) {
        return new ImageOverlay(url, bounds, options);
    };
    /*
   * @class VideoOverlay
   * @aka L.VideoOverlay
   * @inherits ImageOverlay
   *
   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
   *
   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
   * HTML5 element.
   *
   * @example
   *
   * ```js
   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
   * 	videoBounds = [[ 32, -130], [ 13, -100]];
   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
   * ```
   */ var VideoOverlay = ImageOverlay.extend({
        // @section
        // @aka VideoOverlay options
        options: {
            // @option autoplay: Boolean = true
            // Whether the video starts playing automatically when loaded.
            // On some browsers autoplay will only work with `muted: true`
            autoplay: true,
            // @option loop: Boolean = true
            // Whether the video will loop back to the beginning when played.
            loop: true,
            // @option keepAspectRatio: Boolean = true
            // Whether the video will save aspect ratio after the projection.
            // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
            keepAspectRatio: true,
            // @option muted: Boolean = false
            // Whether the video starts on mute when loaded.
            muted: false,
            // @option playsInline: Boolean = true
            // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
            playsInline: true
        },
        _initImage: function _initImage() {
            var wasElementSupplied = this._url.tagName === "VIDEO";
            var vid = this._image = wasElementSupplied ? this._url : create$1("video");
            addClass(vid, "leaflet-image-layer");
            if (this._zoomAnimated) addClass(vid, "leaflet-zoom-animated");
            if (this.options.className) addClass(vid, this.options.className);
            vid.onselectstart = falseFn;
            vid.onmousemove = falseFn;
            // @event load: Event
            // Fired when the video has finished loading the first frame
            vid.onloadeddata = bind(this.fire, this, "load");
            if (wasElementSupplied) {
                var sourceElements = vid.getElementsByTagName("source");
                var sources = [];
                for(var j = 0; j < sourceElements.length; j++)sources.push(sourceElements[j].src);
                this._url = sourceElements.length > 0 ? sources : [
                    vid.src
                ];
                return;
            }
            if (!isArray(this._url)) this._url = [
                this._url
            ];
            if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) vid.style["objectFit"] = "fill";
            vid.autoplay = !!this.options.autoplay;
            vid.loop = !!this.options.loop;
            vid.muted = !!this.options.muted;
            vid.playsInline = !!this.options.playsInline;
            for(var i = 0; i < this._url.length; i++){
                var source = create$1("source");
                source.src = this._url[i];
                vid.appendChild(source);
            }
        }
    });
    // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
    // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
    // geographical bounds it is tied to.
    function videoOverlay(video, bounds, options) {
        return new VideoOverlay(video, bounds, options);
    }
    /*
   * @class SVGOverlay
   * @aka L.SVGOverlay
   * @inherits ImageOverlay
   *
   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.
   *
   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.
   *
   * @example
   *
   * ```js
   * var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
   * svgElement.setAttribute('xmlns', "http://www.w3.org/2000/svg");
   * svgElement.setAttribute('viewBox', "0 0 200 200");
   * svgElement.innerHTML = '<rect width="200" height="200"/><rect x="75" y="23" width="50" height="50" style="fill:red"/><rect x="75" y="123" width="50" height="50" style="fill:#0013ff"/>';
   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];
   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);
   * ```
   */ var SVGOverlay = ImageOverlay.extend({
        _initImage: function _initImage() {
            var el = this._image = this._url;
            addClass(el, "leaflet-image-layer");
            if (this._zoomAnimated) addClass(el, "leaflet-zoom-animated");
            if (this.options.className) addClass(el, this.options.className);
            el.onselectstart = falseFn;
            el.onmousemove = falseFn;
        }
    });
    // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)
    // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.
    // A viewBox attribute is required on the SVG element to zoom in and out properly.
    function svgOverlay(el, bounds, options) {
        return new SVGOverlay(el, bounds, options);
    }
    /*
   * @class DivOverlay
   * @inherits Interactive layer
   * @aka L.DivOverlay
   * Base model for L.Popup and L.Tooltip. Inherit from it for custom overlays like plugins.
   */ // @namespace DivOverlay
    var DivOverlay = Layer.extend({
        // @section
        // @aka DivOverlay options
        options: {
            // @option interactive: Boolean = false
            // If true, the popup/tooltip will listen to the mouse events.
            interactive: false,
            // @option offset: Point = Point(0, 0)
            // The offset of the overlay position.
            offset: [
                0,
                0
            ],
            // @option className: String = ''
            // A custom CSS class name to assign to the overlay.
            className: "",
            // @option pane: String = undefined
            // `Map pane` where the overlay will be added.
            pane: undefined,
            // @option content: String|HTMLElement|Function = ''
            // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
            // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
            content: ""
        },
        initialize: function initialize(options, source) {
            if (options && (options instanceof LatLng || isArray(options))) {
                this._latlng = toLatLng(options);
                setOptions(this, source);
            } else {
                setOptions(this, options);
                this._source = source;
            }
            if (this.options.content) this._content = this.options.content;
        },
        // @method openOn(map: Map): this
        // Adds the overlay to the map.
        // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
        openOn: function openOn(map) {
            map = arguments.length ? map : this._source._map; // experimental, not the part of public api
            if (!map.hasLayer(this)) map.addLayer(this);
            return this;
        },
        // @method close(): this
        // Closes the overlay.
        // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
        // and `layer.closePopup()`/`.closeTooltip()`.
        close: function close() {
            if (this._map) this._map.removeLayer(this);
            return this;
        },
        // @method toggle(layer?: Layer): this
        // Opens or closes the overlay bound to layer depending on its current state.
        // Argument may be omitted only for overlay bound to layer.
        // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
        toggle: function toggle(layer) {
            if (this._map) this.close();
            else {
                if (arguments.length) this._source = layer;
                else layer = this._source;
                this._prepareOpen();
                // open the overlay on the map
                this.openOn(layer._map);
            }
            return this;
        },
        onAdd: function onAdd(map) {
            this._zoomAnimated = map._zoomAnimated;
            if (!this._container) this._initLayout();
            if (map._fadeAnimated) setOpacity(this._container, 0);
            clearTimeout(this._removeTimeout);
            this.getPane().appendChild(this._container);
            this.update();
            if (map._fadeAnimated) setOpacity(this._container, 1);
            this.bringToFront();
            if (this.options.interactive) {
                addClass(this._container, "leaflet-interactive");
                this.addInteractiveTarget(this._container);
            }
        },
        onRemove: function onRemove(map) {
            if (map._fadeAnimated) {
                setOpacity(this._container, 0);
                this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
            } else remove(this._container);
            if (this.options.interactive) {
                removeClass(this._container, "leaflet-interactive");
                this.removeInteractiveTarget(this._container);
            }
        },
        // @namespace DivOverlay
        // @method getLatLng: LatLng
        // Returns the geographical point of the overlay.
        getLatLng: function getLatLng() {
            return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Sets the geographical point where the overlay will open.
        setLatLng: function setLatLng(latlng) {
            this._latlng = toLatLng(latlng);
            if (this._map) {
                this._updatePosition();
                this._adjustPan();
            }
            return this;
        },
        // @method getContent: String|HTMLElement
        // Returns the content of the overlay.
        getContent: function getContent() {
            return this._content;
        },
        // @method setContent(htmlContent: String|HTMLElement|Function): this
        // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
        // The function should return a `String` or `HTMLElement` to be used in the overlay.
        setContent: function setContent(content) {
            this._content = content;
            this.update();
            return this;
        },
        // @method getElement: String|HTMLElement
        // Returns the HTML container of the overlay.
        getElement: function getElement() {
            return this._container;
        },
        // @method update: null
        // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
        update: function update() {
            if (!this._map) return;
            this._container.style.visibility = "hidden";
            this._updateContent();
            this._updateLayout();
            this._updatePosition();
            this._container.style.visibility = "";
            this._adjustPan();
        },
        getEvents: function getEvents() {
            var events = {
                zoom: this._updatePosition,
                viewreset: this._updatePosition
            };
            if (this._zoomAnimated) events.zoomanim = this._animateZoom;
            return events;
        },
        // @method isOpen: Boolean
        // Returns `true` when the overlay is visible on the map.
        isOpen: function isOpen() {
            return !!this._map && this._map.hasLayer(this);
        },
        // @method bringToFront: this
        // Brings this overlay in front of other overlays (in the same map pane).
        bringToFront: function bringToFront() {
            if (this._map) toFront(this._container);
            return this;
        },
        // @method bringToBack: this
        // Brings this overlay to the back of other overlays (in the same map pane).
        bringToBack: function bringToBack() {
            if (this._map) toBack(this._container);
            return this;
        },
        // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
        _prepareOpen: function _prepareOpen(latlng) {
            var source = this._source;
            if (!source._map) return false;
            if (source instanceof FeatureGroup) {
                source = null;
                var layers = this._source._layers;
                for(var id in layers)if (layers[id]._map) {
                    source = layers[id];
                    break;
                }
                if (!source) return false;
                 // Unable to get source layer.
                // set overlay source to this layer
                this._source = source;
            }
            if (!latlng) {
                if (source.getCenter) latlng = source.getCenter();
                else if (source.getLatLng) latlng = source.getLatLng();
                else if (source.getBounds) latlng = source.getBounds().getCenter();
                else throw new Error("Unable to get source layer LatLng.");
            }
            this.setLatLng(latlng);
            if (this._map) // update the overlay (content, layout, etc...)
            this.update();
            return true;
        },
        _updateContent: function _updateContent() {
            if (!this._content) return;
            var node = this._contentNode;
            var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
            if (typeof content === "string") node.innerHTML = content;
            else {
                while(node.hasChildNodes())node.removeChild(node.firstChild);
                node.appendChild(content);
            }
            // @namespace DivOverlay
            // @section DivOverlay events
            // @event contentupdate: Event
            // Fired when the content of the overlay is updated
            this.fire("contentupdate");
        },
        _updatePosition: function _updatePosition() {
            if (!this._map) return;
            var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (this._zoomAnimated) setPosition(this._container, pos.add(anchor));
            else offset = offset.add(pos).add(anchor);
            var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
            // bottom position the overlay in case the height of the overlay changes (images loading etc)
            this._container.style.bottom = bottom + "px";
            this._container.style.left = left + "px";
        },
        _getAnchor: function _getAnchor() {
            return [
                0,
                0
            ];
        }
    });
    Map.include({
        _initOverlay: function _initOverlay(OverlayClass, content, latlng, options) {
            var overlay = content;
            if (!(overlay instanceof OverlayClass)) overlay = new OverlayClass(options).setContent(content);
            if (latlng) overlay.setLatLng(latlng);
            return overlay;
        }
    });
    Layer.include({
        _initOverlay: function _initOverlay(OverlayClass, old, content, options) {
            var overlay = content;
            if (overlay instanceof OverlayClass) {
                setOptions(overlay, options);
                overlay._source = this;
            } else {
                overlay = old && !options ? old : new OverlayClass(options, this);
                overlay.setContent(content);
            }
            return overlay;
        }
    });
    /*
   * @class Popup
   * @inherits DivOverlay
   * @aka L.Popup
   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
   * open popups while making sure that only one popup is open at one time
   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
   *
   * @example
   *
   * If you want to just bind a popup to marker click and then open it, it's really easy:
   *
   * ```js
   * marker.bindPopup(popupContent).openPopup();
   * ```
   * Path overlays like polylines also have a `bindPopup` method.
   *
   * A popup can be also standalone:
   *
   * ```js
   * var popup = L.popup()
   * 	.setLatLng(latlng)
   * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
   * 	.openOn(map);
   * ```
   * or
   * ```js
   * var popup = L.popup(latlng, {content: '<p>Hello world!<br />This is a nice popup.</p>')
   * 	.openOn(map);
   * ```
   */ // @namespace Popup
    var Popup = DivOverlay.extend({
        // @section
        // @aka Popup options
        options: {
            // @option pane: String = 'popupPane'
            // `Map pane` where the popup will be added.
            pane: "popupPane",
            // @option offset: Point = Point(0, 7)
            // The offset of the popup position.
            offset: [
                0,
                7
            ],
            // @option maxWidth: Number = 300
            // Max width of the popup, in pixels.
            maxWidth: 300,
            // @option minWidth: Number = 50
            // Min width of the popup, in pixels.
            minWidth: 50,
            // @option maxHeight: Number = null
            // If set, creates a scrollable container of the given height
            // inside a popup if its content exceeds it.
            // The scrollable container can be styled using the
            // `leaflet-popup-scrolled` CSS class selector.
            maxHeight: null,
            // @option autoPan: Boolean = true
            // Set it to `false` if you don't want the map to do panning animation
            // to fit the opened popup.
            autoPan: true,
            // @option autoPanPaddingTopLeft: Point = null
            // The margin between the popup and the top left corner of the map
            // view after autopanning was performed.
            autoPanPaddingTopLeft: null,
            // @option autoPanPaddingBottomRight: Point = null
            // The margin between the popup and the bottom right corner of the map
            // view after autopanning was performed.
            autoPanPaddingBottomRight: null,
            // @option autoPanPadding: Point = Point(5, 5)
            // Equivalent of setting both top left and bottom right autopan padding to the same value.
            autoPanPadding: [
                5,
                5
            ],
            // @option keepInView: Boolean = false
            // Set it to `true` if you want to prevent users from panning the popup
            // off of the screen while it is open.
            keepInView: false,
            // @option closeButton: Boolean = true
            // Controls the presence of a close button in the popup.
            closeButton: true,
            // @option autoClose: Boolean = true
            // Set it to `false` if you want to override the default behavior of
            // the popup closing when another popup is opened.
            autoClose: true,
            // @option closeOnEscapeKey: Boolean = true
            // Set it to `false` if you want to override the default behavior of
            // the ESC key for closing of the popup.
            closeOnEscapeKey: true,
            // @option closeOnClick: Boolean = *
            // Set it if you want to override the default behavior of the popup closing when user clicks
            // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
            // @option className: String = ''
            // A custom CSS class name to assign to the popup.
            className: ""
        },
        // @namespace Popup
        // @method openOn(map: Map): this
        // Alternative to `map.openPopup(popup)`.
        // Adds the popup to the map and closes the previous one.
        openOn: function openOn(map) {
            map = arguments.length ? map : this._source._map; // experimental, not the part of public api
            if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) map.removeLayer(map._popup);
            map._popup = this;
            return DivOverlay.prototype.openOn.call(this, map);
        },
        onAdd: function onAdd(map) {
            DivOverlay.prototype.onAdd.call(this, map);
            // @namespace Map
            // @section Popup events
            // @event popupopen: PopupEvent
            // Fired when a popup is opened in the map
            map.fire("popupopen", {
                popup: this
            });
            if (this._source) {
                // @namespace Layer
                // @section Popup events
                // @event popupopen: PopupEvent
                // Fired when a popup bound to this layer is opened
                this._source.fire("popupopen", {
                    popup: this
                }, true);
                // For non-path layers, we toggle the popup when clicking
                // again the layer, so prevent the map to reopen it.
                if (!(this._source instanceof Path)) this._source.on("preclick", stopPropagation);
            }
        },
        onRemove: function onRemove(map) {
            DivOverlay.prototype.onRemove.call(this, map);
            // @namespace Map
            // @section Popup events
            // @event popupclose: PopupEvent
            // Fired when a popup in the map is closed
            map.fire("popupclose", {
                popup: this
            });
            if (this._source) {
                // @namespace Layer
                // @section Popup events
                // @event popupclose: PopupEvent
                // Fired when a popup bound to this layer is closed
                this._source.fire("popupclose", {
                    popup: this
                }, true);
                if (!(this._source instanceof Path)) this._source.off("preclick", stopPropagation);
            }
        },
        getEvents: function getEvents() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) events.preclick = this.close;
            if (this.options.keepInView) events.moveend = this._adjustPan;
            return events;
        },
        _initLayout: function _initLayout() {
            var prefix = "leaflet-popup", container = this._container = create$1("div", prefix + " " + (this.options.className || "") + " leaflet-zoom-animated");
            var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
            this._contentNode = create$1("div", prefix + "-content", wrapper);
            disableClickPropagation(container);
            disableScrollPropagation(this._contentNode);
            on(container, "contextmenu", stopPropagation);
            this._tipContainer = create$1("div", prefix + "-tip-container", container);
            this._tip = create$1("div", prefix + "-tip", this._tipContainer);
            if (this.options.closeButton) {
                var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
                closeButton.setAttribute("role", "button"); // overrides the implicit role=link of <a> elements #7399
                closeButton.setAttribute("aria-label", "Close popup");
                closeButton.href = "#close";
                closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
                on(closeButton, "click", function(ev) {
                    preventDefault(ev);
                    this.close();
                }, this);
            }
        },
        _updateLayout: function _updateLayout() {
            var container = this._contentNode, style = container.style;
            style.width = "";
            style.whiteSpace = "nowrap";
            var width = container.offsetWidth;
            width = Math.min(width, this.options.maxWidth);
            width = Math.max(width, this.options.minWidth);
            style.width = width + 1 + "px";
            style.whiteSpace = "";
            style.height = "";
            var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
            if (maxHeight && height > maxHeight) {
                style.height = maxHeight + "px";
                addClass(container, scrolledClass);
            } else removeClass(container, scrolledClass);
            this._containerWidth = this._container.offsetWidth;
        },
        _animateZoom: function _animateZoom(e) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
            setPosition(this._container, pos.add(anchor));
        },
        _adjustPan: function _adjustPan() {
            if (!this.options.autoPan) return;
            if (this._map._panAnim) this._map._panAnim.stop();
            // We can endlessly recurse if keepInView is set and the view resets.
            // Let's guard against that by exiting early if we're responding to our own autopan.
            if (this._autopanning) {
                this._autopanning = false;
                return;
            }
            var map = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
            layerPos._add(getPosition(this._container));
            var containerPos = map.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map.getSize(), dx = 0, dy = 0;
            if (containerPos.x + containerWidth + paddingBR.x > size.x) dx = containerPos.x + containerWidth - size.x + paddingBR.x;
            if (containerPos.x - dx - paddingTL.x < 0) dx = containerPos.x - paddingTL.x;
            if (containerPos.y + containerHeight + paddingBR.y > size.y) dy = containerPos.y + containerHeight - size.y + paddingBR.y;
            if (containerPos.y - dy - paddingTL.y < 0) dy = containerPos.y - paddingTL.y;
            // @namespace Map
            // @section Popup events
            // @event autopanstart: Event
            // Fired when the map starts autopanning when opening a popup.
            if (dx || dy) {
                // Track that we're autopanning, as this function will be re-ran on moveend
                if (this.options.keepInView) this._autopanning = true;
                map.fire("autopanstart").panBy([
                    dx,
                    dy
                ]);
            }
        },
        _getAnchor: function _getAnchor() {
            // Where should we anchor the popup on the source layer?
            return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [
                0,
                0
            ]);
        }
    });
    // @namespace Popup
    // @factory L.popup(options?: Popup options, source?: Layer)
    // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
    // @alternative
    // @factory L.popup(latlng: LatLng, options?: Popup options)
    // Instantiates a `Popup` object given `latlng` where the popup will open and an optional `options` object that describes its appearance and location.
    var popup = function popup(options, source) {
        return new Popup(options, source);
    };
    /* @namespace Map
   * @section Interaction Options
   * @option closePopupOnClick: Boolean = true
   * Set it to `false` if you don't want popups to close when user clicks the map.
   */ Map.mergeOptions({
        closePopupOnClick: true
    });
    // @namespace Map
    // @section Methods for Layers and Controls
    Map.include({
        // @method openPopup(popup: Popup): this
        // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
        // @alternative
        // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
        // Creates a popup with the specified content and options and opens it in the given point on a map.
        openPopup: function openPopup(popup, latlng, options) {
            this._initOverlay(Popup, popup, latlng, options).openOn(this);
            return this;
        },
        // @method closePopup(popup?: Popup): this
        // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
        closePopup: function closePopup(popup) {
            popup = arguments.length ? popup : this._popup;
            if (popup) popup.close();
            return this;
        }
    });
    /*
   * @namespace Layer
   * @section Popup methods example
   *
   * All layers share a set of methods convenient for binding popups to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
   * layer.openPopup();
   * layer.closePopup();
   * ```
   *
   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
   */ // @section Popup methods
    Layer.include({
        // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
        // Binds a popup to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindPopup: function bindPopup(content, options) {
            this._popup = this._initOverlay(Popup, this._popup, content, options);
            if (!this._popupHandlersAdded) {
                this.on({
                    click: this._openPopup,
                    keypress: this._onKeyPress,
                    remove: this.closePopup,
                    move: this._movePopup
                });
                this._popupHandlersAdded = true;
            }
            return this;
        },
        // @method unbindPopup(): this
        // Removes the popup previously bound with `bindPopup`.
        unbindPopup: function unbindPopup() {
            if (this._popup) {
                this.off({
                    click: this._openPopup,
                    keypress: this._onKeyPress,
                    remove: this.closePopup,
                    move: this._movePopup
                });
                this._popupHandlersAdded = false;
                this._popup = null;
            }
            return this;
        },
        // @method openPopup(latlng?: LatLng): this
        // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
        openPopup: function openPopup(latlng) {
            if (this._popup) {
                if (!(this instanceof FeatureGroup)) this._popup._source = this;
                if (this._popup._prepareOpen(latlng || this._latlng)) // open the popup on the map
                this._popup.openOn(this._map);
            }
            return this;
        },
        // @method closePopup(): this
        // Closes the popup bound to this layer if it is open.
        closePopup: function closePopup() {
            if (this._popup) this._popup.close();
            return this;
        },
        // @method togglePopup(): this
        // Opens or closes the popup bound to this layer depending on its current state.
        togglePopup: function togglePopup() {
            if (this._popup) this._popup.toggle(this);
            return this;
        },
        // @method isPopupOpen(): boolean
        // Returns `true` if the popup bound to this layer is currently open.
        isPopupOpen: function isPopupOpen() {
            return this._popup ? this._popup.isOpen() : false;
        },
        // @method setPopupContent(content: String|HTMLElement|Popup): this
        // Sets the content of the popup bound to this layer.
        setPopupContent: function setPopupContent(content) {
            if (this._popup) this._popup.setContent(content);
            return this;
        },
        // @method getPopup(): Popup
        // Returns the popup bound to this layer.
        getPopup: function getPopup() {
            return this._popup;
        },
        _openPopup: function _openPopup(e) {
            if (!this._popup || !this._map) return;
            // prevent map click
            stop(e);
            var target = e.layer || e.target;
            if (this._popup._source === target && !(target instanceof Path)) {
                // treat it like a marker and figure out
                // if we should toggle it open/closed
                if (this._map.hasLayer(this._popup)) this.closePopup();
                else this.openPopup(e.latlng);
                return;
            }
            this._popup._source = target;
            this.openPopup(e.latlng);
        },
        _movePopup: function _movePopup(e) {
            this._popup.setLatLng(e.latlng);
        },
        _onKeyPress: function _onKeyPress(e) {
            if (e.originalEvent.keyCode === 13) this._openPopup(e);
        }
    });
    /*
   * @class Tooltip
   * @inherits DivOverlay
   * @aka L.Tooltip
   * Used to display small texts on top of map layers.
   *
   * @example
   * If you want to just bind a tooltip to marker:
   *
   * ```js
   * marker.bindTooltip("my tooltip text").openTooltip();
   * ```
   * Path overlays like polylines also have a `bindTooltip` method.
   *
   * A tooltip can be also standalone:
   *
   * ```js
   * var tooltip = L.tooltip()
   * 	.setLatLng(latlng)
   * 	.setContent('Hello world!<br />This is a nice tooltip.')
   * 	.addTo(map);
   * ```
   * or
   * ```js
   * var tooltip = L.tooltip(latlng, {content: 'Hello world!<br />This is a nice tooltip.'})
   * 	.addTo(map);
   * ```
   *
   *
   * Note about tooltip offset. Leaflet takes two options in consideration
   * for computing tooltip offsetting:
   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
   *   move it to the bottom. Negatives will move to the left and top.
   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
   *   should adapt this value if you use a custom icon.
   */ // @namespace Tooltip
    var Tooltip = DivOverlay.extend({
        // @section
        // @aka Tooltip options
        options: {
            // @option pane: String = 'tooltipPane'
            // `Map pane` where the tooltip will be added.
            pane: "tooltipPane",
            // @option offset: Point = Point(0, 0)
            // Optional offset of the tooltip position.
            offset: [
                0,
                0
            ],
            // @option direction: String = 'auto'
            // Direction where to open the tooltip. Possible values are: `right`, `left`,
            // `top`, `bottom`, `center`, `auto`.
            // `auto` will dynamically switch between `right` and `left` according to the tooltip
            // position on the map.
            direction: "auto",
            // @option permanent: Boolean = false
            // Whether to open the tooltip permanently or only on mouseover.
            permanent: false,
            // @option sticky: Boolean = false
            // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
            sticky: false,
            // @option opacity: Number = 0.9
            // Tooltip container opacity.
            opacity: 0.9
        },
        onAdd: function onAdd(map) {
            DivOverlay.prototype.onAdd.call(this, map);
            this.setOpacity(this.options.opacity);
            // @namespace Map
            // @section Tooltip events
            // @event tooltipopen: TooltipEvent
            // Fired when a tooltip is opened in the map.
            map.fire("tooltipopen", {
                tooltip: this
            });
            if (this._source) {
                this.addEventParent(this._source);
                // @namespace Layer
                // @section Tooltip events
                // @event tooltipopen: TooltipEvent
                // Fired when a tooltip bound to this layer is opened.
                this._source.fire("tooltipopen", {
                    tooltip: this
                }, true);
            }
        },
        onRemove: function onRemove(map) {
            DivOverlay.prototype.onRemove.call(this, map);
            // @namespace Map
            // @section Tooltip events
            // @event tooltipclose: TooltipEvent
            // Fired when a tooltip in the map is closed.
            map.fire("tooltipclose", {
                tooltip: this
            });
            if (this._source) {
                this.removeEventParent(this._source);
                // @namespace Layer
                // @section Tooltip events
                // @event tooltipclose: TooltipEvent
                // Fired when a tooltip bound to this layer is closed.
                this._source.fire("tooltipclose", {
                    tooltip: this
                }, true);
            }
        },
        getEvents: function getEvents() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (!this.options.permanent) events.preclick = this.close;
            return events;
        },
        _initLayout: function _initLayout() {
            var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            this._contentNode = this._container = create$1("div", className);
            this._container.setAttribute("role", "tooltip");
            this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
        },
        _updateLayout: function _updateLayout() {},
        _adjustPan: function _adjustPan() {},
        _setPosition: function _setPosition(pos) {
            var subX, subY, map = this._map, container = this._container, centerPoint = map.latLngToContainerPoint(map.getCenter()), tooltipPoint = map.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (direction === "top") {
                subX = tooltipWidth / 2;
                subY = tooltipHeight;
            } else if (direction === "bottom") {
                subX = tooltipWidth / 2;
                subY = 0;
            } else if (direction === "center") {
                subX = tooltipWidth / 2;
                subY = tooltipHeight / 2;
            } else if (direction === "right") {
                subX = 0;
                subY = tooltipHeight / 2;
            } else if (direction === "left") {
                subX = tooltipWidth;
                subY = tooltipHeight / 2;
            } else if (tooltipPoint.x < centerPoint.x) {
                direction = "right";
                subX = 0;
                subY = tooltipHeight / 2;
            } else {
                direction = "left";
                subX = tooltipWidth + (offset.x + anchor.x) * 2;
                subY = tooltipHeight / 2;
            }
            pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
            removeClass(container, "leaflet-tooltip-right");
            removeClass(container, "leaflet-tooltip-left");
            removeClass(container, "leaflet-tooltip-top");
            removeClass(container, "leaflet-tooltip-bottom");
            addClass(container, "leaflet-tooltip-" + direction);
            setPosition(container, pos);
        },
        _updatePosition: function _updatePosition() {
            var pos = this._map.latLngToLayerPoint(this._latlng);
            this._setPosition(pos);
        },
        setOpacity: function setOpacity1(opacity) {
            this.options.opacity = opacity;
            if (this._container) setOpacity(this._container, opacity);
        },
        _animateZoom: function _animateZoom(e) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
            this._setPosition(pos);
        },
        _getAnchor: function _getAnchor() {
            // Where should we anchor the tooltip on the source layer?
            return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [
                0,
                0
            ]);
        }
    });
    // @namespace Tooltip
    // @factory L.tooltip(options?: Tooltip options, source?: Layer)
    // Instantiates a `Tooltip` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
    // @alternative
    // @factory L.tooltip(latlng: LatLng, options?: Tooltip options)
    // Instantiates a `Tooltip` object given `latlng` where the tooltip will open and an optional `options` object that describes its appearance and location.
    var tooltip = function tooltip(options, source) {
        return new Tooltip(options, source);
    };
    // @namespace Map
    // @section Methods for Layers and Controls
    Map.include({
        // @method openTooltip(tooltip: Tooltip): this
        // Opens the specified tooltip.
        // @alternative
        // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
        // Creates a tooltip with the specified content and options and open it.
        openTooltip: function openTooltip(tooltip, latlng, options) {
            this._initOverlay(Tooltip, tooltip, latlng, options).openOn(this);
            return this;
        },
        // @method closeTooltip(tooltip: Tooltip): this
        // Closes the tooltip given as parameter.
        closeTooltip: function closeTooltip(tooltip) {
            tooltip.close();
            return this;
        }
    });
    /*
   * @namespace Layer
   * @section Tooltip methods example
   *
   * All layers share a set of methods convenient for binding tooltips to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
   * layer.openTooltip();
   * layer.closeTooltip();
   * ```
   */ // @section Tooltip methods
    Layer.include({
        // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
        // Binds a tooltip to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindTooltip: function bindTooltip(content, options) {
            if (this._tooltip && this.isTooltipOpen()) this.unbindTooltip();
            this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);
            this._initTooltipInteractions();
            if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) this.openTooltip();
            return this;
        },
        // @method unbindTooltip(): this
        // Removes the tooltip previously bound with `bindTooltip`.
        unbindTooltip: function unbindTooltip() {
            if (this._tooltip) {
                this._initTooltipInteractions(true);
                this.closeTooltip();
                this._tooltip = null;
            }
            return this;
        },
        _initTooltipInteractions: function _initTooltipInteractions(remove) {
            if (!remove && this._tooltipHandlersAdded) return;
            var onOff = remove ? "off" : "on", events = {
                remove: this.closeTooltip,
                move: this._moveTooltip
            };
            if (!this._tooltip.options.permanent) {
                events.mouseover = this._openTooltip;
                events.mouseout = this.closeTooltip;
                events.click = this._openTooltip;
                if (this._map) this._addFocusListeners();
                else events.add = this._addFocusListeners;
            } else events.add = this._openTooltip;
            if (this._tooltip.options.sticky) events.mousemove = this._moveTooltip;
            this[onOff](events);
            this._tooltipHandlersAdded = !remove;
        },
        // @method openTooltip(latlng?: LatLng): this
        // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
        openTooltip: function openTooltip(latlng) {
            if (this._tooltip) {
                if (!(this instanceof FeatureGroup)) this._tooltip._source = this;
                if (this._tooltip._prepareOpen(latlng)) {
                    // open the tooltip on the map
                    this._tooltip.openOn(this._map);
                    if (this.getElement) this._setAriaDescribedByOnLayer(this);
                    else if (this.eachLayer) this.eachLayer(this._setAriaDescribedByOnLayer, this);
                }
            }
            return this;
        },
        // @method closeTooltip(): this
        // Closes the tooltip bound to this layer if it is open.
        closeTooltip: function closeTooltip() {
            if (this._tooltip) return this._tooltip.close();
        },
        // @method toggleTooltip(): this
        // Opens or closes the tooltip bound to this layer depending on its current state.
        toggleTooltip: function toggleTooltip() {
            if (this._tooltip) this._tooltip.toggle(this);
            return this;
        },
        // @method isTooltipOpen(): boolean
        // Returns `true` if the tooltip bound to this layer is currently open.
        isTooltipOpen: function isTooltipOpen() {
            return this._tooltip.isOpen();
        },
        // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
        // Sets the content of the tooltip bound to this layer.
        setTooltipContent: function setTooltipContent(content) {
            if (this._tooltip) this._tooltip.setContent(content);
            return this;
        },
        // @method getTooltip(): Tooltip
        // Returns the tooltip bound to this layer.
        getTooltip: function getTooltip() {
            return this._tooltip;
        },
        _addFocusListeners: function _addFocusListeners() {
            if (this.getElement) this._addFocusListenersOnLayer(this);
            else if (this.eachLayer) this.eachLayer(this._addFocusListenersOnLayer, this);
        },
        _addFocusListenersOnLayer: function _addFocusListenersOnLayer(layer) {
            var el = typeof layer.getElement === "function" && layer.getElement();
            if (el) {
                on(el, "focus", function() {
                    this._tooltip._source = layer;
                    this.openTooltip();
                }, this);
                on(el, "blur", this.closeTooltip, this);
            }
        },
        _setAriaDescribedByOnLayer: function _setAriaDescribedByOnLayer(layer) {
            var el = typeof layer.getElement === "function" && layer.getElement();
            if (el) el.setAttribute("aria-describedby", this._tooltip._container.id);
        },
        _openTooltip: function _openTooltip(e) {
            if (!this._tooltip || !this._map) return;
            // If the map is moving, we will show the tooltip after it's done.
            if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
                this._openOnceFlag = true;
                var that = this;
                this._map.once("moveend", function() {
                    that._openOnceFlag = false;
                    that._openTooltip(e);
                });
                return;
            }
            this._tooltip._source = e.layer || e.target;
            this.openTooltip(this._tooltip.options.sticky ? e.latlng : undefined);
        },
        _moveTooltip: function _moveTooltip(e) {
            var latlng = e.latlng, containerPoint, layerPoint;
            if (this._tooltip.options.sticky && e.originalEvent) {
                containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
                layerPoint = this._map.containerPointToLayerPoint(containerPoint);
                latlng = this._map.layerPointToLatLng(layerPoint);
            }
            this._tooltip.setLatLng(latlng);
        }
    });
    /*
   * @class DivIcon
   * @aka L.DivIcon
   * @inherits Icon
   *
   * Represents a lightweight icon for markers that uses a simple `<div>`
   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
   *
   * @example
   * ```js
   * var myIcon = L.divIcon({className: 'my-div-icon'});
   * // you can set .my-div-icon styles in CSS
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
   */ var DivIcon = Icon.extend({
        options: {
            // @section
            // @aka DivIcon options
            iconSize: [
                12,
                12
            ],
            // iconAnchor: (Point),
            // popupAnchor: (Point),
            // @option html: String|HTMLElement = ''
            // Custom HTML code to put inside the div element, empty by default. Alternatively,
            // an instance of `HTMLElement`.
            html: false,
            // @option bgPos: Point = [0, 0]
            // Optional relative position of the background, in pixels
            bgPos: null,
            className: "leaflet-div-icon"
        },
        createIcon: function createIcon(oldIcon) {
            var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
            if (options.html instanceof Element) {
                empty(div);
                div.appendChild(options.html);
            } else div.innerHTML = options.html !== false ? options.html : "";
            if (options.bgPos) {
                var bgPos = toPoint(options.bgPos);
                div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
            }
            this._setIconStyles(div, "icon");
            return div;
        },
        createShadow: function createShadow() {
            return null;
        }
    });
    // @factory L.divIcon(options: DivIcon options)
    // Creates a `DivIcon` instance with the given options.
    function divIcon(options) {
        return new DivIcon(options);
    }
    Icon.Default = IconDefault;
    /*
   * @class GridLayer
   * @inherits Layer
   * @aka L.GridLayer
   *
   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
   *
   *
   * @section Synchronous usage
   * @example
   *
   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords){
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
   *         var ctx = tile.getContext('2d');
   *
   *         // return the tile so it can be rendered on screen
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section Asynchronous usage
   * @example
   *
   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords, done){
   *         var error;
   *
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // draw something asynchronously and pass the tile to the done() callback
   *         setTimeout(function() {
   *             done(error, tile);
   *         }, 1000);
   *
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section
   */ var GridLayer = Layer.extend({
        // @section
        // @aka GridLayer options
        options: {
            // @option tileSize: Number|Point = 256
            // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
            tileSize: 256,
            // @option opacity: Number = 1.0
            // Opacity of the tiles. Can be used in the `createTile()` function.
            opacity: 1,
            // @option updateWhenIdle: Boolean = (depends)
            // Load new tiles only when panning ends.
            // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
            // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
            // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
            updateWhenIdle: Browser.mobile,
            // @option updateWhenZooming: Boolean = true
            // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
            updateWhenZooming: true,
            // @option updateInterval: Number = 200
            // Tiles will not update more than once every `updateInterval` milliseconds when panning.
            updateInterval: 200,
            // @option zIndex: Number = 1
            // The explicit zIndex of the tile layer.
            zIndex: 1,
            // @option bounds: LatLngBounds = undefined
            // If set, tiles will only be loaded inside the set `LatLngBounds`.
            bounds: null,
            // @option minZoom: Number = 0
            // The minimum zoom level down to which this layer will be displayed (inclusive).
            minZoom: 0,
            // @option maxZoom: Number = undefined
            // The maximum zoom level up to which this layer will be displayed (inclusive).
            maxZoom: undefined,
            // @option maxNativeZoom: Number = undefined
            // Maximum zoom number the tile source has available. If it is specified,
            // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
            // from `maxNativeZoom` level and auto-scaled.
            maxNativeZoom: undefined,
            // @option minNativeZoom: Number = undefined
            // Minimum zoom number the tile source has available. If it is specified,
            // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
            // from `minNativeZoom` level and auto-scaled.
            minNativeZoom: undefined,
            // @option noWrap: Boolean = false
            // Whether the layer is wrapped around the antimeridian. If `true`, the
            // GridLayer will only be displayed once at low zoom levels. Has no
            // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
            // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
            // tiles outside the CRS limits.
            noWrap: false,
            // @option pane: String = 'tilePane'
            // `Map pane` where the grid layer will be added.
            pane: "tilePane",
            // @option className: String = ''
            // A custom class name to assign to the tile layer. Empty by default.
            className: "",
            // @option keepBuffer: Number = 2
            // When panning the map, keep this many rows and columns of tiles before unloading them.
            keepBuffer: 2
        },
        initialize: function initialize(options) {
            setOptions(this, options);
        },
        onAdd: function onAdd() {
            this._initContainer();
            this._levels = {};
            this._tiles = {};
            this._resetView(); // implicit _update() call
        },
        beforeAdd: function beforeAdd(map) {
            map._addZoomLimit(this);
        },
        onRemove: function onRemove(map) {
            this._removeAllTiles();
            remove(this._container);
            map._removeZoomLimit(this);
            this._container = null;
            this._tileZoom = undefined;
        },
        // @method bringToFront: this
        // Brings the tile layer to the top of all tile layers.
        bringToFront: function bringToFront() {
            if (this._map) {
                toFront(this._container);
                this._setAutoZIndex(Math.max);
            }
            return this;
        },
        // @method bringToBack: this
        // Brings the tile layer to the bottom of all tile layers.
        bringToBack: function bringToBack() {
            if (this._map) {
                toBack(this._container);
                this._setAutoZIndex(Math.min);
            }
            return this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the tiles for this layer.
        getContainer: function getContainer() {
            return this._container;
        },
        // @method setOpacity(opacity: Number): this
        // Changes the [opacity](#gridlayer-opacity) of the grid layer.
        setOpacity: function setOpacity(opacity) {
            this.options.opacity = opacity;
            this._updateOpacity();
            return this;
        },
        // @method setZIndex(zIndex: Number): this
        // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
        setZIndex: function setZIndex(zIndex) {
            this.options.zIndex = zIndex;
            this._updateZIndex();
            return this;
        },
        // @method isLoading: Boolean
        // Returns `true` if any tile in the grid layer has not finished loading.
        isLoading: function isLoading() {
            return this._loading;
        },
        // @method redraw: this
        // Causes the layer to clear all the tiles and request them again.
        redraw: function redraw() {
            if (this._map) {
                this._removeAllTiles();
                var tileZoom = this._clampZoom(this._map.getZoom());
                if (tileZoom !== this._tileZoom) {
                    this._tileZoom = tileZoom;
                    this._updateLevels();
                }
                this._update();
            }
            return this;
        },
        getEvents: function getEvents() {
            var events = {
                viewprereset: this._invalidateAll,
                viewreset: this._resetView,
                zoom: this._resetView,
                moveend: this._onMoveEnd
            };
            if (!this.options.updateWhenIdle) {
                // update tiles on move, but not more often than once per given interval
                if (!this._onMove) this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
                events.move = this._onMove;
            }
            if (this._zoomAnimated) events.zoomanim = this._animateZoom;
            return events;
        },
        // @section Extension methods
        // Layers extending `GridLayer` shall reimplement the following method.
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, must be overridden by classes extending `GridLayer`.
        // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
        // is specified, it must be called when the tile has finished loading and drawing.
        createTile: function createTile() {
            return document.createElement("div");
        },
        // @section
        // @method getTileSize: Point
        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
        getTileSize: function getTileSize() {
            var s = this.options.tileSize;
            return s instanceof Point ? s : new Point(s, s);
        },
        _updateZIndex: function _updateZIndex() {
            if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) this._container.style.zIndex = this.options.zIndex;
        },
        _setAutoZIndex: function _setAutoZIndex(compare) {
            // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)
            var layers = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min
            for(var i = 0, len = layers.length, zIndex; i < len; i++){
                zIndex = layers[i].style.zIndex;
                if (layers[i] !== this._container && zIndex) edgeZIndex = compare(edgeZIndex, +zIndex);
            }
            if (isFinite(edgeZIndex)) {
                this.options.zIndex = edgeZIndex + compare(-1, 1);
                this._updateZIndex();
            }
        },
        _updateOpacity: function _updateOpacity() {
            if (!this._map) return;
            // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
            if (Browser.ielt9) return;
            setOpacity(this._container, this.options.opacity);
            var now = +new Date(), nextFrame = false, willPrune = false;
            for(var key in this._tiles){
                var tile = this._tiles[key];
                if (!tile.current || !tile.loaded) continue;
                var fade = Math.min(1, (now - tile.loaded) / 200);
                setOpacity(tile.el, fade);
                if (fade < 1) nextFrame = true;
                else {
                    if (tile.active) willPrune = true;
                    else this._onOpaqueTile(tile);
                    tile.active = true;
                }
            }
            if (willPrune && !this._noPrune) this._pruneTiles();
            if (nextFrame) {
                cancelAnimFrame(this._fadeFrame);
                this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
            }
        },
        _onOpaqueTile: falseFn,
        _initContainer: function _initContainer() {
            if (this._container) return;
            this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
            this._updateZIndex();
            if (this.options.opacity < 1) this._updateOpacity();
            this.getPane().appendChild(this._container);
        },
        _updateLevels: function _updateLevels() {
            var zoom = this._tileZoom, maxZoom = this.options.maxZoom;
            if (zoom === undefined) return undefined;
            for(var z in this._levels){
                z = Number(z);
                if (this._levels[z].el.children.length || z === zoom) {
                    this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
                    this._onUpdateLevel(z);
                } else {
                    remove(this._levels[z].el);
                    this._removeTilesAtZoom(z);
                    this._onRemoveLevel(z);
                    delete this._levels[z];
                }
            }
            var level = this._levels[zoom], map = this._map;
            if (!level) {
                level = this._levels[zoom] = {};
                level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
                level.el.style.zIndex = maxZoom;
                level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
                level.zoom = zoom;
                this._setZoomTransform(level, map.getCenter(), map.getZoom());
                // force the browser to consider the newly added element for transition
                falseFn(level.el.offsetWidth);
                this._onCreateLevel(level);
            }
            this._level = level;
            return level;
        },
        _onUpdateLevel: falseFn,
        _onRemoveLevel: falseFn,
        _onCreateLevel: falseFn,
        _pruneTiles: function _pruneTiles() {
            if (!this._map) return;
            var key, tile;
            var zoom = this._map.getZoom();
            if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
                this._removeAllTiles();
                return;
            }
            for(key in this._tiles){
                tile = this._tiles[key];
                tile.retain = tile.current;
            }
            for(key in this._tiles){
                tile = this._tiles[key];
                if (tile.current && !tile.active) {
                    var coords = tile.coords;
                    if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
                }
            }
            for(key in this._tiles)if (!this._tiles[key].retain) this._removeTile(key);
        },
        _removeTilesAtZoom: function _removeTilesAtZoom(zoom) {
            for(var key in this._tiles){
                if (this._tiles[key].coords.z !== zoom) continue;
                this._removeTile(key);
            }
        },
        _removeAllTiles: function _removeAllTiles() {
            for(var key in this._tiles)this._removeTile(key);
        },
        _invalidateAll: function _invalidateAll() {
            for(var z in this._levels){
                remove(this._levels[z].el);
                this._onRemoveLevel(Number(z));
                delete this._levels[z];
            }
            this._removeAllTiles();
            this._tileZoom = undefined;
        },
        _retainParent: function _retainParent(x, y, z, minZoom) {
            var x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1, coords2 = new Point(+x2, +y2);
            coords2.z = +z2;
            var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
            if (tile && tile.active) {
                tile.retain = true;
                return true;
            } else if (tile && tile.loaded) tile.retain = true;
            if (z2 > minZoom) return this._retainParent(x2, y2, z2, minZoom);
            return false;
        },
        _retainChildren: function _retainChildren(x, y, z, maxZoom) {
            for(var i = 2 * x; i < 2 * x + 2; i++)for(var j = 2 * y; j < 2 * y + 2; j++){
                var coords = new Point(i, j);
                coords.z = z + 1;
                var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
                if (tile && tile.active) {
                    tile.retain = true;
                    continue;
                } else if (tile && tile.loaded) tile.retain = true;
                if (z + 1 < maxZoom) this._retainChildren(i, j, z + 1, maxZoom);
            }
        },
        _resetView: function _resetView(e) {
            var animating = e && (e.pinch || e.flyTo);
            this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
        },
        _animateZoom: function _animateZoom(e) {
            this._setView(e.center, e.zoom, true, e.noUpdate);
        },
        _clampZoom: function _clampZoom(zoom) {
            var options = this.options;
            if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) return options.minNativeZoom;
            if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) return options.maxNativeZoom;
            return zoom;
        },
        _setView: function _setView(center, zoom, noPrune, noUpdate) {
            var tileZoom = Math.round(zoom);
            if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) tileZoom = undefined;
            else tileZoom = this._clampZoom(tileZoom);
            var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
            if (!noUpdate || tileZoomChanged) {
                this._tileZoom = tileZoom;
                if (this._abortLoading) this._abortLoading();
                this._updateLevels();
                this._resetGrid();
                if (tileZoom !== undefined) this._update(center);
                if (!noPrune) this._pruneTiles();
                // Flag to prevent _updateOpacity from pruning tiles during
                // a zoom anim or a pinch gesture
                this._noPrune = !!noPrune;
            }
            this._setZoomTransforms(center, zoom);
        },
        _setZoomTransforms: function _setZoomTransforms(center, zoom) {
            for(var i in this._levels)this._setZoomTransform(this._levels[i], center, zoom);
        },
        _setZoomTransform: function _setZoomTransform(level, center, zoom) {
            var scale = this._map.getZoomScale(zoom, level.zoom), translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();
            if (Browser.any3d) setTransform(level.el, translate, scale);
            else setPosition(level.el, translate);
        },
        _resetGrid: function _resetGrid() {
            var map = this._map, crs = map.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
            var bounds = this._map.getPixelWorldBounds(this._tileZoom);
            if (bounds) this._globalTileRange = this._pxBoundsToTileRange(bounds);
            this._wrapX = crs.wrapLng && !this.options.noWrap && [
                Math.floor(map.project([
                    0,
                    crs.wrapLng[0]
                ], tileZoom).x / tileSize.x),
                Math.ceil(map.project([
                    0,
                    crs.wrapLng[1]
                ], tileZoom).x / tileSize.y)
            ];
            this._wrapY = crs.wrapLat && !this.options.noWrap && [
                Math.floor(map.project([
                    crs.wrapLat[0],
                    0
                ], tileZoom).y / tileSize.x),
                Math.ceil(map.project([
                    crs.wrapLat[1],
                    0
                ], tileZoom).y / tileSize.y)
            ];
        },
        _onMoveEnd: function _onMoveEnd() {
            if (!this._map || this._map._animatingZoom) return;
            this._update();
        },
        _getTiledPixelBounds: function _getTiledPixelBounds(center) {
            var map = this._map, mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(), scale = map.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map.project(center, this._tileZoom).floor(), halfSize = map.getSize().divideBy(scale * 2);
            return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
        },
        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function _update(center) {
            var map = this._map;
            if (!map) return;
            var zoom = this._clampZoom(map.getZoom());
            if (center === undefined) center = map.getCenter();
            if (this._tileZoom === undefined) return;
             // if out of minzoom/maxzoom
            var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([
                margin,
                -margin
            ]), tileRange.getTopRight().add([
                margin,
                -margin
            ]));
            // Sanity check: panic if the tile range contains Infinity somewhere.
            if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) throw new Error("Attempted to load an infinite number of tiles");
            for(var key in this._tiles){
                var c = this._tiles[key].coords;
                if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) this._tiles[key].current = false;
            }
            // _update just loads more tiles. If the tile zoom level differs too much
            // from the map's, let _setView reset levels and prune old tiles.
            if (Math.abs(zoom - this._tileZoom) > 1) {
                this._setView(center, zoom);
                return;
            }
            // create a queue of coordinates to load tiles from
            for(var j = tileRange.min.y; j <= tileRange.max.y; j++)for(var i = tileRange.min.x; i <= tileRange.max.x; i++){
                var coords = new Point(i, j);
                coords.z = this._tileZoom;
                if (!this._isValidTile(coords)) continue;
                var tile = this._tiles[this._tileCoordsToKey(coords)];
                if (tile) tile.current = true;
                else queue.push(coords);
            }
            // sort tile queue to load tiles in order of their distance to center
            queue.sort(function(a, b) {
                return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
            });
            if (queue.length !== 0) {
                // if it's the first batch of tiles to load
                if (!this._loading) {
                    this._loading = true;
                    // @event loading: Event
                    // Fired when the grid layer starts loading tiles.
                    this.fire("loading");
                }
                // create DOM fragment to append tiles in one batch
                var fragment = document.createDocumentFragment();
                for(i = 0; i < queue.length; i++)this._addTile(queue[i], fragment);
                this._level.el.appendChild(fragment);
            }
        },
        _isValidTile: function _isValidTile(coords) {
            var crs = this._map.options.crs;
            if (!crs.infinite) {
                // don't load tile if it's out of bounds and not wrapped
                var bounds = this._globalTileRange;
                if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) return false;
            }
            if (!this.options.bounds) return true;
            // don't load tile if it doesn't intersect the bounds in options
            var tileBounds = this._tileCoordsToBounds(coords);
            return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
        },
        _keyToBounds: function _keyToBounds(key) {
            return this._tileCoordsToBounds(this._keyToTileCoords(key));
        },
        _tileCoordsToNwSe: function _tileCoordsToNwSe(coords) {
            var map = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map.unproject(nwPoint, coords.z), se = map.unproject(sePoint, coords.z);
            return [
                nw,
                se
            ];
        },
        // converts tile coordinates to its geographical bounds
        _tileCoordsToBounds: function _tileCoordsToBounds(coords) {
            var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
            if (!this.options.noWrap) bounds = this._map.wrapLatLngBounds(bounds);
            return bounds;
        },
        // converts tile coordinates to key for the tile cache
        _tileCoordsToKey: function _tileCoordsToKey(coords) {
            return coords.x + ":" + coords.y + ":" + coords.z;
        },
        // converts tile cache key to coordinates
        _keyToTileCoords: function _keyToTileCoords(key) {
            var k = key.split(":"), coords = new Point(+k[0], +k[1]);
            coords.z = +k[2];
            return coords;
        },
        _removeTile: function _removeTile(key) {
            var tile = this._tiles[key];
            if (!tile) return;
            remove(tile.el);
            delete this._tiles[key];
            // @event tileunload: TileEvent
            // Fired when a tile is removed (e.g. when a tile goes off the screen).
            this.fire("tileunload", {
                tile: tile.el,
                coords: this._keyToTileCoords(key)
            });
        },
        _initTile: function _initTile(tile) {
            addClass(tile, "leaflet-tile");
            var tileSize = this.getTileSize();
            tile.style.width = tileSize.x + "px";
            tile.style.height = tileSize.y + "px";
            tile.onselectstart = falseFn;
            tile.onmousemove = falseFn;
            // update opacity on tiles in IE7-8 because of filter inheritance problems
            if (Browser.ielt9 && this.options.opacity < 1) setOpacity(tile, this.options.opacity);
        },
        _addTile: function _addTile(coords, container) {
            var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
            var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
            this._initTile(tile);
            // if createTile is defined with a second argument ("done" callback),
            // we know that tile is async and will be ready later; otherwise
            if (this.createTile.length < 2) // mark tile as ready, but delay one frame for opacity animation to happen
            requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
            setPosition(tile, tilePos);
            // save tile in cache
            this._tiles[key] = {
                el: tile,
                coords: coords,
                current: true
            };
            container.appendChild(tile);
            // @event tileloadstart: TileEvent
            // Fired when a tile is requested and starts loading.
            this.fire("tileloadstart", {
                tile: tile,
                coords: coords
            });
        },
        _tileReady: function _tileReady(coords, err, tile) {
            if (err) // @event tileerror: TileErrorEvent
            // Fired when there is an error loading a tile.
            this.fire("tileerror", {
                error: err,
                tile: tile,
                coords: coords
            });
            var key = this._tileCoordsToKey(coords);
            tile = this._tiles[key];
            if (!tile) return;
            tile.loaded = +new Date();
            if (this._map._fadeAnimated) {
                setOpacity(tile.el, 0);
                cancelAnimFrame(this._fadeFrame);
                this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
            } else {
                tile.active = true;
                this._pruneTiles();
            }
            if (!err) {
                addClass(tile.el, "leaflet-tile-loaded");
                // @event tileload: TileEvent
                // Fired when a tile loads.
                this.fire("tileload", {
                    tile: tile.el,
                    coords: coords
                });
            }
            if (this._noTilesToLoad()) {
                this._loading = false;
                // @event load: Event
                // Fired when the grid layer loaded all visible tiles.
                this.fire("load");
                if (Browser.ielt9 || !this._map._fadeAnimated) requestAnimFrame(this._pruneTiles, this);
                else // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
                // to trigger a pruning.
                setTimeout(bind(this._pruneTiles, this), 250);
            }
        },
        _getTilePos: function _getTilePos(coords) {
            return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
        },
        _wrapCoords: function _wrapCoords(coords) {
            var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
            newCoords.z = coords.z;
            return newCoords;
        },
        _pxBoundsToTileRange: function _pxBoundsToTileRange(bounds) {
            var tileSize = this.getTileSize();
            return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([
                1,
                1
            ]));
        },
        _noTilesToLoad: function _noTilesToLoad() {
            for(var key in this._tiles){
                if (!this._tiles[key].loaded) return false;
            }
            return true;
        }
    });
    // @factory L.gridLayer(options?: GridLayer options)
    // Creates a new instance of GridLayer with the supplied options.
    function gridLayer(options) {
        return new GridLayer(options);
    }
    /*
   * @class TileLayer
   * @inherits GridLayer
   * @aka L.TileLayer
   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.
   *
   * @example
   *
   * ```js
   * L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'}).addTo(map);
   * ```
   *
   * @section URL template
   * @example
   *
   * A string of the following form:
   *
   * ```
   * 'https://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
   * ```
   *
   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}`  zoom level, `{x}` and `{y}`  tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
   *
   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
   *
   * ```
   * L.tileLayer('https://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
   * ```
   */ var TileLayer = GridLayer.extend({
        // @section
        // @aka TileLayer options
        options: {
            // @option minZoom: Number = 0
            // The minimum zoom level down to which this layer will be displayed (inclusive).
            minZoom: 0,
            // @option maxZoom: Number = 18
            // The maximum zoom level up to which this layer will be displayed (inclusive).
            maxZoom: 18,
            // @option subdomains: String|String[] = 'abc'
            // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
            subdomains: "abc",
            // @option errorTileUrl: String = ''
            // URL to the tile image to show in place of the tile that failed to load.
            errorTileUrl: "",
            // @option zoomOffset: Number = 0
            // The zoom number used in tile URLs will be offset with this value.
            zoomOffset: 0,
            // @option tms: Boolean = false
            // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
            tms: false,
            // @option zoomReverse: Boolean = false
            // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
            zoomReverse: false,
            // @option detectRetina: Boolean = false
            // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
            detectRetina: false,
            // @option crossOrigin: Boolean|String = false
            // Whether the crossOrigin attribute will be added to the tiles.
            // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
            crossOrigin: false,
            // @option referrerPolicy: Boolean|String = false
            // Whether the referrerPolicy attribute will be added to the tiles.
            // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
            // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
            // (e.g. to validate an API token).
            // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
            referrerPolicy: false
        },
        initialize: function initialize(url, options) {
            this._url = url;
            options = setOptions(this, options);
            // detecting retina displays, adjusting tileSize and zoom levels
            if (options.detectRetina && Browser.retina && options.maxZoom > 0) {
                options.tileSize = Math.floor(options.tileSize / 2);
                if (!options.zoomReverse) {
                    options.zoomOffset++;
                    options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
                } else {
                    options.zoomOffset--;
                    options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
                }
                options.minZoom = Math.max(0, options.minZoom);
            } else if (!options.zoomReverse) // make sure maxZoom is gte minZoom
            options.maxZoom = Math.max(options.minZoom, options.maxZoom);
            else // make sure minZoom is lte maxZoom
            options.minZoom = Math.min(options.maxZoom, options.minZoom);
            if (typeof options.subdomains === "string") options.subdomains = options.subdomains.split("");
            this.on("tileunload", this._onTileRemove);
        },
        // @method setUrl(url: String, noRedraw?: Boolean): this
        // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
        // If the URL does not change, the layer will not be redrawn unless
        // the noRedraw parameter is set to false.
        setUrl: function setUrl(url, noRedraw) {
            if (this._url === url && noRedraw === undefined) noRedraw = true;
            this._url = url;
            if (!noRedraw) this.redraw();
            return this;
        },
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
        // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
        // callback is called when the tile has been loaded.
        createTile: function createTile(coords, done) {
            var tile = document.createElement("img");
            on(tile, "load", bind(this._tileOnLoad, this, done, tile));
            on(tile, "error", bind(this._tileOnError, this, done, tile));
            if (this.options.crossOrigin || this.options.crossOrigin === "") tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            // for this new option we follow the documented behavior
            // more closely by only setting the property when string
            if (typeof this.options.referrerPolicy === "string") tile.referrerPolicy = this.options.referrerPolicy;
            // The alt attribute is set to the empty string,
            // allowing screen readers to ignore the decorative image tiles.
            // https://www.w3.org/WAI/tutorials/images/decorative/
            // https://www.w3.org/TR/html-aria/#el-img-empty-alt
            tile.alt = "";
            tile.src = this.getTileUrl(coords);
            return tile;
        },
        // @section Extension methods
        // @uninheritable
        // Layers extending `TileLayer` might reimplement the following method.
        // @method getTileUrl(coords: Object): String
        // Called only internally, returns the URL for a tile given its coordinates.
        // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
        getTileUrl: function getTileUrl(coords) {
            var data = {
                r: Browser.retina ? "@2x" : "",
                s: this._getSubdomain(coords),
                x: coords.x,
                y: coords.y,
                z: this._getZoomForUrl()
            };
            if (this._map && !this._map.options.crs.infinite) {
                var invertedY = this._globalTileRange.max.y - coords.y;
                if (this.options.tms) data["y"] = invertedY;
                data["-y"] = invertedY;
            }
            return template(this._url, extend(data, this.options));
        },
        _tileOnLoad: function _tileOnLoad(done, tile) {
            // For https://github.com/Leaflet/Leaflet/issues/3332
            if (Browser.ielt9) setTimeout(bind(done, this, null, tile), 0);
            else done(null, tile);
        },
        _tileOnError: function _tileOnError(done, tile, e) {
            var errorUrl = this.options.errorTileUrl;
            if (errorUrl && tile.getAttribute("src") !== errorUrl) tile.src = errorUrl;
            done(e, tile);
        },
        _onTileRemove: function _onTileRemove(e) {
            e.tile.onload = null;
        },
        _getZoomForUrl: function _getZoomForUrl() {
            var zoom = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
            if (zoomReverse) zoom = maxZoom - zoom;
            return zoom + zoomOffset;
        },
        _getSubdomain: function _getSubdomain(tilePoint) {
            var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
            return this.options.subdomains[index];
        },
        // stops loading all tiles in the background layer
        _abortLoading: function _abortLoading() {
            var i, tile;
            for(i in this._tiles)if (this._tiles[i].coords.z !== this._tileZoom) {
                tile = this._tiles[i].el;
                tile.onload = falseFn;
                tile.onerror = falseFn;
                if (!tile.complete) {
                    tile.src = emptyImageUrl;
                    var coords = this._tiles[i].coords;
                    remove(tile);
                    delete this._tiles[i];
                    // @event tileabort: TileEvent
                    // Fired when a tile was loading but is now not wanted.
                    this.fire("tileabort", {
                        tile: tile,
                        coords: coords
                    });
                }
            }
        },
        _removeTile: function _removeTile(key) {
            var tile = this._tiles[key];
            if (!tile) return;
            // Cancels any pending http requests associated with the tile
            tile.el.setAttribute("src", emptyImageUrl);
            return GridLayer.prototype._removeTile.call(this, key);
        },
        _tileReady: function _tileReady(coords, err, tile) {
            if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) return;
            return GridLayer.prototype._tileReady.call(this, coords, err, tile);
        }
    });
    // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
    // Instantiates a tile layer object given a `URL template` and optionally an options object.
    function tileLayer(url, options) {
        return new TileLayer(url, options);
    }
    /*
   * @class TileLayer.WMS
   * @inherits TileLayer
   * @aka L.TileLayer.WMS
   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
   *
   * @example
   *
   * ```js
   * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
   * 	layers: 'nexrad-n0r-900913',
   * 	format: 'image/png',
   * 	transparent: true,
   * 	attribution: "Weather data  2012 IEM Nexrad"
   * });
   * ```
   */ var TileLayerWMS = TileLayer.extend({
        // @section
        // @aka TileLayer.WMS options
        // If any custom options not documented here are used, they will be sent to the
        // WMS server as extra parameters in each request URL. This can be useful for
        // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
        defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            // @option layers: String = ''
            // **(required)** Comma-separated list of WMS layers to show.
            layers: "",
            // @option styles: String = ''
            // Comma-separated list of WMS styles.
            styles: "",
            // @option format: String = 'image/jpeg'
            // WMS image format (use `'image/png'` for layers with transparency).
            format: "image/jpeg",
            // @option transparent: Boolean = false
            // If `true`, the WMS service will return images with transparency.
            transparent: false,
            // @option version: String = '1.1.1'
            // Version of the WMS service to use
            version: "1.1.1"
        },
        options: {
            // @option crs: CRS = null
            // Coordinate Reference System to use for the WMS requests, defaults to
            // map CRS. Don't change this if you're not sure what it means.
            crs: null,
            // @option uppercase: Boolean = false
            // If `true`, WMS request parameter keys will be uppercase.
            uppercase: false
        },
        initialize: function initialize(url, options) {
            this._url = url;
            var wmsParams = extend({}, this.defaultWmsParams);
            // all keys that are not TileLayer options go to WMS params
            for(var i in options)if (!(i in this.options)) wmsParams[i] = options[i];
            options = setOptions(this, options);
            var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
            var tileSize = this.getTileSize();
            wmsParams.width = tileSize.x * realRetina;
            wmsParams.height = tileSize.y * realRetina;
            this.wmsParams = wmsParams;
        },
        onAdd: function onAdd(map) {
            this._crs = this.options.crs || map.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);
            var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
            this.wmsParams[projectionKey] = this._crs.code;
            TileLayer.prototype.onAdd.call(this, map);
        },
        getTileUrl: function getTileUrl(coords) {
            var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [
                min.y,
                min.x,
                max.y,
                max.x
            ] : [
                min.x,
                min.y,
                max.x,
                max.y
            ]).join(","), url = TileLayer.prototype.getTileUrl.call(this, coords);
            return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
        },
        // @method setParams(params: Object, noRedraw?: Boolean): this
        // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
        setParams: function setParams(params, noRedraw) {
            extend(this.wmsParams, params);
            if (!noRedraw) this.redraw();
            return this;
        }
    });
    // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
    // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
    function tileLayerWMS(url, options) {
        return new TileLayerWMS(url, options);
    }
    TileLayer.WMS = TileLayerWMS;
    tileLayer.wms = tileLayerWMS;
    /*
   * @class Renderer
   * @inherits Layer
   * @aka L.Renderer
   *
   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
   * DOM container of the renderer, its bounds, and its zoom animation.
   *
   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
   * itself can be added or removed to the map. All paths use a renderer, which can
   * be implicit (the map will decide the type of renderer and use it automatically)
   * or explicit (using the [`renderer`](#path-renderer) option of the path).
   *
   * Do not use this class directly, use `SVG` and `Canvas` instead.
   *
   * @event update: Event
   * Fired when the renderer updates its bounds, center and zoom, for example when
   * its map has moved
   */ var Renderer = Layer.extend({
        // @section
        // @aka Renderer options
        options: {
            // @option padding: Number = 0.1
            // How much to extend the clip area around the map view (relative to its size)
            // e.g. 0.1 would be 10% of map view in each direction
            padding: 0.1
        },
        initialize: function initialize(options) {
            setOptions(this, options);
            stamp(this);
            this._layers = this._layers || {};
        },
        onAdd: function onAdd() {
            if (!this._container) {
                this._initContainer(); // defined by renderer implementations
                // always keep transform-origin as 0 0
                addClass(this._container, "leaflet-zoom-animated");
            }
            this.getPane().appendChild(this._container);
            this._update();
            this.on("update", this._updatePaths, this);
        },
        onRemove: function onRemove() {
            this.off("update", this._updatePaths, this);
            this._destroyContainer();
        },
        getEvents: function getEvents() {
            var events = {
                viewreset: this._reset,
                zoom: this._onZoom,
                moveend: this._update,
                zoomend: this._onZoomEnd
            };
            if (this._zoomAnimated) events.zoomanim = this._onAnimZoom;
            return events;
        },
        _onAnimZoom: function _onAnimZoom(ev) {
            this._updateTransform(ev.center, ev.zoom);
        },
        _onZoom: function _onZoom() {
            this._updateTransform(this._map.getCenter(), this._map.getZoom());
        },
        _updateTransform: function _updateTransform(center, zoom) {
            var scale = this._map.getZoomScale(zoom, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom), topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom));
            if (Browser.any3d) setTransform(this._container, topLeftOffset, scale);
            else setPosition(this._container, topLeftOffset);
        },
        _reset: function _reset() {
            this._update();
            this._updateTransform(this._center, this._zoom);
            for(var id in this._layers)this._layers[id]._reset();
        },
        _onZoomEnd: function _onZoomEnd() {
            for(var id in this._layers)this._layers[id]._project();
        },
        _updatePaths: function _updatePaths() {
            for(var id in this._layers)this._layers[id]._update();
        },
        _update: function _update() {
            // Update pixel bounds of renderer container (for positioning/sizing/clipping later)
            // Subclasses are responsible of firing the 'update' event.
            var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
            this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
            this._center = this._map.getCenter();
            this._zoom = this._map.getZoom();
        }
    });
    /*
   * @class Canvas
   * @inherits Renderer
   * @aka L.Canvas
   *
   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](https://caniuse.com/canvas), Canvas is not
   * available in all web browsers, notably IE8, and overlapping geometries might
   * not display properly in some edge cases.
   *
   * @example
   *
   * Use Canvas by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.canvas()
   * });
   * ```
   *
   * Use a Canvas renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.canvas({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */ var Canvas = Renderer.extend({
        // @section
        // @aka Canvas options
        options: {
            // @option tolerance: Number = 0
            // How much to extend the click tolerance around a path/object on the map.
            tolerance: 0
        },
        getEvents: function getEvents() {
            var events = Renderer.prototype.getEvents.call(this);
            events.viewprereset = this._onViewPreReset;
            return events;
        },
        _onViewPreReset: function _onViewPreReset() {
            // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
            this._postponeUpdatePaths = true;
        },
        onAdd: function onAdd() {
            Renderer.prototype.onAdd.call(this);
            // Redraw vectors since canvas is cleared upon removal,
            // in case of removing the renderer itself from the map.
            this._draw();
        },
        _initContainer: function _initContainer() {
            var container = this._container = document.createElement("canvas");
            on(container, "mousemove", this._onMouseMove, this);
            on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
            on(container, "mouseout", this._handleMouseOut, this);
            container["_leaflet_disable_events"] = true;
            this._ctx = container.getContext("2d");
        },
        _destroyContainer: function _destroyContainer() {
            cancelAnimFrame(this._redrawRequest);
            delete this._ctx;
            remove(this._container);
            off(this._container);
            delete this._container;
        },
        _updatePaths: function _updatePaths() {
            if (this._postponeUpdatePaths) return;
            var layer;
            this._redrawBounds = null;
            for(var id in this._layers){
                layer = this._layers[id];
                layer._update();
            }
            this._redraw();
        },
        _update: function _update() {
            if (this._map._animatingZoom && this._bounds) return;
            Renderer.prototype._update.call(this);
            var b = this._bounds, container = this._container, size = b.getSize(), m = Browser.retina ? 2 : 1;
            setPosition(container, b.min);
            // set canvas size (also clearing it); use double size on retina
            container.width = m * size.x;
            container.height = m * size.y;
            container.style.width = size.x + "px";
            container.style.height = size.y + "px";
            if (Browser.retina) this._ctx.scale(2, 2);
            // translate so we use the same path coordinates after canvas element moves
            this._ctx.translate(-b.min.x, -b.min.y);
            // Tell paths to redraw themselves
            this.fire("update");
        },
        _reset: function _reset() {
            Renderer.prototype._reset.call(this);
            if (this._postponeUpdatePaths) {
                this._postponeUpdatePaths = false;
                this._updatePaths();
            }
        },
        _initPath: function _initPath(layer) {
            this._updateDashArray(layer);
            this._layers[stamp(layer)] = layer;
            var order = layer._order = {
                layer: layer,
                prev: this._drawLast,
                next: null
            };
            if (this._drawLast) this._drawLast.next = order;
            this._drawLast = order;
            this._drawFirst = this._drawFirst || this._drawLast;
        },
        _addPath: function _addPath(layer) {
            this._requestRedraw(layer);
        },
        _removePath: function _removePath(layer) {
            var order = layer._order;
            var next = order.next;
            var prev = order.prev;
            if (next) next.prev = prev;
            else this._drawLast = prev;
            if (prev) prev.next = next;
            else this._drawFirst = next;
            delete layer._order;
            delete this._layers[stamp(layer)];
            this._requestRedraw(layer);
        },
        _updatePath: function _updatePath(layer) {
            // Redraw the union of the layer's old pixel
            // bounds and the new pixel bounds.
            this._extendRedrawBounds(layer);
            layer._project();
            layer._update();
            // The redraw will extend the redraw bounds
            // with the new pixel bounds.
            this._requestRedraw(layer);
        },
        _updateStyle: function _updateStyle(layer) {
            this._updateDashArray(layer);
            this._requestRedraw(layer);
        },
        _updateDashArray: function _updateDashArray(layer) {
            if (typeof layer.options.dashArray === "string") {
                var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i;
                for(i = 0; i < parts.length; i++){
                    dashValue = Number(parts[i]);
                    // Ignore dash array containing invalid lengths
                    if (isNaN(dashValue)) return;
                    dashArray.push(dashValue);
                }
                layer.options._dashArray = dashArray;
            } else layer.options._dashArray = layer.options.dashArray;
        },
        _requestRedraw: function _requestRedraw(layer) {
            if (!this._map) return;
            this._extendRedrawBounds(layer);
            this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
        },
        _extendRedrawBounds: function _extendRedrawBounds(layer) {
            if (layer._pxBounds) {
                var padding = (layer.options.weight || 0) + 1;
                this._redrawBounds = this._redrawBounds || new Bounds();
                this._redrawBounds.extend(layer._pxBounds.min.subtract([
                    padding,
                    padding
                ]));
                this._redrawBounds.extend(layer._pxBounds.max.add([
                    padding,
                    padding
                ]));
            }
        },
        _redraw: function _redraw() {
            this._redrawRequest = null;
            if (this._redrawBounds) {
                this._redrawBounds.min._floor();
                this._redrawBounds.max._ceil();
            }
            this._clear(); // clear layers in redraw bounds
            this._draw(); // draw layers
            this._redrawBounds = null;
        },
        _clear: function _clear() {
            var bounds = this._redrawBounds;
            if (bounds) {
                var size = bounds.getSize();
                this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
            } else {
                this._ctx.save();
                this._ctx.setTransform(1, 0, 0, 1, 0, 0);
                this._ctx.clearRect(0, 0, this._container.width, this._container.height);
                this._ctx.restore();
            }
        },
        _draw: function _draw() {
            var layer, bounds = this._redrawBounds;
            this._ctx.save();
            if (bounds) {
                var size = bounds.getSize();
                this._ctx.beginPath();
                this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
                this._ctx.clip();
            }
            this._drawing = true;
            for(var order = this._drawFirst; order; order = order.next){
                layer = order.layer;
                if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) layer._updatePath();
            }
            this._drawing = false;
            this._ctx.restore(); // Restore state before clipping.
        },
        _updatePoly: function _updatePoly(layer, closed) {
            if (!this._drawing) return;
            var i, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;
            if (!len) return;
            ctx.beginPath();
            for(i = 0; i < len; i++){
                for(j = 0, len2 = parts[i].length; j < len2; j++){
                    p = parts[i][j];
                    ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
                }
                if (closed) ctx.closePath();
            }
            this._fillStroke(ctx, layer);
        // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
        },
        _updateCircle: function _updateCircle(layer) {
            if (!this._drawing || layer._empty()) return;
            var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
            if (s !== 1) {
                ctx.save();
                ctx.scale(1, s);
            }
            ctx.beginPath();
            ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);
            if (s !== 1) ctx.restore();
            this._fillStroke(ctx, layer);
        },
        _fillStroke: function _fillStroke(ctx, layer) {
            var options = layer.options;
            if (options.fill) {
                ctx.globalAlpha = options.fillOpacity;
                ctx.fillStyle = options.fillColor || options.color;
                ctx.fill(options.fillRule || "evenodd");
            }
            if (options.stroke && options.weight !== 0) {
                if (ctx.setLineDash) ctx.setLineDash(layer.options && layer.options._dashArray || []);
                ctx.globalAlpha = options.opacity;
                ctx.lineWidth = options.weight;
                ctx.strokeStyle = options.color;
                ctx.lineCap = options.lineCap;
                ctx.lineJoin = options.lineJoin;
                ctx.stroke();
            }
        },
        // Canvas obviously doesn't have mouse events for individual drawn objects,
        // so we emulate that by calculating what's under the mouse on mousemove/click manually
        _onClick: function _onClick(e) {
            var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;
            for(var order = this._drawFirst; order; order = order.next){
                layer = order.layer;
                if (layer.options.interactive && layer._containsPoint(point)) {
                    if (!(e.type === "click" || e.type === "preclick") || !this._map._draggableMoved(layer)) clickedLayer = layer;
                }
            }
            this._fireEvent(clickedLayer ? [
                clickedLayer
            ] : false, e);
        },
        _onMouseMove: function _onMouseMove(e) {
            if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) return;
            var point = this._map.mouseEventToLayerPoint(e);
            this._handleMouseHover(e, point);
        },
        _handleMouseOut: function _handleMouseOut(e) {
            var layer = this._hoveredLayer;
            if (layer) {
                // if we're leaving the layer, fire mouseout
                removeClass(this._container, "leaflet-interactive");
                this._fireEvent([
                    layer
                ], e, "mouseout");
                this._hoveredLayer = null;
                this._mouseHoverThrottled = false;
            }
        },
        _handleMouseHover: function _handleMouseHover(e, point) {
            if (this._mouseHoverThrottled) return;
            var layer, candidateHoveredLayer;
            for(var order = this._drawFirst; order; order = order.next){
                layer = order.layer;
                if (layer.options.interactive && layer._containsPoint(point)) candidateHoveredLayer = layer;
            }
            if (candidateHoveredLayer !== this._hoveredLayer) {
                this._handleMouseOut(e);
                if (candidateHoveredLayer) {
                    addClass(this._container, "leaflet-interactive"); // change cursor
                    this._fireEvent([
                        candidateHoveredLayer
                    ], e, "mouseover");
                    this._hoveredLayer = candidateHoveredLayer;
                }
            }
            this._fireEvent(this._hoveredLayer ? [
                this._hoveredLayer
            ] : false, e);
            this._mouseHoverThrottled = true;
            setTimeout(bind(function() {
                this._mouseHoverThrottled = false;
            }, this), 32);
        },
        _fireEvent: function _fireEvent(layers, e, type) {
            this._map._fireDOMEvent(e, type || e.type, layers);
        },
        _bringToFront: function _bringToFront(layer) {
            var order = layer._order;
            if (!order) return;
            var next = order.next;
            var prev = order.prev;
            if (next) next.prev = prev;
            else // Already last
            return;
            if (prev) prev.next = next;
            else if (next) // Update first entry unless this is the
            // single entry
            this._drawFirst = next;
            order.prev = this._drawLast;
            this._drawLast.next = order;
            order.next = null;
            this._drawLast = order;
            this._requestRedraw(layer);
        },
        _bringToBack: function _bringToBack(layer) {
            var order = layer._order;
            if (!order) return;
            var next = order.next;
            var prev = order.prev;
            if (prev) prev.next = next;
            else // Already first
            return;
            if (next) next.prev = prev;
            else if (prev) // Update last entry unless this is the
            // single entry
            this._drawLast = prev;
            order.prev = null;
            order.next = this._drawFirst;
            this._drawFirst.prev = order;
            this._drawFirst = order;
            this._requestRedraw(layer);
        }
    });
    // @factory L.canvas(options?: Renderer options)
    // Creates a Canvas renderer with the given options.
    function canvas(options) {
        return Browser.canvas ? new Canvas(options) : null;
    }
    /*
   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
   */ var vmlCreate = function() {
        try {
            document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
            return function(name) {
                return document.createElement("<lvml:" + name + ' class="lvml">');
            };
        } catch (e) {
        // Do not return fn from catch block so `e` can be garbage collected
        // See https://github.com/Leaflet/Leaflet/pull/7279
        }
        return function(name) {
            return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
    }();
    /*
   * @class SVG
   *
   *
   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
   * with old versions of Internet Explorer.
   */ // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
    var vmlMixin = {
        _initContainer: function _initContainer() {
            this._container = create$1("div", "leaflet-vml-container");
        },
        _update: function _update() {
            if (this._map._animatingZoom) return;
            Renderer.prototype._update.call(this);
            this.fire("update");
        },
        _initPath: function _initPath(layer) {
            var container = layer._container = vmlCreate("shape");
            addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
            container.coordsize = "1 1";
            layer._path = vmlCreate("path");
            container.appendChild(layer._path);
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
        },
        _addPath: function _addPath(layer) {
            var container = layer._container;
            this._container.appendChild(container);
            if (layer.options.interactive) layer.addInteractiveTarget(container);
        },
        _removePath: function _removePath(layer) {
            var container = layer._container;
            remove(container);
            layer.removeInteractiveTarget(container);
            delete this._layers[stamp(layer)];
        },
        _updateStyle: function _updateStyle(layer) {
            var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
            container.stroked = !!options.stroke;
            container.filled = !!options.fill;
            if (options.stroke) {
                if (!stroke) stroke = layer._stroke = vmlCreate("stroke");
                container.appendChild(stroke);
                stroke.weight = options.weight + "px";
                stroke.color = options.color;
                stroke.opacity = options.opacity;
                if (options.dashArray) stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
                else stroke.dashStyle = "";
                stroke.endcap = options.lineCap.replace("butt", "flat");
                stroke.joinstyle = options.lineJoin;
            } else if (stroke) {
                container.removeChild(stroke);
                layer._stroke = null;
            }
            if (options.fill) {
                if (!fill) fill = layer._fill = vmlCreate("fill");
                container.appendChild(fill);
                fill.color = options.fillColor || options.color;
                fill.opacity = options.fillOpacity;
            } else if (fill) {
                container.removeChild(fill);
                layer._fill = null;
            }
        },
        _updateCircle: function _updateCircle(layer) {
            var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
            this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0," + 23592600);
        },
        _setPath: function _setPath(layer, path) {
            layer._path.v = path;
        },
        _bringToFront: function _bringToFront(layer) {
            toFront(layer._container);
        },
        _bringToBack: function _bringToBack(layer) {
            toBack(layer._container);
        }
    };
    var create = Browser.vml ? vmlCreate : svgCreate;
    /*
   * @class SVG
   * @inherits Renderer
   * @aka L.SVG
   *
   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](https://caniuse.com/svg), SVG is not
   * available in all web browsers, notably Android 2.x and 3.x.
   *
   * Although SVG is not available on IE7 and IE8, these browsers support
   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
   * (a now deprecated technology), and the SVG renderer will fall back to VML in
   * this case.
   *
   * @example
   *
   * Use SVG by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.svg()
   * });
   * ```
   *
   * Use a SVG renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.svg({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */ var SVG = Renderer.extend({
        _initContainer: function _initContainer() {
            this._container = create("svg");
            // makes it possible to click through svg root; we'll reset it back in individual paths
            this._container.setAttribute("pointer-events", "none");
            this._rootGroup = create("g");
            this._container.appendChild(this._rootGroup);
        },
        _destroyContainer: function _destroyContainer() {
            remove(this._container);
            off(this._container);
            delete this._container;
            delete this._rootGroup;
            delete this._svgSize;
        },
        _update: function _update() {
            if (this._map._animatingZoom && this._bounds) return;
            Renderer.prototype._update.call(this);
            var b = this._bounds, size = b.getSize(), container = this._container;
            // set size of svg-container if changed
            if (!this._svgSize || !this._svgSize.equals(size)) {
                this._svgSize = size;
                container.setAttribute("width", size.x);
                container.setAttribute("height", size.y);
            }
            // movement: update container viewBox so that we don't have to change coordinates of individual layers
            setPosition(container, b.min);
            container.setAttribute("viewBox", [
                b.min.x,
                b.min.y,
                size.x,
                size.y
            ].join(" "));
            this.fire("update");
        },
        // methods below are called by vector layers implementations
        _initPath: function _initPath(layer) {
            var path = layer._path = create("path");
            // @namespace Path
            // @option className: String = null
            // Custom class name set on an element. Only for SVG renderer.
            if (layer.options.className) addClass(path, layer.options.className);
            if (layer.options.interactive) addClass(path, "leaflet-interactive");
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
        },
        _addPath: function _addPath(layer) {
            if (!this._rootGroup) this._initContainer();
            this._rootGroup.appendChild(layer._path);
            layer.addInteractiveTarget(layer._path);
        },
        _removePath: function _removePath(layer) {
            remove(layer._path);
            layer.removeInteractiveTarget(layer._path);
            delete this._layers[stamp(layer)];
        },
        _updatePath: function _updatePath(layer) {
            layer._project();
            layer._update();
        },
        _updateStyle: function _updateStyle(layer) {
            var path = layer._path, options = layer.options;
            if (!path) return;
            if (options.stroke) {
                path.setAttribute("stroke", options.color);
                path.setAttribute("stroke-opacity", options.opacity);
                path.setAttribute("stroke-width", options.weight);
                path.setAttribute("stroke-linecap", options.lineCap);
                path.setAttribute("stroke-linejoin", options.lineJoin);
                if (options.dashArray) path.setAttribute("stroke-dasharray", options.dashArray);
                else path.removeAttribute("stroke-dasharray");
                if (options.dashOffset) path.setAttribute("stroke-dashoffset", options.dashOffset);
                else path.removeAttribute("stroke-dashoffset");
            } else path.setAttribute("stroke", "none");
            if (options.fill) {
                path.setAttribute("fill", options.fillColor || options.color);
                path.setAttribute("fill-opacity", options.fillOpacity);
                path.setAttribute("fill-rule", options.fillRule || "evenodd");
            } else path.setAttribute("fill", "none");
        },
        _updatePoly: function _updatePoly(layer, closed) {
            this._setPath(layer, pointsToPath(layer._parts, closed));
        },
        _updateCircle: function _updateCircle(layer) {
            var p = layer._point, r = Math.max(Math.round(layer._radius), 1), r2 = Math.max(Math.round(layer._radiusY), 1) || r, arc = "a" + r + "," + r2 + " 0 1,0 ";
            // drawing a circle with two half-arcs
            var d = layer._empty() ? "M0 0" : "M" + (p.x - r) + "," + p.y + arc + r * 2 + ",0 " + arc + -r * 2 + ",0 ";
            this._setPath(layer, d);
        },
        _setPath: function _setPath(layer, path) {
            layer._path.setAttribute("d", path);
        },
        // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
        _bringToFront: function _bringToFront(layer) {
            toFront(layer._path);
        },
        _bringToBack: function _bringToBack(layer) {
            toBack(layer._path);
        }
    });
    if (Browser.vml) SVG.include(vmlMixin);
    // @namespace SVG
    // @factory L.svg(options?: Renderer options)
    // Creates a SVG renderer with the given options.
    function svg(options) {
        return Browser.svg || Browser.vml ? new SVG(options) : null;
    }
    Map.include({
        // @namespace Map; @method getRenderer(layer: Path): Renderer
        // Returns the instance of `Renderer` that should be used to render the given
        // `Path`. It will ensure that the `renderer` options of the map and paths
        // are respected, and that the renderers do exist on the map.
        getRenderer: function getRenderer(layer) {
            // @namespace Path; @option renderer: Renderer
            // Use this specific instance of `Renderer` for this path. Takes
            // precedence over the map's [default renderer](#map-renderer).
            var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
            if (!renderer) renderer = this._renderer = this._createRenderer();
            if (!this.hasLayer(renderer)) this.addLayer(renderer);
            return renderer;
        },
        _getPaneRenderer: function _getPaneRenderer(name) {
            if (name === "overlayPane" || name === undefined) return false;
            var renderer = this._paneRenderers[name];
            if (renderer === undefined) {
                renderer = this._createRenderer({
                    pane: name
                });
                this._paneRenderers[name] = renderer;
            }
            return renderer;
        },
        _createRenderer: function _createRenderer(options) {
            // @namespace Map; @option preferCanvas: Boolean = false
            // Whether `Path`s should be rendered on a `Canvas` renderer.
            // By default, all `Path`s are rendered in a `SVG` renderer.
            return this.options.preferCanvas && canvas(options) || svg(options);
        }
    });
    /*
   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
   */ /*
   * @class Rectangle
   * @aka L.Rectangle
   * @inherits Polygon
   *
   * A class for drawing rectangle overlays on a map. Extends `Polygon`.
   *
   * @example
   *
   * ```js
   * // define rectangle geographical bounds
   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
   *
   * // create an orange rectangle
   * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
   *
   * // zoom the map to the rectangle bounds
   * map.fitBounds(bounds);
   * ```
   *
   */ var Rectangle = Polygon.extend({
        initialize: function initialize(latLngBounds, options) {
            Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
        },
        // @method setBounds(latLngBounds: LatLngBounds): this
        // Redraws the rectangle with the passed bounds.
        setBounds: function setBounds(latLngBounds) {
            return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
        },
        _boundsToLatLngs: function _boundsToLatLngs(latLngBounds) {
            latLngBounds = toLatLngBounds(latLngBounds);
            return [
                latLngBounds.getSouthWest(),
                latLngBounds.getNorthWest(),
                latLngBounds.getNorthEast(),
                latLngBounds.getSouthEast()
            ];
        }
    });
    // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
    function rectangle(latLngBounds, options) {
        return new Rectangle(latLngBounds, options);
    }
    SVG.create = create;
    SVG.pointsToPath = pointsToPath;
    GeoJSON.geometryToLayer = geometryToLayer;
    GeoJSON.coordsToLatLng = coordsToLatLng;
    GeoJSON.coordsToLatLngs = coordsToLatLngs;
    GeoJSON.latLngToCoords = latLngToCoords;
    GeoJSON.latLngsToCoords = latLngsToCoords;
    GeoJSON.getFeature = getFeature;
    GeoJSON.asFeature = asFeature;
    /*
   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
   * (zoom to a selected bounding box), enabled by default.
   */ // @namespace Map
    // @section Interaction Options
    Map.mergeOptions({
        // @option boxZoom: Boolean = true
        // Whether the map can be zoomed to a rectangular area specified by
        // dragging the mouse while pressing the shift key.
        boxZoom: true
    });
    var BoxZoom = Handler.extend({
        initialize: function initialize(map) {
            this._map = map;
            this._container = map._container;
            this._pane = map._panes.overlayPane;
            this._resetStateTimeout = 0;
            map.on("unload", this._destroy, this);
        },
        addHooks: function addHooks() {
            on(this._container, "mousedown", this._onMouseDown, this);
        },
        removeHooks: function removeHooks() {
            off(this._container, "mousedown", this._onMouseDown, this);
        },
        moved: function moved() {
            return this._moved;
        },
        _destroy: function _destroy() {
            remove(this._pane);
            delete this._pane;
        },
        _resetState: function _resetState() {
            this._resetStateTimeout = 0;
            this._moved = false;
        },
        _clearDeferredResetState: function _clearDeferredResetState() {
            if (this._resetStateTimeout !== 0) {
                clearTimeout(this._resetStateTimeout);
                this._resetStateTimeout = 0;
            }
        },
        _onMouseDown: function _onMouseDown(e) {
            if (!e.shiftKey || e.which !== 1 && e.button !== 1) return false;
            // Clear the deferred resetState if it hasn't executed yet, otherwise it
            // will interrupt the interaction and orphan a box element in the container.
            this._clearDeferredResetState();
            this._resetState();
            disableTextSelection();
            disableImageDrag();
            this._startPoint = this._map.mouseEventToContainerPoint(e);
            on(document, {
                contextmenu: stop,
                mousemove: this._onMouseMove,
                mouseup: this._onMouseUp,
                keydown: this._onKeyDown
            }, this);
        },
        _onMouseMove: function _onMouseMove(e) {
            if (!this._moved) {
                this._moved = true;
                this._box = create$1("div", "leaflet-zoom-box", this._container);
                addClass(this._container, "leaflet-crosshair");
                this._map.fire("boxzoomstart");
            }
            this._point = this._map.mouseEventToContainerPoint(e);
            var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
            setPosition(this._box, bounds.min);
            this._box.style.width = size.x + "px";
            this._box.style.height = size.y + "px";
        },
        _finish: function _finish() {
            if (this._moved) {
                remove(this._box);
                removeClass(this._container, "leaflet-crosshair");
            }
            enableTextSelection();
            enableImageDrag();
            off(document, {
                contextmenu: stop,
                mousemove: this._onMouseMove,
                mouseup: this._onMouseUp,
                keydown: this._onKeyDown
            }, this);
        },
        _onMouseUp: function _onMouseUp(e) {
            if (e.which !== 1 && e.button !== 1) return;
            this._finish();
            if (!this._moved) return;
            // Postpone to next JS tick so internal click event handling
            // still see it as "moved".
            this._clearDeferredResetState();
            this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
            var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));
            this._map.fitBounds(bounds).fire("boxzoomend", {
                boxZoomBounds: bounds
            });
        },
        _onKeyDown: function _onKeyDown(e) {
            if (e.keyCode === 27) {
                this._finish();
                this._clearDeferredResetState();
                this._resetState();
            }
        }
    });
    // @section Handlers
    // @property boxZoom: Handler
    // Box (shift-drag with mouse) zoom handler.
    Map.addInitHook("addHandler", "boxZoom", BoxZoom);
    /*
   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
   */ // @namespace Map
    // @section Interaction Options
    Map.mergeOptions({
        // @option doubleClickZoom: Boolean|String = true
        // Whether the map can be zoomed in by double clicking on it and
        // zoomed out by double clicking while holding shift. If passed
        // `'center'`, double-click zoom will zoom to the center of the
        //  view regardless of where the mouse was.
        doubleClickZoom: true
    });
    var DoubleClickZoom = Handler.extend({
        addHooks: function addHooks() {
            this._map.on("dblclick", this._onDoubleClick, this);
        },
        removeHooks: function removeHooks() {
            this._map.off("dblclick", this._onDoubleClick, this);
        },
        _onDoubleClick: function _onDoubleClick(e) {
            var map = this._map, oldZoom = map.getZoom(), delta = map.options.zoomDelta, zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
            if (map.options.doubleClickZoom === "center") map.setZoom(zoom);
            else map.setZoomAround(e.containerPoint, zoom);
        }
    });
    // @section Handlers
    //
    // Map properties include interaction handlers that allow you to control
    // interaction behavior in runtime, enabling or disabling certain features such
    // as dragging or touch zoom (see `Handler` methods). For example:
    //
    // ```js
    // map.doubleClickZoom.disable();
    // ```
    //
    // @property doubleClickZoom: Handler
    // Double click zoom handler.
    Map.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
    /*
   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
   */ // @namespace Map
    // @section Interaction Options
    Map.mergeOptions({
        // @option dragging: Boolean = true
        // Whether the map is draggable with mouse/touch or not.
        dragging: true,
        // @section Panning Inertia Options
        // @option inertia: Boolean = *
        // If enabled, panning of the map will have an inertia effect where
        // the map builds momentum while dragging and continues moving in
        // the same direction for some time. Feels especially nice on touch
        // devices. Enabled by default.
        inertia: true,
        // @option inertiaDeceleration: Number = 3000
        // The rate with which the inertial movement slows down, in pixels/second.
        inertiaDeceleration: 3400,
        // @option inertiaMaxSpeed: Number = Infinity
        // Max speed of the inertial movement, in pixels/second.
        inertiaMaxSpeed: Infinity,
        // @option easeLinearity: Number = 0.2
        easeLinearity: 0.2,
        // TODO refactor, move to CRS
        // @option worldCopyJump: Boolean = false
        // With this option enabled, the map tracks when you pan to another "copy"
        // of the world and seamlessly jumps to the original one so that all overlays
        // like markers and vector layers are still visible.
        worldCopyJump: false,
        // @option maxBoundsViscosity: Number = 0.0
        // If `maxBounds` is set, this option will control how solid the bounds
        // are when dragging the map around. The default value of `0.0` allows the
        // user to drag outside the bounds at normal speed, higher values will
        // slow down map dragging outside bounds, and `1.0` makes the bounds fully
        // solid, preventing the user from dragging outside the bounds.
        maxBoundsViscosity: 0.0
    });
    var Drag = Handler.extend({
        addHooks: function addHooks() {
            if (!this._draggable) {
                var map = this._map;
                this._draggable = new Draggable(map._mapPane, map._container);
                this._draggable.on({
                    dragstart: this._onDragStart,
                    drag: this._onDrag,
                    dragend: this._onDragEnd
                }, this);
                this._draggable.on("predrag", this._onPreDragLimit, this);
                if (map.options.worldCopyJump) {
                    this._draggable.on("predrag", this._onPreDragWrap, this);
                    map.on("zoomend", this._onZoomEnd, this);
                    map.whenReady(this._onZoomEnd, this);
                }
            }
            addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
            this._draggable.enable();
            this._positions = [];
            this._times = [];
        },
        removeHooks: function removeHooks() {
            removeClass(this._map._container, "leaflet-grab");
            removeClass(this._map._container, "leaflet-touch-drag");
            this._draggable.disable();
        },
        moved: function moved() {
            return this._draggable && this._draggable._moved;
        },
        moving: function moving() {
            return this._draggable && this._draggable._moving;
        },
        _onDragStart: function _onDragStart() {
            var map = this._map;
            map._stop();
            if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
                var bounds = toLatLngBounds(this._map.options.maxBounds);
                this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));
                this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
            } else this._offsetLimit = null;
            map.fire("movestart").fire("dragstart");
            if (map.options.inertia) {
                this._positions = [];
                this._times = [];
            }
        },
        _onDrag: function _onDrag(e) {
            if (this._map.options.inertia) {
                var time = this._lastTime = +new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
                this._positions.push(pos);
                this._times.push(time);
                this._prunePositions(time);
            }
            this._map.fire("move", e).fire("drag", e);
        },
        _prunePositions: function _prunePositions(time) {
            while(this._positions.length > 1 && time - this._times[0] > 50){
                this._positions.shift();
                this._times.shift();
            }
        },
        _onZoomEnd: function _onZoomEnd() {
            var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([
                0,
                0
            ]);
            this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
            this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
        },
        _viscousLimit: function _viscousLimit(value, threshold) {
            return value - (value - threshold) * this._viscosity;
        },
        _onPreDragLimit: function _onPreDragLimit() {
            if (!this._viscosity || !this._offsetLimit) return;
            var offset = this._draggable._newPos.subtract(this._draggable._startPos);
            var limit = this._offsetLimit;
            if (offset.x < limit.min.x) offset.x = this._viscousLimit(offset.x, limit.min.x);
            if (offset.y < limit.min.y) offset.y = this._viscousLimit(offset.y, limit.min.y);
            if (offset.x > limit.max.x) offset.x = this._viscousLimit(offset.x, limit.max.x);
            if (offset.y > limit.max.y) offset.y = this._viscousLimit(offset.y, limit.max.y);
            this._draggable._newPos = this._draggable._startPos.add(offset);
        },
        _onPreDragWrap: function _onPreDragWrap() {
            // TODO refactor to be able to adjust map pane position after zoom
            var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
            this._draggable._absPos = this._draggable._newPos.clone();
            this._draggable._newPos.x = newX;
        },
        _onDragEnd: function _onDragEnd(e) {
            var map = this._map, options = map.options, noInertia = !options.inertia || e.noInertia || this._times.length < 2;
            map.fire("dragend", e);
            if (noInertia) map.fire("moveend");
            else {
                this._prunePositions(+new Date());
                var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1000, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([
                    0,
                    0
                ]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
                if (!offset.x && !offset.y) map.fire("moveend");
                else {
                    offset = map._limitOffset(offset, map.options.maxBounds);
                    requestAnimFrame(function() {
                        map.panBy(offset, {
                            duration: decelerationDuration,
                            easeLinearity: ease,
                            noMoveStart: true,
                            animate: true
                        });
                    });
                }
            }
        }
    });
    // @section Handlers
    // @property dragging: Handler
    // Map dragging handler (by both mouse and touch).
    Map.addInitHook("addHandler", "dragging", Drag);
    /*
   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
   */ // @namespace Map
    // @section Keyboard Navigation Options
    Map.mergeOptions({
        // @option keyboard: Boolean = true
        // Makes the map focusable and allows users to navigate the map with keyboard
        // arrows and `+`/`-` keys.
        keyboard: true,
        // @option keyboardPanDelta: Number = 80
        // Amount of pixels to pan when pressing an arrow key.
        keyboardPanDelta: 80
    });
    var Keyboard = Handler.extend({
        keyCodes: {
            left: [
                37
            ],
            right: [
                39
            ],
            down: [
                40
            ],
            up: [
                38
            ],
            zoomIn: [
                187,
                107,
                61,
                171
            ],
            zoomOut: [
                189,
                109,
                54,
                173
            ]
        },
        initialize: function initialize(map) {
            this._map = map;
            this._setPanDelta(map.options.keyboardPanDelta);
            this._setZoomDelta(map.options.zoomDelta);
        },
        addHooks: function addHooks() {
            var container = this._map._container;
            // make the container focusable by tabbing
            if (container.tabIndex <= 0) container.tabIndex = "0";
            on(container, {
                focus: this._onFocus,
                blur: this._onBlur,
                mousedown: this._onMouseDown
            }, this);
            this._map.on({
                focus: this._addHooks,
                blur: this._removeHooks
            }, this);
        },
        removeHooks: function removeHooks() {
            this._removeHooks();
            off(this._map._container, {
                focus: this._onFocus,
                blur: this._onBlur,
                mousedown: this._onMouseDown
            }, this);
            this._map.off({
                focus: this._addHooks,
                blur: this._removeHooks
            }, this);
        },
        _onMouseDown: function _onMouseDown() {
            if (this._focused) return;
            var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
            this._map._container.focus();
            window.scrollTo(left, top);
        },
        _onFocus: function _onFocus() {
            this._focused = true;
            this._map.fire("focus");
        },
        _onBlur: function _onBlur() {
            this._focused = false;
            this._map.fire("blur");
        },
        _setPanDelta: function _setPanDelta(panDelta) {
            var keys = this._panKeys = {}, codes = this.keyCodes, i, len;
            for(i = 0, len = codes.left.length; i < len; i++)keys[codes.left[i]] = [
                -1 * panDelta,
                0
            ];
            for(i = 0, len = codes.right.length; i < len; i++)keys[codes.right[i]] = [
                panDelta,
                0
            ];
            for(i = 0, len = codes.down.length; i < len; i++)keys[codes.down[i]] = [
                0,
                panDelta
            ];
            for(i = 0, len = codes.up.length; i < len; i++)keys[codes.up[i]] = [
                0,
                -1 * panDelta
            ];
        },
        _setZoomDelta: function _setZoomDelta(zoomDelta) {
            var keys = this._zoomKeys = {}, codes = this.keyCodes, i, len;
            for(i = 0, len = codes.zoomIn.length; i < len; i++)keys[codes.zoomIn[i]] = zoomDelta;
            for(i = 0, len = codes.zoomOut.length; i < len; i++)keys[codes.zoomOut[i]] = -zoomDelta;
        },
        _addHooks: function _addHooks() {
            on(document, "keydown", this._onKeyDown, this);
        },
        _removeHooks: function _removeHooks() {
            off(document, "keydown", this._onKeyDown, this);
        },
        _onKeyDown: function _onKeyDown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            var key = e.keyCode, map = this._map, offset;
            if (key in this._panKeys) {
                if (!map._panAnim || !map._panAnim._inProgress) {
                    offset = this._panKeys[key];
                    if (e.shiftKey) offset = toPoint(offset).multiplyBy(3);
                    if (map.options.maxBounds) offset = map._limitOffset(toPoint(offset), map.options.maxBounds);
                    if (map.options.worldCopyJump) {
                        var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));
                        map.panTo(newLatLng);
                    } else map.panBy(offset);
                }
            } else if (key in this._zoomKeys) map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
            else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) map.closePopup();
            else return;
            stop(e);
        }
    });
    // @section Handlers
    // @section Handlers
    // @property keyboard: Handler
    // Keyboard navigation handler.
    Map.addInitHook("addHandler", "keyboard", Keyboard);
    /*
   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
   */ // @namespace Map
    // @section Interaction Options
    Map.mergeOptions({
        // @section Mouse wheel options
        // @option scrollWheelZoom: Boolean|String = true
        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
        // it will zoom to the center of the view regardless of where the mouse was.
        scrollWheelZoom: true,
        // @option wheelDebounceTime: Number = 40
        // Limits the rate at which a wheel can fire (in milliseconds). By default
        // user can't zoom via wheel more often than once per 40 ms.
        wheelDebounceTime: 40,
        // @option wheelPxPerZoomLevel: Number = 60
        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
        // mean a change of one full zoom level. Smaller values will make wheel-zooming
        // faster (and vice versa).
        wheelPxPerZoomLevel: 60
    });
    var ScrollWheelZoom = Handler.extend({
        addHooks: function addHooks() {
            on(this._map._container, "wheel", this._onWheelScroll, this);
            this._delta = 0;
        },
        removeHooks: function removeHooks() {
            off(this._map._container, "wheel", this._onWheelScroll, this);
        },
        _onWheelScroll: function _onWheelScroll(e) {
            var delta = getWheelDelta(e);
            var debounce = this._map.options.wheelDebounceTime;
            this._delta += delta;
            this._lastMousePos = this._map.mouseEventToContainerPoint(e);
            if (!this._startTime) this._startTime = +new Date();
            var left = Math.max(debounce - (+new Date() - this._startTime), 0);
            clearTimeout(this._timer);
            this._timer = setTimeout(bind(this._performZoom, this), left);
            stop(e);
        },
        _performZoom: function _performZoom() {
            var map = this._map, zoom = map.getZoom(), snap = this._map.options.zoomSnap || 0;
            map._stop(); // stop panning and fly animations if any
            // map the delta with a sigmoid function to -4..4 range leaning on -1..1
            var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;
            this._delta = 0;
            this._startTime = null;
            if (!delta) return;
            if (map.options.scrollWheelZoom === "center") map.setZoom(zoom + delta);
            else map.setZoomAround(this._lastMousePos, zoom + delta);
        }
    });
    // @section Handlers
    // @property scrollWheelZoom: Handler
    // Scroll wheel zoom handler.
    Map.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
    /*
   * L.Map.TapHold is used to simulate `contextmenu` event on long hold,
   * which otherwise is not fired by mobile Safari.
   */ var tapHoldDelay = 600;
    // @namespace Map
    // @section Interaction Options
    Map.mergeOptions({
        // @section Touch interaction options
        // @option tapHold: Boolean
        // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
        tapHold: Browser.touchNative && Browser.safari && Browser.mobile,
        // @option tapTolerance: Number = 15
        // The max number of pixels a user can shift his finger during touch
        // for it to be considered a valid tap.
        tapTolerance: 15
    });
    var TapHold = Handler.extend({
        addHooks: function addHooks() {
            on(this._map._container, "touchstart", this._onDown, this);
        },
        removeHooks: function removeHooks() {
            off(this._map._container, "touchstart", this._onDown, this);
        },
        _onDown: function _onDown(e) {
            clearTimeout(this._holdTimeout);
            if (e.touches.length !== 1) return;
            var first = e.touches[0];
            this._startPos = this._newPos = new Point(first.clientX, first.clientY);
            this._holdTimeout = setTimeout(bind(function() {
                this._cancel();
                if (!this._isTapValid()) return;
                // prevent simulated mouse events https://w3c.github.io/touch-events/#mouse-events
                on(document, "touchend", preventDefault);
                on(document, "touchend touchcancel", this._cancelClickPrevent);
                this._simulateEvent("contextmenu", first);
            }, this), tapHoldDelay);
            on(document, "touchend touchcancel contextmenu", this._cancel, this);
            on(document, "touchmove", this._onMove, this);
        },
        _cancelClickPrevent: function cancelClickPrevent() {
            off(document, "touchend", preventDefault);
            off(document, "touchend touchcancel", cancelClickPrevent);
        },
        _cancel: function _cancel() {
            clearTimeout(this._holdTimeout);
            off(document, "touchend touchcancel contextmenu", this._cancel, this);
            off(document, "touchmove", this._onMove, this);
        },
        _onMove: function _onMove(e) {
            var first = e.touches[0];
            this._newPos = new Point(first.clientX, first.clientY);
        },
        _isTapValid: function _isTapValid() {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
        },
        _simulateEvent: function _simulateEvent(type, e) {
            var simulatedEvent = new MouseEvent(type, {
                bubbles: true,
                cancelable: true,
                view: window,
                // detail: 1,
                screenX: e.screenX,
                screenY: e.screenY,
                clientX: e.clientX,
                clientY: e.clientY
            });
            simulatedEvent._simulated = true;
            e.target.dispatchEvent(simulatedEvent);
        }
    });
    // @section Handlers
    // @property tapHold: Handler
    // Long tap handler to simulate `contextmenu` event (useful in mobile Safari).
    Map.addInitHook("addHandler", "tapHold", TapHold);
    /*
   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
   */ // @namespace Map
    // @section Interaction Options
    Map.mergeOptions({
        // @section Touch interaction options
        // @option touchZoom: Boolean|String = *
        // Whether the map can be zoomed by touch-dragging with two fingers. If
        // passed `'center'`, it will zoom to the center of the view regardless of
        // where the touch events (fingers) were. Enabled for touch-capable web
        // browsers.
        touchZoom: Browser.touch,
        // @option bounceAtZoomLimits: Boolean = true
        // Set it to false if you don't want the map to zoom beyond min/max zoom
        // and then bounce back when pinch-zooming.
        bounceAtZoomLimits: true
    });
    var TouchZoom = Handler.extend({
        addHooks: function addHooks() {
            addClass(this._map._container, "leaflet-touch-zoom");
            on(this._map._container, "touchstart", this._onTouchStart, this);
        },
        removeHooks: function removeHooks() {
            removeClass(this._map._container, "leaflet-touch-zoom");
            off(this._map._container, "touchstart", this._onTouchStart, this);
        },
        _onTouchStart: function _onTouchStart(e) {
            var map = this._map;
            if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) return;
            var p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]);
            this._centerPoint = map.getSize()._divideBy(2);
            this._startLatLng = map.containerPointToLatLng(this._centerPoint);
            if (map.options.touchZoom !== "center") this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
            this._startDist = p1.distanceTo(p2);
            this._startZoom = map.getZoom();
            this._moved = false;
            this._zooming = true;
            map._stop();
            on(document, "touchmove", this._onTouchMove, this);
            on(document, "touchend touchcancel", this._onTouchEnd, this);
            preventDefault(e);
        },
        _onTouchMove: function _onTouchMove(e) {
            if (!e.touches || e.touches.length !== 2 || !this._zooming) return;
            var map = this._map, p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]), scale = p1.distanceTo(p2) / this._startDist;
            this._zoom = map.getScaleZoom(scale, this._startZoom);
            if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) this._zoom = map._limitZoom(this._zoom);
            if (map.options.touchZoom === "center") {
                this._center = this._startLatLng;
                if (scale === 1) return;
            } else {
                // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
                var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
                if (scale === 1 && delta.x === 0 && delta.y === 0) return;
                this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
            }
            if (!this._moved) {
                map._moveStart(true, false);
                this._moved = true;
            }
            cancelAnimFrame(this._animRequest);
            var moveFn = bind(map._move, map, this._center, this._zoom, {
                pinch: true,
                round: false
            }, undefined);
            this._animRequest = requestAnimFrame(moveFn, this, true);
            preventDefault(e);
        },
        _onTouchEnd: function _onTouchEnd() {
            if (!this._moved || !this._zooming) {
                this._zooming = false;
                return;
            }
            this._zooming = false;
            cancelAnimFrame(this._animRequest);
            off(document, "touchmove", this._onTouchMove, this);
            off(document, "touchend touchcancel", this._onTouchEnd, this);
            // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
            if (this._map.options.zoomAnimation) this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
            else this._map._resetView(this._center, this._map._limitZoom(this._zoom));
        }
    });
    // @section Handlers
    // @property touchZoom: Handler
    // Touch zoom handler.
    Map.addInitHook("addHandler", "touchZoom", TouchZoom);
    Map.BoxZoom = BoxZoom;
    Map.DoubleClickZoom = DoubleClickZoom;
    Map.Drag = Drag;
    Map.Keyboard = Keyboard;
    Map.ScrollWheelZoom = ScrollWheelZoom;
    Map.TapHold = TapHold;
    Map.TouchZoom = TouchZoom;
    exports1.Bounds = Bounds;
    exports1.Browser = Browser;
    exports1.CRS = CRS;
    exports1.Canvas = Canvas;
    exports1.Circle = Circle;
    exports1.CircleMarker = CircleMarker;
    exports1.Class = Class;
    exports1.Control = Control;
    exports1.DivIcon = DivIcon;
    exports1.DivOverlay = DivOverlay;
    exports1.DomEvent = DomEvent;
    exports1.DomUtil = DomUtil;
    exports1.Draggable = Draggable;
    exports1.Evented = Evented;
    exports1.FeatureGroup = FeatureGroup;
    exports1.GeoJSON = GeoJSON;
    exports1.GridLayer = GridLayer;
    exports1.Handler = Handler;
    exports1.Icon = Icon;
    exports1.ImageOverlay = ImageOverlay;
    exports1.LatLng = LatLng;
    exports1.LatLngBounds = LatLngBounds;
    exports1.Layer = Layer;
    exports1.LayerGroup = LayerGroup;
    exports1.LineUtil = LineUtil;
    exports1.Map = Map;
    exports1.Marker = Marker;
    exports1.Mixin = Mixin;
    exports1.Path = Path;
    exports1.Point = Point;
    exports1.PolyUtil = PolyUtil;
    exports1.Polygon = Polygon;
    exports1.Polyline = Polyline;
    exports1.Popup = Popup;
    exports1.PosAnimation = PosAnimation;
    exports1.Projection = index;
    exports1.Rectangle = Rectangle;
    exports1.Renderer = Renderer;
    exports1.SVG = SVG;
    exports1.SVGOverlay = SVGOverlay;
    exports1.TileLayer = TileLayer;
    exports1.Tooltip = Tooltip;
    exports1.Transformation = Transformation;
    exports1.Util = Util;
    exports1.VideoOverlay = VideoOverlay;
    exports1.bind = bind;
    exports1.bounds = toBounds;
    exports1.canvas = canvas;
    exports1.circle = circle;
    exports1.circleMarker = circleMarker;
    exports1.control = control;
    exports1.divIcon = divIcon;
    exports1.extend = extend;
    exports1.featureGroup = featureGroup;
    exports1.geoJSON = geoJSON;
    exports1.geoJson = geoJson;
    exports1.gridLayer = gridLayer;
    exports1.icon = icon;
    exports1.imageOverlay = imageOverlay;
    exports1.latLng = toLatLng;
    exports1.latLngBounds = toLatLngBounds;
    exports1.layerGroup = layerGroup;
    exports1.map = createMap;
    exports1.marker = marker;
    exports1.point = toPoint;
    exports1.polygon = polygon;
    exports1.polyline = polyline;
    exports1.popup = popup;
    exports1.rectangle = rectangle;
    exports1.setOptions = setOptions;
    exports1.stamp = stamp;
    exports1.svg = svg;
    exports1.svgOverlay = svgOverlay;
    exports1.tileLayer = tileLayer;
    exports1.tooltip = tooltip;
    exports1.transformation = toTransformation;
    exports1.version = version;
    exports1.videoOverlay = videoOverlay;
    var oldL = window.L;
    exports1.noConflict = function() {
        window.L = oldL;
        return this;
    };
    // Always export us to window global (see #2364)
    window.L = exports1;
});

},{"@swc/helpers/_/_type_of":"b4wfg"}],"fuBEK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "renderMap", function() {
    return renderMap;
});
parcelHelpers.export(exports, "addMemories", function() {
    return addMemories;
});
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _toConsumableArray = require("@swc/helpers/_/_to_consumable_array");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var _leaflet = require("leaflet");
var _leafletDefault = parcelHelpers.interopDefault(_leaflet);
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _routeChanger = require("./routeChanger");
var _sweetalert2 = require("sweetalert2");
var _sweetalert2Default = parcelHelpers.interopDefault(_sweetalert2);
var map, reversedCoordinates;
// inputs
var memoriesForm = document.querySelector(".memories-inputs");
var inputLocation = document.querySelector(".memories-location");
var inputDescription = document.querySelector(".memories-description");
var inputDate = document.querySelector(".memories-date");
var inputImages = document.getElementById("file");
// error labels
var errorLocationLabel = document.querySelector(".err-message-location");
var errorDescriptionlabel = document.querySelector(".err-message-description");
var errImgLabel = document.querySelector(".err-message-photo");
var errorDateLabel = document.querySelector(".err-message-date.message");
var clearingErrors = function clearingErrors() {
    errorDateLabel.textContent = errorDescriptionlabel.textContent = errorLocationLabel.textContent = "";
};
// adding marker to map according to location(encapsulated function)
var addMarker = function() {
    var _ref = (0, _asyncToGenerator._)(function(locationValue) {
        var _data_data_features__geometry, _data_data_features_, data, _data_data_features__geometry_coordinates, coordinates, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    _state.trys.push([
                        0,
                        2,
                        ,
                        3
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)("https://api.geoapify.com/v1/geocode/search?city=".concat(locationValue, "&apiKey=857d4394470d41e5a3577c123b68b803"))
                    ];
                case 1:
                    data = _state.sent();
                    coordinates = (_data_data_features__geometry_coordinates = (_data_data_features_ = data.data.features[0]) === null || _data_data_features_ === void 0 ? void 0 : (_data_data_features__geometry = _data_data_features_.geometry) === null || _data_data_features__geometry === void 0 ? void 0 : _data_data_features__geometry.coordinates) !== null && _data_data_features__geometry_coordinates !== void 0 ? _data_data_features__geometry_coordinates : null;
                    if (!coordinates) return [
                        2,
                        errorLocationLabel.textContent = "Please enter a valid city"
                    ];
                    reversedCoordinates = (0, _toConsumableArray._)(coordinates).reverse();
                    // render lat and lng to map
                    map.setView(reversedCoordinates, 13, {
                        animate: true
                    });
                    (0, _leafletDefault.default).marker(reversedCoordinates).addTo(map);
                    return [
                        3,
                        3
                    ];
                case 2:
                    err = _state.sent();
                    throw err;
                case 3:
                    return [
                        2
                    ];
            }
        });
    });
    return function addMarker(locationValue) {
        return _ref.apply(this, arguments);
    };
}();
var showError = function showError(err) {
    console.log(err);
    err.forEach(function(err) {
        if (err.path === "photo") errImgLabel.textContent = err.message;
        if (err.path === "location") errorLocationLabel.textContent = err.message;
        if (err.path === "description") errorDescriptionlabel.textContent = err.message;
        if (err.path === "date") errorDateLabel.textContent = err.message;
    });
};
var renderMap = function renderMap() {
    // creating map object
    map = (0, _leafletDefault.default).map("map", {
        zoomControl: false,
        attributionControl: false
    }).setView([
        51.505,
        -0.09
    ], 13);
    //   setting tile layer for map
    (0, _leafletDefault.default).tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);
};
var addMemories = function() {
    var _ref = (0, _asyncToGenerator._)(function(e) {
        var locationValue, descriptionValue, dateValue, image, form, res, err, _err_response_data, _err_response, error;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    // check inputs are valid
                    locationValue = inputLocation.value.toLowerCase();
                    descriptionValue = inputDescription.value;
                    dateValue = inputDate.value;
                    image = inputImages.files[0];
                    console.log(locationValue, descriptionValue, dateValue, image);
                    if (!memoriesForm.checkValidity()) return [
                        2
                    ];
                    e.preventDefault();
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        4,
                        ,
                        5
                    ]);
                    // adding marker to location
                    return [
                        4,
                        addMarker(locationValue)
                    ];
                case 2:
                    _state.sent();
                    // save to database
                    form = new FormData();
                    form.append("location", locationValue);
                    form.append("description", descriptionValue);
                    form.append("date", dateValue);
                    form.append("profileImg", image);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "PATCH",
                            url: "/api/v1/users/memories",
                            data: form
                        })
                    ];
                case 3:
                    res = _state.sent();
                    console.log(res);
                    //clearing all errors if succesfull
                    clearingErrors();
                    // alert for success
                    (0, _sweetalert2Default.default).fire("Memories succesfully added");
                    // changing route
                    (0, _routeChanger.routeChanger)("/profile");
                    return [
                        3,
                        5
                    ];
                case 4:
                    err = _state.sent();
                    console.log(err.response.data);
                    // clearingErrors;
                    clearingErrors();
                    error = err === null || err === void 0 ? void 0 : (_err_response = err.response) === null || _err_response === void 0 ? void 0 : (_err_response_data = _err_response.data) === null || _err_response_data === void 0 ? void 0 : _err_response_data.errInfo;
                    showError(error);
                    return [
                        3,
                        5
                    ];
                case 5:
                    return [
                        2
                    ];
            }
        });
    });
    return function addMemories(e) {
        return _ref.apply(this, arguments);
    };
}();

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_to_consumable_array":"ig3r6","@swc/helpers/_/_ts_generator":"dhhs4","leaflet":"97rBD","axios":"eCZhQ","./routeChanger":"ful9o","sweetalert2":"2OR50","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"9QfUV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sendRestPasswordLink", function() {
    return sendRestPasswordLink;
});
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _sweetalert2 = require("sweetalert2");
var _sweetalert2Default = parcelHelpers.interopDefault(_sweetalert2);
var _routeChanger = require("./routeChanger");
var sendRestPasswordLink = function() {
    var _ref = (0, _asyncToGenerator._)(function(e) {
        var form, email, errMessage, errorBox, data, message, err, message1;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    form = document.querySelector(".forget-password-form");
                    email = document.querySelector(".email").value;
                    errMessage = document.querySelector(".err-message");
                    errorBox = document.querySelector(".message-container");
                    if (!form.checkValidity()) return [
                        2
                    ];
                    e.preventDefault();
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            url: "api/v1/users/forget-password",
                            method: "POST",
                            data: {
                                email: email
                            }
                        })
                    ];
                case 2:
                    data = _state.sent();
                    errorBox.classList.remove("error-container");
                    errMessage.textContent = "Don't hesitate";
                    message = data.data.message;
                    errorBox.classList.remove("error-container");
                    errMessage.textContent = message;
                    (0, _sweetalert2Default.default).fire(message);
                    (0, _routeChanger.routeChanger)("/");
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    message1 = err.response.data.message;
                    errorBox.classList.add("error-container");
                    errMessage.textContent = message1;
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function sendRestPasswordLink(e) {
        return _ref.apply(this, arguments);
    };
}();

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_ts_generator":"dhhs4","axios":"eCZhQ","sweetalert2":"2OR50","./routeChanger":"ful9o","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"kd774":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "updatePassword", function() {
    return updatePassword;
});
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _routeChanger = require("./routeChanger");
var _sweetalert2 = require("sweetalert2");
var _sweetalert2Default = parcelHelpers.interopDefault(_sweetalert2);
var form = document.querySelector(".reset-password-form");
var updatePassword = function() {
    var _ref = (0, _asyncToGenerator._)(function(e) {
        var password, confirmPassword, confrimPasswordErrLabel, token, data, message, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    password = document.querySelector(".input-password").value;
                    confirmPassword = document.querySelector(".input-confirm-password").value;
                    confrimPasswordErrLabel = document.querySelector(".err-confirm-password-msg");
                    token = this.dataset.token;
                    if (!form.checkValidity()) return [
                        2
                    ];
                    e.preventDefault();
                    if (confirmPassword !== password) return [
                        2,
                        confrimPasswordErrLabel.textContent = "Password and confrim password are not same"
                    ];
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "PATCH",
                            url: "/api/v1/users/reset-password/".concat(token),
                            data: {
                                password: password,
                                confirmPassword: confirmPassword
                            }
                        })
                    ];
                case 2:
                    data = _state.sent();
                    message = data.data.message;
                    (0, _sweetalert2Default.default).fire(message);
                    (0, _routeChanger.routeChanger)("/");
                    route;
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    console.log(err);
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function updatePassword(e) {
        return _ref.apply(this, arguments);
    };
}();

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_ts_generator":"dhhs4","axios":"eCZhQ","./routeChanger":"ful9o","sweetalert2":"2OR50","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"85UK9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addCoupon", function() {
    return addCoupon;
});
parcelHelpers.export(exports, "editCoupon", function() {
    return editCoupon;
});
parcelHelpers.export(exports, "deleteCoupon", function() {
    return deleteCoupon;
});
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _sweetalert2 = require("sweetalert2");
var _sweetalert2Default = parcelHelpers.interopDefault(_sweetalert2);
var _routeChanger = require("./routeChanger");
var _profile = require("./profile");
var inputCouponCode = document.querySelector(".coupon-code-input");
var inputDiscount = document.querySelector(".discount-input");
var form = document.querySelector(".coupon-form");
var errorBox = document.querySelector(".message-container");
var errorMessage = document.querySelector(".error-msg");
var addCoupon = function() {
    var _ref = (0, _asyncToGenerator._)(function(e) {
        var message, res, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (!form.checkValidity()) return [
                        2
                    ];
                    e.preventDefault();
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "POST",
                            url: "/api/v1/coupons",
                            data: {
                                couponCode: inputCouponCode.value,
                                discountPercentage: inputDiscount.value
                            }
                        })
                    ];
                case 2:
                    res = _state.sent();
                    errorBox.classList.remove("error-container");
                    errorMessage.textContent = "Don't Hesitate";
                    message = res.data.message;
                    (0, _sweetalert2Default.default).fire(message);
                    (0, _routeChanger.routeChanger)("/");
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    message = err.response.data.message;
                    errorBox.classList.add("error-container");
                    errorMessage.textContent = message;
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function addCoupon(e) {
        return _ref.apply(this, arguments);
    };
}();
var editCoupon = function() {
    var _ref = (0, _asyncToGenerator._)(function(coupon) {
        var message, res, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    _state.trys.push([
                        0,
                        2,
                        ,
                        3
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "PATCH",
                            url: "/api/v1/coupons/".concat(coupon.couponId),
                            data: {
                                couponCode: coupon.coupon.id,
                                isValid: coupon.tokenValidity,
                                discountPercentage: coupon.discountPercentage
                            }
                        })
                    ];
                case 1:
                    res = _state.sent();
                    message = res.data.message;
                    (0, _sweetalert2Default.default).fire(message);
                    (0, _profile.renderCoupons)();
                    return [
                        3,
                        3
                    ];
                case 2:
                    err = _state.sent();
                    console.log(err);
                    message = "Something went wrong";
                    (0, _sweetalert2Default.default).fire(message);
                    return [
                        3,
                        3
                    ];
                case 3:
                    return [
                        2
                    ];
            }
        });
    });
    return function editCoupon(coupon) {
        return _ref.apply(this, arguments);
    };
}();
var deleteCoupon = function() {
    var _ref = (0, _asyncToGenerator._)(function(id) {
        var res, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    _state.trys.push([
                        0,
                        2,
                        ,
                        3
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "DELETE",
                            url: "/api/v1/coupons/".concat(id)
                        })
                    ];
                case 1:
                    res = _state.sent();
                    (0, _sweetalert2Default.default).fire("Coupon deleted");
                    (0, _profile.renderCoupons)();
                    return [
                        3,
                        3
                    ];
                case 2:
                    err = _state.sent();
                    console.log(err);
                    return [
                        3,
                        3
                    ];
                case 3:
                    return [
                        2
                    ];
            }
        });
    });
    return function deleteCoupon(id) {
        return _ref.apply(this, arguments);
    };
}();

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_ts_generator":"dhhs4","axios":"eCZhQ","sweetalert2":"2OR50","./routeChanger":"ful9o","./profile":"kLVhs","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}],"5N5Hk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "previewImage", function() {
    return previewImage;
});
parcelHelpers.export(exports, "renderProfile", function() {
    return renderProfile;
});
parcelHelpers.export(exports, "updateProfileDetails", function() {
    return updateProfileDetails;
});
var _asyncToGenerator = require("@swc/helpers/_/_async_to_generator");
var _tsGenerator = require("@swc/helpers/_/_ts_generator");
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _sweetalert2 = require("sweetalert2");
var _sweetalert2Default = parcelHelpers.interopDefault(_sweetalert2);
var itemsContainer = document.querySelector(".dash-board-commodity");
var date = document.querySelector(".date");
var dashboardHeading = document.querySelector(".dashboard-heading");
var now = new Date();
var isChanged = false;
var disabelBtn = function disabelBtn() {
    var btn = document.querySelector(".profile-form-btn");
    btn.disabled = !isChanged;
};
var getProfileMarkup = function getProfileMarkup(user) {
    return '<div class="user-profile"><input class="hide" id="profile-photo" type="file" name="" accept="image/*" /><label class="user-img" for="profile-photo"><img class="profile-img" src='.concat(user.profileImg, " alt=").concat(user.name, ' srcset=""/></label>\n            <form class="user-profile-form">\n                <div class="column"><label class="profile-form-label">Name </label><input class="input-text input-profile-name" type="text" placeholder="Name" value=').concat(user.name, ' required="required" pattern="[a-zA-Z]*" title="Enter your name" maxlength="3" /></div>\n                <div class="column"><label class="profile-form-label">About </label><input class="input-text input-profile-about" type="text" placeholder="About you" required minlength="8" maxlength="100" title="At least 8 characters and maximum of 100 characters" value="').concat(user.about, '"/>\n                </div>\n                <div class="column"><label class="profile-form-label">Email </label><input class="input-text input-profile-email" type="email" required="required" value=').concat(user.email, ' /></div>\n                <p class="profile-err hide">Something went wrong </p><button class="btn profile-form-btn">save    </button>\n            </form>\n         </div>');
};
var previewImage = function previewImage() {
    var fileInput = document.getElementById("profile-photo");
    var previewImg = document.querySelector(".profile-img");
    fileInput.addEventListener("change", function(e) {
        var file = e.target.files[0];
        if (!file) return;
        var reader = new FileReader();
        reader.addEventListener("load", function(e) {
            return previewImg.src = e.target.result;
        });
        reader.readAsDataURL(file);
    });
};
var getUserDetails = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var res, user, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    _state.trys.push([
                        0,
                        2,
                        ,
                        3
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)("/api/v1/users/account")
                    ];
                case 1:
                    res = _state.sent();
                    user = res.data.data.user;
                    return [
                        2,
                        user
                    ];
                case 2:
                    err = _state.sent();
                    console.log(err);
                    return [
                        3,
                        3
                    ];
                case 3:
                    return [
                        2
                    ];
            }
        });
    });
    return function getUserDetails() {
        return _ref.apply(this, arguments);
    };
}();
var renderProfile = function() {
    var _ref = (0, _asyncToGenerator._)(function() {
        var user, markup;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    //   clearing everything
                    itemsContainer.innerHTML = "";
                    date.textContent = "".concat(now.getDate(), "/").concat(now.getMonth() + 1, "/").concat(now.getFullYear());
                    dashboardHeading.textContent = "Profile";
                    return [
                        4,
                        getUserDetails()
                    ];
                case 1:
                    user = _state.sent();
                    //  creating markup with current user
                    markup = getProfileMarkup(user);
                    // rendering the user profile
                    itemsContainer.insertAdjacentHTML("beforeend", markup);
                    return [
                        2
                    ];
            }
        });
    });
    return function renderProfile() {
        return _ref.apply(this, arguments);
    };
}();
var updateProfileDetails = function() {
    var _ref = (0, _asyncToGenerator._)(function(e) {
        var profileForm, form, fileImage, inputName, inputAbout, inputEmail, res, err;
        return (0, _tsGenerator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    // forms
                    profileForm = document.querySelector(".user-profile-form");
                    form = new FormData();
                    //image
                    fileImage = document.getElementById("profile-photo");
                    // inputs
                    inputName = document.querySelector(".input-profile-name");
                    inputAbout = document.querySelector(".input-profile-about");
                    inputEmail = document.querySelector(".input-profile-email");
                    if (!profileForm.checkValidity()) return [
                        2
                    ];
                    e.preventDefault();
                    if (fileImage.files.length > 0) form.append("profileImg", fileImage.files[0]);
                    form.append("name", inputName.value);
                    form.append("about", inputAbout.value);
                    form.append("email", inputEmail.value);
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        (0, _axiosDefault.default)({
                            method: "PATCH",
                            url: "/api/v1/users/update",
                            data: form
                        })
                    ];
                case 2:
                    res = _state.sent();
                    (0, _sweetalert2Default.default).fire(res.data.message);
                    location.assign("/profile");
                    return [
                        3,
                        4
                    ];
                case 3:
                    err = _state.sent();
                    console.log(err);
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function updateProfileDetails(e) {
        return _ref.apply(this, arguments);
    };
}();

},{"@swc/helpers/_/_async_to_generator":"6EzFB","@swc/helpers/_/_ts_generator":"dhhs4","axios":"eCZhQ","sweetalert2":"2OR50","@parcel/transformer-js/src/esmodule-helpers.js":"3XTd0"}]},["7m0pj","jDAbT"], "jDAbT", "parcelRequireb040")

//# sourceMappingURL=index.js.map
